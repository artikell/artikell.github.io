{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"source/images/joplin-excalidraw-example.gif","path":"images/joplin-excalidraw-example.gif","modified":0,"renderable":0},{"_id":"themes/cactus/source/css/rtl.styl","path":"css/rtl.styl","modified":0,"renderable":1},{"_id":"themes/cactus/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/cactus/source/images/apple-touch-icon.png","path":"images/apple-touch-icon.png","modified":0,"renderable":1},{"_id":"themes/cactus/source/images/favicon-192x192.png","path":"images/favicon-192x192.png","modified":0,"renderable":1},{"_id":"themes/cactus/source/images/favicon.ico","path":"images/favicon.ico","modified":0,"renderable":1},{"_id":"themes/cactus/source/images/logo.png","path":"images/logo.png","modified":0,"renderable":1},{"_id":"themes/cactus/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/cactus/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/clipboard/clipboard.min.js","path":"lib/clipboard/clipboard.min.js","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/jquery/jquery.min.js","path":"lib/jquery/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGL-Bold.ttf","path":"lib/meslo-LG/MesloLGL-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGL-BoldItalic.ttf","path":"lib/meslo-LG/MesloLGL-BoldItalic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGL-Italic.ttf","path":"lib/meslo-LG/MesloLGL-Italic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGL-Regular.ttf","path":"lib/meslo-LG/MesloLGL-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGM-BoldItalic.ttf","path":"lib/meslo-LG/MesloLGM-BoldItalic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGM-Bold.ttf","path":"lib/meslo-LG/MesloLGM-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGM-Italic.ttf","path":"lib/meslo-LG/MesloLGM-Italic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGM-Regular.ttf","path":"lib/meslo-LG/MesloLGM-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGS-Bold.ttf","path":"lib/meslo-LG/MesloLGS-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGS-BoldItalic.ttf","path":"lib/meslo-LG/MesloLGS-BoldItalic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGS-Regular.ttf","path":"lib/meslo-LG/MesloLGS-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGS-Italic.ttf","path":"lib/meslo-LG/MesloLGS-Italic.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Black.eot","path":"lib/vazir-font/Vazir-Black.eot","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Black.ttf","path":"lib/vazir-font/Vazir-Black.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Black.woff","path":"lib/vazir-font/Vazir-Black.woff","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Black.woff2","path":"lib/vazir-font/Vazir-Black.woff2","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Bold.eot","path":"lib/vazir-font/Vazir-Bold.eot","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Bold.ttf","path":"lib/vazir-font/Vazir-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Bold.woff","path":"lib/vazir-font/Vazir-Bold.woff","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Bold.woff2","path":"lib/vazir-font/Vazir-Bold.woff2","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Light.eot","path":"lib/vazir-font/Vazir-Light.eot","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Light.ttf","path":"lib/vazir-font/Vazir-Light.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Light.woff","path":"lib/vazir-font/Vazir-Light.woff","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Light.woff2","path":"lib/vazir-font/Vazir-Light.woff2","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Medium.eot","path":"lib/vazir-font/Vazir-Medium.eot","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Medium.ttf","path":"lib/vazir-font/Vazir-Medium.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Medium.woff","path":"lib/vazir-font/Vazir-Medium.woff","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Medium.woff2","path":"lib/vazir-font/Vazir-Medium.woff2","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Regular.eot","path":"lib/vazir-font/Vazir-Regular.eot","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Regular.ttf","path":"lib/vazir-font/Vazir-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Regular.woff","path":"lib/vazir-font/Vazir-Regular.woff","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Regular.woff2","path":"lib/vazir-font/Vazir-Regular.woff2","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Thin.eot","path":"lib/vazir-font/Vazir-Thin.eot","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Thin.ttf","path":"lib/vazir-font/Vazir-Thin.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Thin.woff","path":"lib/vazir-font/Vazir-Thin.woff","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Thin.woff2","path":"lib/vazir-font/Vazir-Thin.woff2","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Variable.eot","path":"lib/vazir-font/Vazir-Variable.eot","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Variable.ttf","path":"lib/vazir-font/Vazir-Variable.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Variable.woff","path":"lib/vazir-font/Vazir-Variable.woff","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Variable.woff2","path":"lib/vazir-font/Vazir-Variable.woff2","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/vazir-font/font-face.css","path":"lib/vazir-font/font-face.css","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-brands-400.ttf","path":"lib/font-awesome/webfonts/fa-brands-400.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-regular-400.ttf","path":"lib/font-awesome/webfonts/fa-regular-400.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-solid-900.ttf","path":"lib/font-awesome/webfonts/fa-solid-900.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-v4compatibility.ttf","path":"lib/font-awesome/webfonts/fa-v4compatibility.ttf","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-v4compatibility.woff2","path":"lib/font-awesome/webfonts/fa-v4compatibility.woff2","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/justified-gallery/css/justifiedGallery.min.css","path":"lib/justified-gallery/css/justifiedGallery.min.css","modified":0,"renderable":1},{"_id":"themes/cactus/source/lib/justified-gallery/js/jquery.justifiedGallery.min.js","path":"lib/justified-gallery/js/jquery.justifiedGallery.min.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/1月2日~1月8日-Redis周报.md","hash":"dec25532f6a4c60418df6b5f65ab31e1c5876a70","modified":1673281897615},{"_id":"source/_posts/Redis中的Failover机制.md","hash":"5135074e6990d0dcdc1d5528e6599875b4d0d164","modified":1672670250208},{"_id":"source/_posts/Redis中的内存统计.md","hash":"16ecb7eee5e8f804635595c63a163b59b014a0d0","modified":1672934244432},{"_id":"source/_posts/Redis中的Timeout处理.md","hash":"76d502368a59366652033aa8e4e0b09626f71185","modified":1673363264962},{"_id":"source/_posts/Redis新协议-RESP3.md","hash":"e11ea7419fd2ddc6e842844b89e7e0b1c0815761","modified":1673192729672},{"_id":"source/_posts/Redis的日志管理与复制.md","hash":"80618bcff9277fa84099efdd74ff6614141dd970","modified":1672667567926},{"_id":"source/_posts/hello-world.md","hash":"40e804610ff712f079ace7012b862b4efecf82fb","modified":1672589037669},{"_id":"source/_posts/关于syscheck，Redis需要什么样的服务器.md","hash":"50a50364fbacef638d0f4157dd334cc4c936a737","modified":1672844290421},{"_id":"source/about/index.ejs","hash":"c654cd306eb1119ad70991704150aa7daa82b4d1","modified":1673363357580},{"_id":"source/_posts/可怕的Debug命令.md","hash":"51725033e6ee011195ab14d9835998fa99d63fcc","modified":1672764461866},{"_id":"source/roadmap/index.md","hash":"536abdb847ad3a7f38475e491ab8422b92d2d70b","modified":1672654747188},{"_id":"source/link/index.md","hash":"79bbb20e079661bf3402e0bc998057031f6a3472","modified":1672656666402},{"_id":"themes/cactus/.gitignore","hash":"72267ee409a324fc197c150b3c4bf28b87b709a8","modified":1672559727718},{"_id":"themes/cactus/.jshintrc","hash":"2548bd6ce44422edc7e6f9f68061ab47f26c4f57","modified":1672559727719},{"_id":"themes/cactus/.stylintrc","hash":"eb5f48e83657928cb0cbee031373b2cd36ca0083","modified":1672559727719},{"_id":"themes/cactus/LICENSE","hash":"346ece39a983b0e7858c11f785cd846cef9eb875","modified":1672559727720},{"_id":"themes/cactus/gulpfile.js","hash":"3f073baa3d9ed36725e518606de61bcc317ad207","modified":1672559727722},{"_id":"themes/cactus/_config.yml","hash":"2b21c918ca081d6697ada6b96122037970fa1a71","modified":1672559727722},{"_id":"themes/cactus/README.md","hash":"778ff0b9caf666d2c0dc3413e26ffb862f354173","modified":1672559727721},{"_id":"themes/cactus/languages/ar.yml","hash":"81a88b0593fc89de3118d686681b1f69883c847b","modified":1672559727724},{"_id":"themes/cactus/languages/ca.yml","hash":"b79dd2c21dc6697c635e92db1f661a4b8d5d2305","modified":1672559727724},{"_id":"themes/cactus/languages/default.yml","hash":"6a84970bf69c3e9490e5382747ca2b4c4b4dccde","modified":1672559727726},{"_id":"themes/cactus/package.json","hash":"0eddf80e60a40d107585f7a8a512f7785cda8163","modified":1672559727752},{"_id":"themes/cactus/languages/es.yml","hash":"2b1fc8b0d636123e9ee39017fa20053bd1913a5a","modified":1672559727727},{"_id":"themes/cactus/languages/en.yml","hash":"6a84970bf69c3e9490e5382747ca2b4c4b4dccde","modified":1672559727726},{"_id":"themes/cactus/languages/de.yml","hash":"43b2f4e078b042aaae0377a4235216a51ed82e0d","modified":1672559727725},{"_id":"themes/cactus/languages/fr.yml","hash":"5c07406998f19d219a5a7b65c0d88b6b023f85b2","modified":1672559727728},{"_id":"themes/cactus/languages/nl.yml","hash":"ac0573352ad2c737a7686bcca498b985e7bd6447","modified":1672559727730},{"_id":"themes/cactus/languages/it.yml","hash":"62800bcae1f2d2454f87f4bcf4d7593848424f61","modified":1672559727729},{"_id":"themes/cactus/languages/pt-br.yml","hash":"4859aba788a050c2d5d0b997693b0c8c24b349f7","modified":1672559727731},{"_id":"themes/cactus/languages/pl.yml","hash":"8a2d6dc874d86c38d42c2c861c39590647b5d536","modified":1672559727731},{"_id":"themes/cactus/languages/fa.yml","hash":"63f32e50953af1c4bd0308a4fca5862b5287c2cb","modified":1672559727728},{"_id":"themes/cactus/languages/ru.yml","hash":"81b57fcd1977ef534f4bf303dbc1b4710cc7f057","modified":1672559727732},{"_id":"themes/cactus/languages/kr.yml","hash":"651fb83991c91b13b53ed55740e5402cf0f1c5e8","modified":1672559727729},{"_id":"themes/cactus/languages/tr.yml","hash":"2702914007e6bade9d6861078c0e179ac05bf48c","modified":1672559727733},{"_id":"themes/cactus/layout/404.ejs","hash":"b911da998c160cceb8cd7c4dae709a1374ed2491","modified":1672559727736},{"_id":"themes/cactus/languages/vi.yml","hash":"f84893c3ec3e45875c90069e14b17ed3016ed973","modified":1672559727733},{"_id":"themes/cactus/languages/zh-TW.yml","hash":"2f4e050c9b35a67f4a7278cec3a949533c2ac16a","modified":1672559727735},{"_id":"themes/cactus/languages/zh-CN.yml","hash":"d016060817311addb4c528de440126b975038c31","modified":1672559727734},{"_id":"themes/cactus/layout/index.ejs","hash":"0b880a0f497ea597bf5213b4210c852508a5d559","modified":1672559727749},{"_id":"themes/cactus/scripts/error_404.js","hash":"f83b290e47cb78a2754152fccc34e571a72087bd","modified":1672559727753},{"_id":"themes/cactus/scripts/cdn.js","hash":"887edec364d51efa7c524446483188c6ad05adaf","modified":1672559727753},{"_id":"themes/cactus/layout/page.ejs","hash":"c5465d5315a7544aa466b01fd8cfb62917a8bb1d","modified":1672559727751},{"_id":"themes/cactus/layout/layout.ejs","hash":"8504004f2ed78914f806c6699d9bd722318cbe56","modified":1672559727750},{"_id":"themes/cactus/layout/post.ejs","hash":"f9149f294e6142437c58784c41f1d082a61c8b82","modified":1672559727751},{"_id":"themes/cactus/scripts/page_title.js","hash":"fa662dbdb82779af1b95e35ed7ccdf4866a53dee","modified":1672559727755},{"_id":"themes/cactus/layout/archive.ejs","hash":"5a23d506dd65f9b5fd1d44a73d5e04c935a899e2","modified":1672559727749},{"_id":"themes/cactus/scripts/meta.js","hash":"654868666b6573b2cee7e750b47ad8a3c2ee13a0","modified":1672559727755},{"_id":"themes/cactus/layout/_partial/comments.ejs","hash":"4e75035a427fd137ae7f12940209e8e97845df3b","modified":1672559727736},{"_id":"themes/cactus/scripts/thumbnail.js","hash":"df8829fd8c3119650037eba5ec11bdce06acff9d","modified":1672559727756},{"_id":"themes/cactus/scripts/merge-configs.js","hash":"2048c3415d96b17b9d84aa44bc0c25f1210525f8","modified":1672559727754},{"_id":"themes/cactus/layout/_partial/header.ejs","hash":"0e06ee826de1af22a63626456ceb8f2b6c0d1555","modified":1672559727739},{"_id":"themes/cactus/layout/_partial/footer.ejs","hash":"12fd63b51472c9c5b8b7d167eb1a96bf1d686c20","modified":1672559727737},{"_id":"themes/cactus/layout/_partial/pagination.ejs","hash":"23bf862b3b8a3cd831850504d9b5a24d21b005e7","modified":1672559727740},{"_id":"themes/cactus/layout/_partial/head.ejs","hash":"95526bec071998144ee0b0fc33f39bb74e5e9c4f","modified":1672559727738},{"_id":"themes/cactus/source/css/_mixins.styl","hash":"1a9e309523df9685e8d088dcff0a809c58e2c392","modified":1672559727811},{"_id":"themes/cactus/source/css/_variables.styl","hash":"69d9c5e95edcaee5ccd8218262b989ce721cce79","modified":1672559727822},{"_id":"themes/cactus/source/css/_fonts.styl","hash":"354809b5a64e8a47a66c66fd1a28ac597c1460a6","modified":1672559727761},{"_id":"themes/cactus/source/css/_extend.styl","hash":"b6a4e5905a7515dda66919167531a5ab2b3d1fe2","modified":1672559727760},{"_id":"themes/cactus/source/css/_util.styl","hash":"2bfeb2e2605dd5235693b00c71a212646d2e0410","modified":1672559727821},{"_id":"themes/cactus/layout/_partial/scripts.ejs","hash":"a901e3c89e4cd1d20a87bfc683b64b6818275946","modified":1672559727747},{"_id":"themes/cactus/layout/_partial/styles.ejs","hash":"c6bc7e8a422c5bb57f88fed1d1b0694d03e24e74","modified":1672559727748},{"_id":"themes/cactus/source/css/rtl.styl","hash":"ff8700e1626feeb53d905a2df2777bda7d1eca50","modified":1672559727822},{"_id":"themes/cactus/source/css/style.styl","hash":"5d8afa50dd27d083e09d3b09106f98de46e3c7d0","modified":1672559727823},{"_id":"themes/cactus/source/images/favicon-192x192.png","hash":"96e6fcbbb13a5914a6131391e210eb7dfd13d692","modified":1672559727825},{"_id":"themes/cactus/source/images/apple-touch-icon.png","hash":"57e2def34682655f41a0be2d083f16765ba7858b","modified":1672559727824},{"_id":"themes/cactus/source/js/main.js","hash":"619ac6529d140711e3b14f739a192bb31c4824ff","modified":1672559727829},{"_id":"themes/cactus/layout/_partial/search.ejs","hash":"8b4bf9cf5db0ce762a31fc3baae0f2fc004bece4","modified":1672559727747},{"_id":"themes/cactus/layout/_partial/post/actions_desktop.ejs","hash":"aa6218d8d5af1e26e7a0d805b1ea864eca2b88c5","modified":1672559727741},{"_id":"themes/cactus/source/js/search.js","hash":"914a2ce72fb325106c61600200be823b72bfb39f","modified":1672559727829},{"_id":"themes/cactus/source/images/favicon.ico","hash":"189f9842bcb79a6f8f9e8445bc8bbd773443826b","modified":1672559727826},{"_id":"themes/cactus/layout/_partial/post/date.ejs","hash":"6f2d1aa9562df343b797d25705f1945323c465fb","modified":1672559727743},{"_id":"themes/cactus/layout/_partial/post/actions_mobile.ejs","hash":"79b234ff3c264e66b2e71c819228e62bf92b48e4","modified":1672559727742},{"_id":"themes/cactus/layout/_partial/post/category.ejs","hash":"b5bfa049f17868fb09d9d2a7e1d5279fa0381d37","modified":1672559727743},{"_id":"themes/cactus/layout/_partial/post/share.ejs","hash":"1a294382bd14d979525b8ed934d807bc7d083e4d","modified":1672559727745},{"_id":"themes/cactus/layout/_partial/post/title.ejs","hash":"a060f1c6e3718494a6b1d0e1981ea0bf4e549828","modified":1672559727746},{"_id":"themes/cactus/layout/_partial/post/gallery.ejs","hash":"9aecd8908e8a684f33dc20c02497c0f1774137c7","modified":1672559727744},{"_id":"themes/cactus/source/css/_colors/classic.styl","hash":"bc09f8777a6c99030da953dfdb84f793c5e4fd85","modified":1672559727758},{"_id":"themes/cactus/layout/_partial/post/tag.ejs","hash":"e08fae30da060f49c087f6c121868b08eb55c795","modified":1672559727745},{"_id":"themes/cactus/source/css/_colors/light.styl","hash":"d14ef1aa02d0895b6f9321ebfc23a1ec84b054b8","modified":1672559727759},{"_id":"themes/cactus/source/css/_highlight/agate.styl","hash":"53027913ed8d4f75ac3e49e76aad824f0df62da3","modified":1672559727762},{"_id":"themes/cactus/source/css/_colors/dark.styl","hash":"9aa43b1f23d5d268dfa36bd942d6ce97b7677c4d","modified":1672559727758},{"_id":"themes/cactus/source/css/_colors/white.styl","hash":"88e93a9d3fe1d0270d65cabdeacc18bd94d45937","modified":1672559727760},{"_id":"themes/cactus/source/css/_highlight/arduino-light.styl","hash":"15e8572585cd708221c513dea4bdd89d8fe56c10","modified":1672559727764},{"_id":"themes/cactus/source/css/_highlight/atelier-cave-dark.styl","hash":"ce63dd8548688d88254405eedfa75b1d7c82449e","modified":1672559727766},{"_id":"themes/cactus/source/css/_highlight/ascetic.styl","hash":"32cff3bef6fac3760fe78f203096477052a90552","modified":1672559727765},{"_id":"themes/cactus/source/css/_highlight/atelier-cave-light.styl","hash":"a5be0744a7ecf4a08f600ade4cfd555afc67bc15","modified":1672559727767},{"_id":"themes/cactus/source/css/_highlight/androidstudio.styl","hash":"2af0861725f97f0ee2ded67c3d2d4548c62b2d16","modified":1672559727763},{"_id":"themes/cactus/source/css/_highlight/atelier-estuary-dark.styl","hash":"0bb16a4eff93688f40787abc2f9e56e7d5cc93e7","modified":1672559727768},{"_id":"themes/cactus/source/css/_highlight/arta.styl","hash":"b3e81e3e694ceb8deed178adb8b91013c5120e30","modified":1672559727765},{"_id":"themes/cactus/source/css/_highlight/atelier-dune-light.styl","hash":"931435fbc6f974e8ce9e32722680035d248a9dc1","modified":1672559727768},{"_id":"themes/cactus/source/css/_highlight/atelier-forest-dark.styl","hash":"effbc5d75fa87203c847039869c22031b40d5b7d","modified":1672559727770},{"_id":"themes/cactus/source/css/_highlight/atelier-forest-light.styl","hash":"95228d9f2102fad425536aac44b80b2cba1f5950","modified":1672559727771},{"_id":"themes/cactus/source/css/_highlight/atelier-estuary-light.styl","hash":"344276ca9b27e51d4c907f76afe5d13cf8e60bdf","modified":1672559727769},{"_id":"themes/cactus/source/css/_highlight/atelier-dune-dark.styl","hash":"c196ff0ee064af0e507823694ae39020addfc280","modified":1672559727767},{"_id":"themes/cactus/source/css/_highlight/atelier-heath-light.styl","hash":"8c8c2e445abef85273be966d59770e9ced6aac21","modified":1672559727772},{"_id":"themes/cactus/source/css/_highlight/atelier-heath-dark.styl","hash":"9a2e9a1d0a01bbdf158560c3ed1c134e098b2c68","modified":1672559727771},{"_id":"themes/cactus/source/css/_highlight/atelier-lakeside-light.styl","hash":"2c54cb9bdb259ae3b5b29f63ac2469ed34b08578","modified":1672559727774},{"_id":"themes/cactus/source/css/_highlight/atelier-plateau-dark.styl","hash":"84c80e6f67f62fce958d25817c277d2360272617","modified":1672559727774},{"_id":"themes/cactus/source/css/_highlight/atelier-lakeside-dark.styl","hash":"10ee3882fca7b97a37bd309d2d35fce9868647bb","modified":1672559727773},{"_id":"themes/cactus/source/css/_highlight/atelier-savanna-light.styl","hash":"f8244c93711c7cb59dd79d2df966806b30d171ea","modified":1672559727776},{"_id":"themes/cactus/source/css/_highlight/atelier-sulphurpool-dark.styl","hash":"538a14321193cd8abf2ddc484306631e54149ffb","modified":1672559727778},{"_id":"themes/cactus/source/css/_highlight/atelier-sulphurpool-light.styl","hash":"efa52713efc468abeeb2b9299704371583b857de","modified":1672559727779},{"_id":"themes/cactus/source/css/_highlight/atelier-savanna-dark.styl","hash":"e32c1c70def8060fce5e790979a126da650ac642","modified":1672559727776},{"_id":"themes/cactus/source/css/_highlight/atelier-seaside-light.styl","hash":"0597342da6e2d0c5bdcc7d42dabb07322b1a4177","modified":1672559727778},{"_id":"themes/cactus/source/css/_highlight/codepen-embed.styl","hash":"8b7b34484f76a6c2c3b1a9e49abb9b382f439ae8","modified":1672559727781},{"_id":"themes/cactus/source/css/_highlight/brown-paper.styl","hash":"c2326ba20a5020a66ca7895258d18833327d4334","modified":1672559727780},{"_id":"themes/cactus/source/css/_highlight/atelier-plateau-light.styl","hash":"d1a05fdd1ededc9063d181ab25bad55a164aeb4a","modified":1672559727775},{"_id":"themes/cactus/source/css/_highlight/color-brewer.styl","hash":"2a439d6214430e2f45dd4939b4dfe1fe1a20aa0f","modified":1672559727782},{"_id":"themes/cactus/source/css/_highlight/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1672559727780},{"_id":"themes/cactus/source/css/_highlight/atelier-seaside-dark.styl","hash":"2edf385215bbe1985b1a10106525d362667d28c2","modified":1672559727777},{"_id":"themes/cactus/source/css/_highlight/darkula.styl","hash":"9717efa9194837ba3fb4d762997d33075dcf8bfa","modified":1672559727783},{"_id":"themes/cactus/source/css/_highlight/far.styl","hash":"aaac3028f5e33123cd123a583cddc9290c45ec8e","modified":1672559727784},{"_id":"themes/cactus/source/css/_highlight/docco.styl","hash":"b1c176378bb275f2e8caa759f36294e42d614bf1","modified":1672559727784},{"_id":"themes/cactus/source/css/_highlight/github-gist.styl","hash":"48211a03d33e7f7ada0b261162bea06676155a71","modified":1672559727786},{"_id":"themes/cactus/source/css/_highlight/foundation.styl","hash":"bf8ddc94b4ad995b8b8805b5a4cf95004553fdac","modified":1672559727785},{"_id":"themes/cactus/source/css/_highlight/github.styl","hash":"3336aeba324c6d34a6fd41fef9b47bc598f7064c","modified":1672559727786},{"_id":"themes/cactus/source/css/_highlight/highlightjs.styl","hash":"0e198b7a59191c7a39b641a4ddd22c948edb9358","modified":1672559727789},{"_id":"themes/cactus/source/css/_highlight/gruvbox-dark.styl","hash":"76b744c14fd5600bea64731c05df97c2df75523f","modified":1672559727789},{"_id":"themes/cactus/source/css/_highlight/grayscale.styl","hash":"bf37d8b8d1e602126c51526f0cc28807440228ed","modified":1672559727787},{"_id":"themes/cactus/source/css/_highlight/dark.styl","hash":"f5e6e75958de59e87fc6be3a1668e870e20bc836","modified":1672559727782},{"_id":"themes/cactus/source/css/_highlight/hopscotch.styl","hash":"1378a6bc67a32c0cbff72ab771268b53f9aa586d","modified":1672559727790},{"_id":"themes/cactus/source/css/_highlight/index.styl","hash":"002d5596f6379cc87dbd43d9145bc764aa666be1","modified":1672559727792},{"_id":"themes/cactus/source/css/_highlight/googlecode.styl","hash":"bda816beee7b439814b514e6869dc678822be1bc","modified":1672559727787},{"_id":"themes/cactus/source/css/_highlight/idea.styl","hash":"a02967cb51c16a34e0ee895d33ded2b823d35b21","modified":1672559727791},{"_id":"themes/cactus/source/css/_highlight/kimbie.dark.styl","hash":"45dbb168f22d739d0109745d2decd66b5f94e786","modified":1672559727793},{"_id":"themes/cactus/source/css/_highlight/ir-black.styl","hash":"53e5d74326a4527b92272bbd6946d4fec92720e8","modified":1672559727793},{"_id":"themes/cactus/source/css/_highlight/magula.styl","hash":"16d323f989b1420a0f72ef989242ece9bf17a456","modified":1672559727795},{"_id":"themes/cactus/source/css/_highlight/kimbie.light.styl","hash":"61f8baed25be05288c8604d5070afbcd9f183f49","modified":1672559727794},{"_id":"themes/cactus/source/css/_highlight/mono-blue.styl","hash":"4c89a6ae29de67c0700585af82a60607e85df928","modified":1672559727796},{"_id":"themes/cactus/source/css/_highlight/hybrid.styl","hash":"b8eb5c69d12f2ee5ebc50265ae271699d7f1a8d3","modified":1672559727791},{"_id":"themes/cactus/source/css/_highlight/monokai-sublime.styl","hash":"c385b11345894be7e6ce3c5f08663e199933b8e4","modified":1672559727797},{"_id":"themes/cactus/source/css/_highlight/kimbie.styl","hash":"51b889ca7c6fe178cfbbe28d875a6ea427184441","modified":1672559727794},{"_id":"themes/cactus/source/css/_highlight/paraiso-light.styl","hash":"d224d1df0eb3395d9eea1344cee945c228af2911","modified":1672559727799},{"_id":"themes/cactus/source/css/_highlight/obsidian.styl","hash":"199e28326be8590883f0813ebbd54fcfaa4750fd","modified":1672559727798},{"_id":"themes/cactus/source/css/_highlight/paraiso.styl","hash":"75f181eece6b71d033ea0c8d6cf00ae7efb9e29b","modified":1672559727800},{"_id":"themes/cactus/source/css/_highlight/paraiso-dark.styl","hash":"f1537bd868579fa018ecdbfd2eb922dcf3ba2cac","modified":1672559727798},{"_id":"themes/cactus/source/css/_highlight/railscasts.styl","hash":"b6674db9210e0c4444e4835fff2d1361f3ebd64c","modified":1672559727802},{"_id":"themes/cactus/source/css/_highlight/pojoaque.jpg","hash":"c5fe6533b88b21f8d90d3d03954c6b29baa67791","modified":1672559727800},{"_id":"themes/cactus/source/css/_highlight/pojoaque.styl","hash":"4e7b6b046b8575ac749f6aec4e953a62ada27a36","modified":1672559727801},{"_id":"themes/cactus/source/css/_highlight/monokai.styl","hash":"f87be027848ea6bee623a08ad1e17b2f5b7937ee","modified":1672559727797},{"_id":"themes/cactus/source/css/_highlight/solarized-dark.styl","hash":"90c9da5aa594383697e5b18892a7f95beb053f55","modified":1672559727804},{"_id":"themes/cactus/source/css/_highlight/solarized-light.styl","hash":"aa0dd3fd25c464183b59c5575c9bee8756b397f2","modified":1672559727805},{"_id":"themes/cactus/source/css/_highlight/rainbow.styl","hash":"c0cf97aae3e10fdcd10414547a711c9effbc39b8","modified":1672559727802},{"_id":"themes/cactus/source/css/_highlight/tomorrow-night-bright.styl","hash":"7674fecb6d27350727dc0d2dc93bc018382ebbd0","modified":1672559727807},{"_id":"themes/cactus/source/css/_highlight/school-book.styl","hash":"d43560fe519a931ce6da7d57416d7aa148441b83","modified":1672559727803},{"_id":"themes/cactus/source/css/_highlight/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1672559727803},{"_id":"themes/cactus/source/css/_highlight/tomorrow-night-blue.styl","hash":"f24c17d0ab815dcfaab3438cb9fe2ab4839f5e0d","modified":1672559727806},{"_id":"themes/cactus/source/css/_highlight/tomorrow-night-eighties.styl","hash":"28d751075ebabf7d0327a36f725076fe82fdf626","modified":1672559727808},{"_id":"themes/cactus/source/css/_highlight/zenburn.styl","hash":"68ff9332ccc03f9389b15b713415cde016f8088f","modified":1672559727811},{"_id":"themes/cactus/source/css/_highlight/tomorrow-night.styl","hash":"16ba09b2db501e4e3e2e7d62595d9bf935bf27c4","modified":1672559727808},{"_id":"themes/cactus/source/css/_highlight/xcode.styl","hash":"5e8532ae8366dcf6a4ef5e4813dc3d42ab3d0a50","modified":1672559727810},{"_id":"themes/cactus/source/css/_highlight/tomorrow.styl","hash":"15779cf6846725c7c35fc56cac39047d7e0aec1c","modified":1672559727809},{"_id":"themes/cactus/source/css/_highlight/vs.styl","hash":"959a746f4b37aacb5d1d6ff1d57e0c045289d75d","modified":1672559727809},{"_id":"themes/cactus/source/css/_partial/article.styl","hash":"258370d8ab98e63804ead9bc030f633ca97a1235","modified":1672559727813},{"_id":"themes/cactus/source/css/_highlight/sunburst.styl","hash":"af3eec0fd56151e55bbd49c31b151f36717611d8","modified":1672559727805},{"_id":"themes/cactus/source/css/_partial/categories.styl","hash":"a43f00e61b3507f130b8a3f8108a4eeca147c2a0","modified":1672559727814},{"_id":"themes/cactus/source/css/_partial/footer.styl","hash":"61c2c7c5f73a0022ec41830bea0812a97f522d7c","modified":1672559727815},{"_id":"themes/cactus/source/css/_partial/archive.styl","hash":"31aef892437d5734a134c34f2a8a6610a8f671c3","modified":1672559727812},{"_id":"themes/cactus/source/css/_partial/search.styl","hash":"159be002780c62a77f46947cf854a7342fba24f4","modified":1672559727819},{"_id":"themes/cactus/source/css/_partial/comments.styl","hash":"1e90f1fb9d4c155df518cacb5a537e9de9c042c1","modified":1672559727814},{"_id":"themes/cactus/source/css/_partial/header.styl","hash":"7f18929e7f4ad6d20da374e8b9f85ce587220a87","modified":1672559727816},{"_id":"themes/cactus/source/css/_partial/tooltip.styl","hash":"2daff581ec3efaec840cbfdee512195919c32629","modified":1672559727820},{"_id":"themes/cactus/source/css/_partial/tags.styl","hash":"d571d5c7c960300d29c5f0ec3fe1140322ecd6b3","modified":1672559727819},{"_id":"themes/cactus/source/css/_partial/pagination.styl","hash":"950bf517bbe7adb9a9aa4eb5ddec74ffc7598787","modified":1672559727817},{"_id":"themes/cactus/source/css/_partial/index.styl","hash":"59c99f4ea3a73bf47ce030df166c5e33d5de31fb","modified":1672559727816},{"_id":"themes/cactus/source/lib/clipboard/clipboard.min.js","hash":"6674f81dd01c76be986cf0a8172d1073e56d7ef4","modified":1672559727830},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Black.woff","hash":"f6fda2de0348b3e3b7de73267f9f8e97a62f8353","modified":1672559727880},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Black.woff2","hash":"7ea4fd7dd4cd4f480af78a0e2c5849eb921b1aeb","modified":1672559727881},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Bold.woff","hash":"56e632c9196fac364c66f812a3b4635dd999ad1c","modified":1672559727885},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Bold.woff2","hash":"6e40d0c7669c1adbcbf034bdc459f7bed4d6676d","modified":1672559727885},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Light.woff","hash":"1c3dbf17411b1f6a6b22c2b76e9d8511586643d0","modified":1672559727889},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Light.woff2","hash":"50b654d916204c30987d1987abd890ef92085ae3","modified":1672559727890},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Medium.woff","hash":"43a8aaa3fca8721dd32a5d20f7a98dfbc87c97fd","modified":1672559727894},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Medium.woff2","hash":"14b3e257c51a6a11d23b2a078017ff340c9777e4","modified":1672559727895},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Regular.woff2","hash":"a9714ffb842afc74836e64de04b52d8c37c87c8a","modified":1672559727899},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Thin.woff","hash":"c0e784de2eb5261cca244928f8a81fd893c3fe16","modified":1672559727902},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Thin.woff2","hash":"9b03b1a9071709f5b7dbca13412ecef6cb7a2a67","modified":1672559727903},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Variable.woff2","hash":"e213bb26bc7f10e1df3fe2d03d3ecaecd6e6d371","modified":1672559727908},{"_id":"themes/cactus/source/lib/vazir-font/font-face.css","hash":"ba0030e1cd28a8caa7a5bb74b98da7c7bb185c90","modified":1672559727908},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Regular.woff","hash":"235889d59ddad2b1f3243ccaab7733bd713a2a21","modified":1672559727898},{"_id":"themes/cactus/source/css/_partial/post/actions_desktop.styl","hash":"a1f36f9a3fd5ffcd832bf39e9402678978035d48","modified":1672559727817},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Variable.woff","hash":"2e8e6d38d361def5f48baac366f04e3db3ed4828","modified":1672559727907},{"_id":"themes/cactus/source/css/_partial/post/actions_mobile.styl","hash":"0d2966c1d870392476864af8ee3ba312ba30cb82","modified":1672559727818},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-v4compatibility.woff2","hash":"60d794c18c2b58b2b76d2ce17b85c44c48fb2efd","modified":1672559727844},{"_id":"themes/cactus/source/lib/justified-gallery/css/justifiedGallery.min.css","hash":"dd3052149d3054f35efb823c68dd78e78aad5875","modified":1672559727847},{"_id":"themes/cactus/source/lib/justified-gallery/js/jquery.justifiedGallery.min.js","hash":"ad8f48b4022498078b089fcdd1e8b47faf496931","modified":1672559727848},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"be22b700cc80c242da898ef8b7bb96adc4e0899f","modified":1672559727837},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-regular-400.ttf","hash":"d1a7eff18db8a47207ea42e34e9d9fbcc66a97a7","modified":1672559727837},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-v4compatibility.ttf","hash":"c77fcea87e0c4953f2b0ac92dc49a31c664b6ef7","modified":1672559727843},{"_id":"themes/cactus/source/lib/jquery/jquery.min.js","hash":"b82d238d4e31fdf618bae8ac11a6c812c03dd0d4","modified":1672559727846},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Black.ttf","hash":"b65915e3fa57b5c19995d15dc2341d115c1971b9","modified":1672559727879},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Bold.eot","hash":"5c1c680fade45393e4a5bb4548a092cd5ea6811e","modified":1672559727882},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Black.eot","hash":"91152bd73e7ff8d943e3bde3ddb0fa0a018e1c21","modified":1672559727878},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Bold.ttf","hash":"122bb778b17a152c426a825ee981610a4bd59bf3","modified":1672559727884},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Light.eot","hash":"a059359e9bea17dc2ff2ede955a05bf0dc4d00d0","modified":1672559727887},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Light.ttf","hash":"df82b80c4d3b11e70dcd269fc62ac97cbfa0414d","modified":1672559727888},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Medium.ttf","hash":"948a091f0fdb8c7ae17d5ef8e51bd8830d65dd9a","modified":1672559727893},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Medium.eot","hash":"d9ec1f9f3fefd57e446cbe86dc297f1ff269b6de","modified":1672559727892},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Regular.ttf","hash":"643c28c8f8a2bce1a0d62525aa045cd9883773cd","modified":1672559727897},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Regular.eot","hash":"521c01f0eb79a48025e972ecbe21b0d7fb15437b","modified":1672559727896},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Thin.eot","hash":"a0ea0bdaef00b35544f9a21d25d35db9a79f7189","modified":1672559727900},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Variable.eot","hash":"af46f7f4e10a1440a4c97b350622d279143e6798","modified":1672559727905},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Thin.ttf","hash":"6aacb0eecb03c660570b6e159ba5ca97ca7461cf","modified":1672559727901},{"_id":"themes/cactus/source/lib/font-awesome/css/all.min.css","hash":"d3cafed4c6596253c1050ee63897aa0f440e4f65","modified":1672559727832},{"_id":"themes/cactus/source/lib/vazir-font/Vazir-Variable.ttf","hash":"1e08b6373c2e086f24776df9b11e4be6bbcc8a4a","modified":1672559727906},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"98564e5517b7b455e80b2cd503e7bb3b52beb930","modified":1672559727835},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-brands-400.ttf","hash":"cfb2c6122bd53141e939ee4ff991a16a29d1bdce","modified":1672559727834},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"09a731f80844483614ff12f86ccbe41db6736cb5","modified":1672559727843},{"_id":"themes/cactus/source/images/logo.png","hash":"0e3029251dfda26adee2761f71377297e8c26871","modified":1672559727828},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGL-BoldItalic.ttf","hash":"b7d24ab1e4fad720f31a2b0cca1904ce1740d846","modified":1672559727860},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGM-BoldItalic.ttf","hash":"b542b9591fbf33925d93f0695b6e123a9f0cfd43","modified":1672559727868},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGS-BoldItalic.ttf","hash":"926035f0156cccf1b0ca507347f39bf9c510f51e","modified":1672559727874},{"_id":"themes/cactus/source/lib/font-awesome/webfonts/fa-solid-900.ttf","hash":"97f5404656d9547666479ec64c336467000656ef","modified":1672559727841},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGL-Italic.ttf","hash":"9a23c6898b0943bd3d96c04df9a0f66e919451d8","modified":1672559727863},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGM-Italic.ttf","hash":"93ebc5098cf57a32b7b8d297681f31692c09bdfa","modified":1672559727869},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGS-Italic.ttf","hash":"9d757cc9f928fc83b2133283dd639c12b11d94ad","modified":1672559727875},{"_id":"source/images/joplin-excalidraw-example.gif","hash":"159b4b46bc554071bb4026cf169267051b2bab64","modified":1678500792088},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGL-Bold.ttf","hash":"34f7db59f1d023294e69976aa20b7d52b86165a4","modified":1672559727857},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGL-Regular.ttf","hash":"6c090d6bff3928fbf8a5f4104e58ed7f421aea7c","modified":1672559727864},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGS-Bold.ttf","hash":"f9918fb93d6ab6850f5d38069a999c311af78816","modified":1672559727872},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGM-Bold.ttf","hash":"58be4b7760e9a84daa81929d046f9a15c4fd1c1a","modified":1672559727865},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGM-Regular.ttf","hash":"20ce1fc7ae1254558ca044ae48283faaa58897e5","modified":1672559727871},{"_id":"themes/cactus/source/lib/meslo-LG/MesloLGS-Regular.ttf","hash":"de559f8d70d5b1ab2810597bfd0b1b9506f3ef01","modified":1672559727876},{"_id":"public/baidusitemap.xml","hash":"1a7d27e65316ee1ff6882f943cf6dca745a03af7","modified":1678500908166},{"_id":"public/about/index.html","hash":"a9bbcc440ec44fcb05c145da3367700f08075f11","modified":1678500908166},{"_id":"public/link/index.html","hash":"3956bab9e18fbc3bd0f577f943481ff015a90480","modified":1678500908166},{"_id":"public/roadmap/index.html","hash":"f38d70fb439db2373b19edb70e50430cd9e278bc","modified":1678500908166},{"_id":"public/archives/index.html","hash":"86f34f6c1a70fbaf98f938f48a704828df4aea70","modified":1678500908166},{"_id":"public/archives/2023/index.html","hash":"7ceea85d77d9ab4e067c494e2bc8135db02ee81a","modified":1678500908166},{"_id":"public/archives/2023/01/index.html","hash":"1241f4541b5e9b7c9f3d98504db1842b35ad61ec","modified":1678500908166},{"_id":"public/index.html","hash":"053d2827dbfab4f0d2de12ed5f7ca82635453544","modified":1678500908166},{"_id":"public/404.html","hash":"0ac0fa94817d1eed39ebd11c60ac2118a5536ca9","modified":1678500908166},{"_id":"public/2023/01/10/Redis中的Timeout处理/index.html","hash":"e850620d9160d19f007d4e0b48e39f45405f9b11","modified":1678500908166},{"_id":"public/2023/01/10/1月2日~1月8日-Redis周报/index.html","hash":"b729be21a5056678157470acfedbcc0820451857","modified":1678500908166},{"_id":"public/2023/01/05/Redis中的内存统计/index.html","hash":"497d5508c1baf18fb35bae7a9a9dc7dec8087527","modified":1678500908166},{"_id":"public/2023/01/08/Redis新协议-RESP3/index.html","hash":"f1036cffd22d141775e9106193fd3fe6078056b0","modified":1678500908166},{"_id":"public/2023/01/04/可怕的Debug命令/index.html","hash":"56285560d7a13bb5d4682914cb741d290186544b","modified":1678500908166},{"_id":"public/2023/01/04/关于syscheck，Redis需要什么样的服务器/index.html","hash":"b55f2c7e49b2e8e5acf9aa7d608710ef2eddf136","modified":1678500908166},{"_id":"public/2023/01/02/Redis中的Failover机制/index.html","hash":"a7bdd0d7b1b2a9465983e77a8e3859f7f589eda5","modified":1678500908166},{"_id":"public/2023/01/02/Redis的日志管理与复制/index.html","hash":"f406f7fa9a60d0fba8dbd60ce6e6747a5e094216","modified":1678500908166},{"_id":"public/2023/01/02/hello-world/index.html","hash":"315ef62abc4974969baade7ea9a3af8e92260fb3","modified":1678500908166},{"_id":"public/images/apple-touch-icon.png","hash":"57e2def34682655f41a0be2d083f16765ba7858b","modified":1678500908166},{"_id":"public/images/favicon-192x192.png","hash":"96e6fcbbb13a5914a6131391e210eb7dfd13d692","modified":1678500908166},{"_id":"public/images/favicon.ico","hash":"189f9842bcb79a6f8f9e8445bc8bbd773443826b","modified":1678500908166},{"_id":"public/lib/vazir-font/Vazir-Black.woff","hash":"f6fda2de0348b3e3b7de73267f9f8e97a62f8353","modified":1678500908166},{"_id":"public/lib/vazir-font/Vazir-Black.woff2","hash":"7ea4fd7dd4cd4f480af78a0e2c5849eb921b1aeb","modified":1678500908166},{"_id":"public/lib/vazir-font/Vazir-Bold.woff","hash":"56e632c9196fac364c66f812a3b4635dd999ad1c","modified":1678500908166},{"_id":"public/lib/vazir-font/Vazir-Bold.woff2","hash":"6e40d0c7669c1adbcbf034bdc459f7bed4d6676d","modified":1678500908166},{"_id":"public/lib/vazir-font/Vazir-Light.woff2","hash":"50b654d916204c30987d1987abd890ef92085ae3","modified":1678500908166},{"_id":"public/lib/vazir-font/Vazir-Light.woff","hash":"1c3dbf17411b1f6a6b22c2b76e9d8511586643d0","modified":1678500908166},{"_id":"public/lib/vazir-font/Vazir-Medium.woff","hash":"43a8aaa3fca8721dd32a5d20f7a98dfbc87c97fd","modified":1678500908166},{"_id":"public/lib/vazir-font/Vazir-Medium.woff2","hash":"14b3e257c51a6a11d23b2a078017ff340c9777e4","modified":1678500908166},{"_id":"public/lib/vazir-font/Vazir-Regular.woff2","hash":"a9714ffb842afc74836e64de04b52d8c37c87c8a","modified":1678500908166},{"_id":"public/lib/vazir-font/Vazir-Regular.woff","hash":"235889d59ddad2b1f3243ccaab7733bd713a2a21","modified":1678500908166},{"_id":"public/lib/vazir-font/Vazir-Thin.woff","hash":"c0e784de2eb5261cca244928f8a81fd893c3fe16","modified":1678500908166},{"_id":"public/lib/vazir-font/Vazir-Thin.woff2","hash":"9b03b1a9071709f5b7dbca13412ecef6cb7a2a67","modified":1678500908166},{"_id":"public/lib/vazir-font/Vazir-Variable.woff","hash":"2e8e6d38d361def5f48baac366f04e3db3ed4828","modified":1678500908166},{"_id":"public/lib/vazir-font/Vazir-Variable.woff2","hash":"e213bb26bc7f10e1df3fe2d03d3ecaecd6e6d371","modified":1678500908166},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.ttf","hash":"d1a7eff18db8a47207ea42e34e9d9fbcc66a97a7","modified":1678500908166},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"be22b700cc80c242da898ef8b7bb96adc4e0899f","modified":1678500908166},{"_id":"public/lib/font-awesome/webfonts/fa-v4compatibility.woff2","hash":"60d794c18c2b58b2b76d2ce17b85c44c48fb2efd","modified":1678500908166},{"_id":"public/lib/font-awesome/webfonts/fa-v4compatibility.ttf","hash":"c77fcea87e0c4953f2b0ac92dc49a31c664b6ef7","modified":1678500908166},{"_id":"public/css/rtl.css","hash":"9589fac02a34fd9084f805f801889028756bbb65","modified":1678500908166},{"_id":"public/js/search.js","hash":"914a2ce72fb325106c61600200be823b72bfb39f","modified":1678500908166},{"_id":"public/js/main.js","hash":"619ac6529d140711e3b14f739a192bb31c4824ff","modified":1678500908166},{"_id":"public/lib/clipboard/clipboard.min.js","hash":"6674f81dd01c76be986cf0a8172d1073e56d7ef4","modified":1678500908166},{"_id":"public/css/style.css","hash":"350ef411c4855773b2f8e0e1fe2e9eb90d540888","modified":1678500908166},{"_id":"public/lib/jquery/jquery.min.js","hash":"b82d238d4e31fdf618bae8ac11a6c812c03dd0d4","modified":1678500908166},{"_id":"public/lib/vazir-font/Vazir-Black.eot","hash":"91152bd73e7ff8d943e3bde3ddb0fa0a018e1c21","modified":1678500908166},{"_id":"public/lib/vazir-font/Vazir-Black.ttf","hash":"b65915e3fa57b5c19995d15dc2341d115c1971b9","modified":1678500908166},{"_id":"public/lib/vazir-font/Vazir-Bold.eot","hash":"5c1c680fade45393e4a5bb4548a092cd5ea6811e","modified":1678500908166},{"_id":"public/lib/vazir-font/Vazir-Bold.ttf","hash":"122bb778b17a152c426a825ee981610a4bd59bf3","modified":1678500908166},{"_id":"public/lib/vazir-font/Vazir-Light.ttf","hash":"df82b80c4d3b11e70dcd269fc62ac97cbfa0414d","modified":1678500908166},{"_id":"public/lib/vazir-font/Vazir-Light.eot","hash":"a059359e9bea17dc2ff2ede955a05bf0dc4d00d0","modified":1678500908166},{"_id":"public/lib/vazir-font/Vazir-Medium.eot","hash":"d9ec1f9f3fefd57e446cbe86dc297f1ff269b6de","modified":1678500908166},{"_id":"public/lib/vazir-font/Vazir-Medium.ttf","hash":"948a091f0fdb8c7ae17d5ef8e51bd8830d65dd9a","modified":1678500908166},{"_id":"public/lib/vazir-font/Vazir-Regular.eot","hash":"521c01f0eb79a48025e972ecbe21b0d7fb15437b","modified":1678500908166},{"_id":"public/lib/vazir-font/Vazir-Regular.ttf","hash":"643c28c8f8a2bce1a0d62525aa045cd9883773cd","modified":1678500908166},{"_id":"public/lib/vazir-font/Vazir-Thin.eot","hash":"a0ea0bdaef00b35544f9a21d25d35db9a79f7189","modified":1678500908166},{"_id":"public/lib/vazir-font/Vazir-Thin.ttf","hash":"6aacb0eecb03c660570b6e159ba5ca97ca7461cf","modified":1678500908166},{"_id":"public/lib/vazir-font/Vazir-Variable.eot","hash":"af46f7f4e10a1440a4c97b350622d279143e6798","modified":1678500908166},{"_id":"public/lib/vazir-font/Vazir-Variable.ttf","hash":"1e08b6373c2e086f24776df9b11e4be6bbcc8a4a","modified":1678500908166},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"98564e5517b7b455e80b2cd503e7bb3b52beb930","modified":1678500908166},{"_id":"public/lib/vazir-font/font-face.css","hash":"ba0030e1cd28a8caa7a5bb74b98da7c7bb185c90","modified":1678500908166},{"_id":"public/lib/justified-gallery/css/justifiedGallery.min.css","hash":"dd3052149d3054f35efb823c68dd78e78aad5875","modified":1678500908166},{"_id":"public/lib/justified-gallery/js/jquery.justifiedGallery.min.js","hash":"ad8f48b4022498078b089fcdd1e8b47faf496931","modified":1678500908166},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"d3cafed4c6596253c1050ee63897aa0f440e4f65","modified":1678500908166},{"_id":"public/images/logo.png","hash":"0e3029251dfda26adee2761f71377297e8c26871","modified":1678500908166},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.ttf","hash":"cfb2c6122bd53141e939ee4ff991a16a29d1bdce","modified":1678500908166},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"09a731f80844483614ff12f86ccbe41db6736cb5","modified":1678500908166},{"_id":"public/lib/meslo-LG/MesloLGL-BoldItalic.ttf","hash":"b7d24ab1e4fad720f31a2b0cca1904ce1740d846","modified":1678500908166},{"_id":"public/lib/meslo-LG/MesloLGM-BoldItalic.ttf","hash":"b542b9591fbf33925d93f0695b6e123a9f0cfd43","modified":1678500908166},{"_id":"public/lib/meslo-LG/MesloLGS-BoldItalic.ttf","hash":"926035f0156cccf1b0ca507347f39bf9c510f51e","modified":1678500908166},{"_id":"public/lib/meslo-LG/MesloLGM-Italic.ttf","hash":"93ebc5098cf57a32b7b8d297681f31692c09bdfa","modified":1678500908166},{"_id":"public/lib/meslo-LG/MesloLGL-Italic.ttf","hash":"9a23c6898b0943bd3d96c04df9a0f66e919451d8","modified":1678500908166},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.ttf","hash":"97f5404656d9547666479ec64c336467000656ef","modified":1678500908166},{"_id":"public/lib/meslo-LG/MesloLGS-Italic.ttf","hash":"9d757cc9f928fc83b2133283dd639c12b11d94ad","modified":1678500908166},{"_id":"public/lib/meslo-LG/MesloLGL-Regular.ttf","hash":"6c090d6bff3928fbf8a5f4104e58ed7f421aea7c","modified":1678500908166},{"_id":"public/lib/meslo-LG/MesloLGL-Bold.ttf","hash":"34f7db59f1d023294e69976aa20b7d52b86165a4","modified":1678500908166},{"_id":"public/lib/meslo-LG/MesloLGM-Regular.ttf","hash":"20ce1fc7ae1254558ca044ae48283faaa58897e5","modified":1678500908166},{"_id":"public/lib/meslo-LG/MesloLGM-Bold.ttf","hash":"58be4b7760e9a84daa81929d046f9a15c4fd1c1a","modified":1678500908166},{"_id":"public/lib/meslo-LG/MesloLGS-Bold.ttf","hash":"f9918fb93d6ab6850f5d38069a999c311af78816","modified":1678500908166},{"_id":"public/lib/meslo-LG/MesloLGS-Regular.ttf","hash":"de559f8d70d5b1ab2810597bfd0b1b9506f3ef01","modified":1678500908166},{"_id":"public/images/joplin-excalidraw-example.gif","hash":"159b4b46bc554071bb4026cf169267051b2bab64","modified":1678500908166}],"Category":[],"Data":[],"Page":[{"title":"About","date":"2023-01-01T08:05:44.000Z","_content":"\n<% let Life = {\n    name: \"Skyfire\",\n    update_time: Date(),\n    plans: [\n        {\n            title: \"Book\",\n            progress: 0,\n            total: 30\n        },\n        {\n            title: \"Article\",\n            progress: 8,\n            total: 100\n        },\n        {\n            title: \"Travel\",\n            progress: 1,\n            total: 5\n        }\n    ],\n}; \n%>\n\n<h2>Introduction</h2>\n\n<p> <b>Name</b>: <%= Life.name %> </p>\n<p> <b>LastTime</b>: <%= Life.update_time %> </p>\n\n<h2>Plan</h2>\n\n<% Life.plans.forEach(function(plan){ %>\n    <p> <b><%= plan.title %></b>: <%= plan.progress %> / <%= plan.total %> </p>\n<% }); %>","source":"about/index.ejs","raw":"---\ntitle: About\ndate: 2023-01-01 16:05:44\n---\n\n<% let Life = {\n    name: \"Skyfire\",\n    update_time: Date(),\n    plans: [\n        {\n            title: \"Book\",\n            progress: 0,\n            total: 30\n        },\n        {\n            title: \"Article\",\n            progress: 8,\n            total: 100\n        },\n        {\n            title: \"Travel\",\n            progress: 1,\n            total: 5\n        }\n    ],\n}; \n%>\n\n<h2>Introduction</h2>\n\n<p> <b>Name</b>: <%= Life.name %> </p>\n<p> <b>LastTime</b>: <%= Life.update_time %> </p>\n\n<h2>Plan</h2>\n\n<% Life.plans.forEach(function(plan){ %>\n    <p> <b><%= plan.title %></b>: <%= plan.progress %> / <%= plan.total %> </p>\n<% }); %>","updated":"2023-01-10T15:09:17.580Z","path":"about/index.html","comments":1,"layout":"page","_id":"clf3c2gci00004cuq30uz8fe3","content":"\n\n\n<h2>Introduction</h2>\n\n<p> <b>Name</b>: Skyfire </p>\n<p> <b>LastTime</b>: Sat Mar 11 2023 10:14:09 GMT+0800 (China Standard Time) </p>\n\n<h2>Plan</h2>\n\n\n    <p> <b>Book</b>: 0 / 30 </p>\n\n    <p> <b>Article</b>: 8 / 100 </p>\n\n    <p> <b>Travel</b>: 1 / 5 </p>\n","site":{"data":{}},"excerpt":"","more":"\n\n\n<h2>Introduction</h2>\n\n<p> <b>Name</b>: Skyfire </p>\n<p> <b>LastTime</b>: Sat Mar 11 2023 10:14:09 GMT+0800 (China Standard Time) </p>\n\n<h2>Plan</h2>\n\n\n    <p> <b>Book</b>: 0 / 30 </p>\n\n    <p> <b>Article</b>: 8 / 100 </p>\n\n    <p> <b>Travel</b>: 1 / 5 </p>\n"},{"title":"roadmap","date":"2023-01-02T03:50:20.000Z","_content":"\n# Roadmap\n\n ## Article\n\n- Redis7 核心原理\n- RedisModule 核心原理\n- Linux 性能分析\n- Dragonfly 设计与实现\n\n## Book\n\n- [Vonng/ddia: 《Designing Data-Intensive Application》DDIA中文翻译](https://github.com/Vonng/ddia)","source":"roadmap/index.md","raw":"---\ntitle: roadmap\ndate: 2023-01-02 11:50:20\n---\n\n# Roadmap\n\n ## Article\n\n- Redis7 核心原理\n- RedisModule 核心原理\n- Linux 性能分析\n- Dragonfly 设计与实现\n\n## Book\n\n- [Vonng/ddia: 《Designing Data-Intensive Application》DDIA中文翻译](https://github.com/Vonng/ddia)","updated":"2023-01-02T10:19:07.188Z","path":"roadmap/index.html","comments":1,"layout":"page","_id":"clf3c2gcq00024cuq8uha3bjz","content":"<h1 id=\"Roadmap\"><a href=\"#Roadmap\" class=\"headerlink\" title=\"Roadmap\"></a>Roadmap</h1><h2 id=\"Article\"><a href=\"#Article\" class=\"headerlink\" title=\"Article\"></a>Article</h2><ul>\n<li>Redis7 核心原理</li>\n<li>RedisModule 核心原理</li>\n<li>Linux 性能分析</li>\n<li>Dragonfly 设计与实现</li>\n</ul>\n<h2 id=\"Book\"><a href=\"#Book\" class=\"headerlink\" title=\"Book\"></a>Book</h2><ul>\n<li><a href=\"https://github.com/Vonng/ddia\">Vonng/ddia: 《Designing Data-Intensive Application》DDIA中文翻译</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Roadmap\"><a href=\"#Roadmap\" class=\"headerlink\" title=\"Roadmap\"></a>Roadmap</h1><h2 id=\"Article\"><a href=\"#Article\" class=\"headerlink\" title=\"Article\"></a>Article</h2><ul>\n<li>Redis7 核心原理</li>\n<li>RedisModule 核心原理</li>\n<li>Linux 性能分析</li>\n<li>Dragonfly 设计与实现</li>\n</ul>\n<h2 id=\"Book\"><a href=\"#Book\" class=\"headerlink\" title=\"Book\"></a>Book</h2><ul>\n<li><a href=\"https://github.com/Vonng/ddia\">Vonng/ddia: 《Designing Data-Intensive Application》DDIA中文翻译</a></li>\n</ul>\n"},{"title":"link","date":"2023-01-02T03:38:38.000Z","_content":"\n## Interesting Blog\n\n- [timqian/chinese-independent-blogs: 中文独立博客列表](https://github.com/timqian/chinese-independent-blogs)\n- [Go 语言设计与实现 | Go 语言设计与实现](https://draveness.me/golang/)\n\n## English Learning\n\n- [eleduck/English4Developers](https://github.com/eleduck/English4Developers)\n\n## Distributed storage\n\n- [dragonflydb/dragonfly: A modern replacement for Redis and Memcached](https://github.com/dragonflydb/dragonfly)","source":"link/index.md","raw":"---\ntitle: link\ndate: 2023-01-02 11:38:38\n---\n\n## Interesting Blog\n\n- [timqian/chinese-independent-blogs: 中文独立博客列表](https://github.com/timqian/chinese-independent-blogs)\n- [Go 语言设计与实现 | Go 语言设计与实现](https://draveness.me/golang/)\n\n## English Learning\n\n- [eleduck/English4Developers](https://github.com/eleduck/English4Developers)\n\n## Distributed storage\n\n- [dragonflydb/dragonfly: A modern replacement for Redis and Memcached](https://github.com/dragonflydb/dragonfly)","updated":"2023-01-02T10:51:06.402Z","path":"link/index.html","comments":1,"layout":"page","_id":"clf3c2gct00044cuqeya31bx6","content":"<h2 id=\"Interesting-Blog\"><a href=\"#Interesting-Blog\" class=\"headerlink\" title=\"Interesting Blog\"></a>Interesting Blog</h2><ul>\n<li><a href=\"https://github.com/timqian/chinese-independent-blogs\">timqian/chinese-independent-blogs: 中文独立博客列表</a></li>\n<li><a href=\"https://draveness.me/golang/\">Go 语言设计与实现 | Go 语言设计与实现</a></li>\n</ul>\n<h2 id=\"English-Learning\"><a href=\"#English-Learning\" class=\"headerlink\" title=\"English Learning\"></a>English Learning</h2><ul>\n<li><a href=\"https://github.com/eleduck/English4Developers\">eleduck/English4Developers</a></li>\n</ul>\n<h2 id=\"Distributed-storage\"><a href=\"#Distributed-storage\" class=\"headerlink\" title=\"Distributed storage\"></a>Distributed storage</h2><ul>\n<li><a href=\"https://github.com/dragonflydb/dragonfly\">dragonflydb/dragonfly: A modern replacement for Redis and Memcached</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Interesting-Blog\"><a href=\"#Interesting-Blog\" class=\"headerlink\" title=\"Interesting Blog\"></a>Interesting Blog</h2><ul>\n<li><a href=\"https://github.com/timqian/chinese-independent-blogs\">timqian/chinese-independent-blogs: 中文独立博客列表</a></li>\n<li><a href=\"https://draveness.me/golang/\">Go 语言设计与实现 | Go 语言设计与实现</a></li>\n</ul>\n<h2 id=\"English-Learning\"><a href=\"#English-Learning\" class=\"headerlink\" title=\"English Learning\"></a>English Learning</h2><ul>\n<li><a href=\"https://github.com/eleduck/English4Developers\">eleduck/English4Developers</a></li>\n</ul>\n<h2 id=\"Distributed-storage\"><a href=\"#Distributed-storage\" class=\"headerlink\" title=\"Distributed storage\"></a>Distributed storage</h2><ul>\n<li><a href=\"https://github.com/dragonflydb/dragonfly\">dragonflydb/dragonfly: A modern replacement for Redis and Memcached</a></li>\n</ul>\n"}],"Post":[{"title":"1月2日~1月8日-Redis周报","abbrlink":65487,"date":"2023-01-09T16:30:28.000Z","_content":"\n## CommitLog 分析\n\n- [Fix issues with listpack encoded set (#11685)](https://github.com/redis/redis/commit/d0cc3de73f91ca79b2343e73e640b40709cfcaf5)\n\n> 修复了OBJ_ENCODING_LISTPACK的内存统计方法\n> 优化了ZRANDMEMBER可能出现的OOM操作，增加了每次申请空间的限制。\n\n- [In cluster-mode enabled, override the databases config at startup to 1 (](https://github.com/redis/redis/commit/cb1fff3cb6a944d1f9cc67f8aa8b1d92648bbade)\n\n> 在config中，对cluster-mode下的dbnum做处理，替换原有的exit操作\n\n- [Include peer-addr:port and local-addr:port when logging accept errors (…](https://github.com/redis/redis/commit/a2e75a78b424a6faca4bba4b1bf8270b98407284)\n\n> 日志中增加本地和对端的addr信息\n\n- [Make redis-cli support PSYNC command (#11647)](https://github.com/redis/redis/commit/4ef4c4a686b6edaf825635d942b698349f67bcc6)\n\n> 在redis-cli中支持PSYNC命令。【TODO】\n\n- [Fix potential issue with Lua argv caching, module command filter and …](https://github.com/redis/redis/commit/c8052122a2af9b85124a8697488a0c44d66777b8)\n\n> 在lua中，经过module的RM_CommandFilterArgInsert操作，可能导致原有的argv对象大小发生变化，但由于使用的zrealloc，地址并未变化，最终导致内存损坏，故增加了对argv_len的判断。\n\n- [fix handshake timeout replication test race (#11640)](https://github.com/redis/redis/commit/0ecf6cdc0a81f79e6875191ef9aa4f16c9110223)\n\n> 优化了主从同步时的超时时间设置，避免ci错误\n\n- [Introduce .is\\_local method for connection layer](https://github.com/redis/redis/commit/dec529f4be3e3314300bb513e7a9f3af636e13b0)\n\n> 抽象了对本地client的判断逻辑，从原有的islocalClient抽象出了对各类连接的方法connIsLocal\n\n- [Optimize the performance of msetnx command by call lookupkey only once (](https://github.com/redis/redis/commit/884ca601b21ec6ef4d216ae850c0cf503f762623)\n\n> 优化mset的多次lookup操作\n\n- [Add cluster info and cluster nodes to bug report (#11656)](https://github.com/redis/redis/commit/d2d6bc18ebc63265c2ee55ed79ab6ad2044b3bc3)\n\n> 增加了cluster info命令以及在core后打印cluster的信息\n\n- [reprocess command when client is unblocked on keys (#11012) · redis/redis@383d902](https://github.com/redis/redis/commit/383d902ce68131cf40d6122ce09e305e672e8555)\n\n> 对blocked client做了很大量的重构，【TODO】","source":"_posts/1月2日~1月8日-Redis周报.md","raw":"---\ntitle: 1月2日~1月8日-Redis周报\nabbrlink: 65487\ndate: 2023-01-10 00:30:28\ntags:\n---\n\n## CommitLog 分析\n\n- [Fix issues with listpack encoded set (#11685)](https://github.com/redis/redis/commit/d0cc3de73f91ca79b2343e73e640b40709cfcaf5)\n\n> 修复了OBJ_ENCODING_LISTPACK的内存统计方法\n> 优化了ZRANDMEMBER可能出现的OOM操作，增加了每次申请空间的限制。\n\n- [In cluster-mode enabled, override the databases config at startup to 1 (](https://github.com/redis/redis/commit/cb1fff3cb6a944d1f9cc67f8aa8b1d92648bbade)\n\n> 在config中，对cluster-mode下的dbnum做处理，替换原有的exit操作\n\n- [Include peer-addr:port and local-addr:port when logging accept errors (…](https://github.com/redis/redis/commit/a2e75a78b424a6faca4bba4b1bf8270b98407284)\n\n> 日志中增加本地和对端的addr信息\n\n- [Make redis-cli support PSYNC command (#11647)](https://github.com/redis/redis/commit/4ef4c4a686b6edaf825635d942b698349f67bcc6)\n\n> 在redis-cli中支持PSYNC命令。【TODO】\n\n- [Fix potential issue with Lua argv caching, module command filter and …](https://github.com/redis/redis/commit/c8052122a2af9b85124a8697488a0c44d66777b8)\n\n> 在lua中，经过module的RM_CommandFilterArgInsert操作，可能导致原有的argv对象大小发生变化，但由于使用的zrealloc，地址并未变化，最终导致内存损坏，故增加了对argv_len的判断。\n\n- [fix handshake timeout replication test race (#11640)](https://github.com/redis/redis/commit/0ecf6cdc0a81f79e6875191ef9aa4f16c9110223)\n\n> 优化了主从同步时的超时时间设置，避免ci错误\n\n- [Introduce .is\\_local method for connection layer](https://github.com/redis/redis/commit/dec529f4be3e3314300bb513e7a9f3af636e13b0)\n\n> 抽象了对本地client的判断逻辑，从原有的islocalClient抽象出了对各类连接的方法connIsLocal\n\n- [Optimize the performance of msetnx command by call lookupkey only once (](https://github.com/redis/redis/commit/884ca601b21ec6ef4d216ae850c0cf503f762623)\n\n> 优化mset的多次lookup操作\n\n- [Add cluster info and cluster nodes to bug report (#11656)](https://github.com/redis/redis/commit/d2d6bc18ebc63265c2ee55ed79ab6ad2044b3bc3)\n\n> 增加了cluster info命令以及在core后打印cluster的信息\n\n- [reprocess command when client is unblocked on keys (#11012) · redis/redis@383d902](https://github.com/redis/redis/commit/383d902ce68131cf40d6122ce09e305e672e8555)\n\n> 对blocked client做了很大量的重构，【TODO】","slug":"1月2日~1月8日-Redis周报","published":1,"updated":"2023-01-09T16:31:37.615Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clf3c2gcm00014cuq56kf4tys","content":"<h2 id=\"CommitLog-分析\"><a href=\"#CommitLog-分析\" class=\"headerlink\" title=\"CommitLog 分析\"></a>CommitLog 分析</h2><ul>\n<li><a href=\"https://github.com/redis/redis/commit/d0cc3de73f91ca79b2343e73e640b40709cfcaf5\">Fix issues with listpack encoded set (#11685)</a></li>\n</ul>\n<blockquote>\n<p>修复了OBJ_ENCODING_LISTPACK的内存统计方法<br>优化了ZRANDMEMBER可能出现的OOM操作，增加了每次申请空间的限制。</p>\n</blockquote>\n<ul>\n<li><a href=\"https://github.com/redis/redis/commit/cb1fff3cb6a944d1f9cc67f8aa8b1d92648bbade\">In cluster-mode enabled, override the databases config at startup to 1 (</a></li>\n</ul>\n<blockquote>\n<p>在config中，对cluster-mode下的dbnum做处理，替换原有的exit操作</p>\n</blockquote>\n<ul>\n<li><a href=\"https://github.com/redis/redis/commit/a2e75a78b424a6faca4bba4b1bf8270b98407284\">Include peer-addr:port and local-addr:port when logging accept errors (…</a></li>\n</ul>\n<blockquote>\n<p>日志中增加本地和对端的addr信息</p>\n</blockquote>\n<ul>\n<li><a href=\"https://github.com/redis/redis/commit/4ef4c4a686b6edaf825635d942b698349f67bcc6\">Make redis-cli support PSYNC command (#11647)</a></li>\n</ul>\n<blockquote>\n<p>在redis-cli中支持PSYNC命令。【TODO】</p>\n</blockquote>\n<ul>\n<li><a href=\"https://github.com/redis/redis/commit/c8052122a2af9b85124a8697488a0c44d66777b8\">Fix potential issue with Lua argv caching, module command filter and …</a></li>\n</ul>\n<blockquote>\n<p>在lua中，经过module的RM_CommandFilterArgInsert操作，可能导致原有的argv对象大小发生变化，但由于使用的zrealloc，地址并未变化，最终导致内存损坏，故增加了对argv_len的判断。</p>\n</blockquote>\n<ul>\n<li><a href=\"https://github.com/redis/redis/commit/0ecf6cdc0a81f79e6875191ef9aa4f16c9110223\">fix handshake timeout replication test race (#11640)</a></li>\n</ul>\n<blockquote>\n<p>优化了主从同步时的超时时间设置，避免ci错误</p>\n</blockquote>\n<ul>\n<li><a href=\"https://github.com/redis/redis/commit/dec529f4be3e3314300bb513e7a9f3af636e13b0\">Introduce .is_local method for connection layer</a></li>\n</ul>\n<blockquote>\n<p>抽象了对本地client的判断逻辑，从原有的islocalClient抽象出了对各类连接的方法connIsLocal</p>\n</blockquote>\n<ul>\n<li><a href=\"https://github.com/redis/redis/commit/884ca601b21ec6ef4d216ae850c0cf503f762623\">Optimize the performance of msetnx command by call lookupkey only once (</a></li>\n</ul>\n<blockquote>\n<p>优化mset的多次lookup操作</p>\n</blockquote>\n<ul>\n<li><a href=\"https://github.com/redis/redis/commit/d2d6bc18ebc63265c2ee55ed79ab6ad2044b3bc3\">Add cluster info and cluster nodes to bug report (#11656)</a></li>\n</ul>\n<blockquote>\n<p>增加了cluster info命令以及在core后打印cluster的信息</p>\n</blockquote>\n<ul>\n<li><a href=\"https://github.com/redis/redis/commit/383d902ce68131cf40d6122ce09e305e672e8555\">reprocess command when client is unblocked on keys (#11012) · redis/redis@383d902</a></li>\n</ul>\n<blockquote>\n<p>对blocked client做了很大量的重构，【TODO】</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"CommitLog-分析\"><a href=\"#CommitLog-分析\" class=\"headerlink\" title=\"CommitLog 分析\"></a>CommitLog 分析</h2><ul>\n<li><a href=\"https://github.com/redis/redis/commit/d0cc3de73f91ca79b2343e73e640b40709cfcaf5\">Fix issues with listpack encoded set (#11685)</a></li>\n</ul>\n<blockquote>\n<p>修复了OBJ_ENCODING_LISTPACK的内存统计方法<br>优化了ZRANDMEMBER可能出现的OOM操作，增加了每次申请空间的限制。</p>\n</blockquote>\n<ul>\n<li><a href=\"https://github.com/redis/redis/commit/cb1fff3cb6a944d1f9cc67f8aa8b1d92648bbade\">In cluster-mode enabled, override the databases config at startup to 1 (</a></li>\n</ul>\n<blockquote>\n<p>在config中，对cluster-mode下的dbnum做处理，替换原有的exit操作</p>\n</blockquote>\n<ul>\n<li><a href=\"https://github.com/redis/redis/commit/a2e75a78b424a6faca4bba4b1bf8270b98407284\">Include peer-addr:port and local-addr:port when logging accept errors (…</a></li>\n</ul>\n<blockquote>\n<p>日志中增加本地和对端的addr信息</p>\n</blockquote>\n<ul>\n<li><a href=\"https://github.com/redis/redis/commit/4ef4c4a686b6edaf825635d942b698349f67bcc6\">Make redis-cli support PSYNC command (#11647)</a></li>\n</ul>\n<blockquote>\n<p>在redis-cli中支持PSYNC命令。【TODO】</p>\n</blockquote>\n<ul>\n<li><a href=\"https://github.com/redis/redis/commit/c8052122a2af9b85124a8697488a0c44d66777b8\">Fix potential issue with Lua argv caching, module command filter and …</a></li>\n</ul>\n<blockquote>\n<p>在lua中，经过module的RM_CommandFilterArgInsert操作，可能导致原有的argv对象大小发生变化，但由于使用的zrealloc，地址并未变化，最终导致内存损坏，故增加了对argv_len的判断。</p>\n</blockquote>\n<ul>\n<li><a href=\"https://github.com/redis/redis/commit/0ecf6cdc0a81f79e6875191ef9aa4f16c9110223\">fix handshake timeout replication test race (#11640)</a></li>\n</ul>\n<blockquote>\n<p>优化了主从同步时的超时时间设置，避免ci错误</p>\n</blockquote>\n<ul>\n<li><a href=\"https://github.com/redis/redis/commit/dec529f4be3e3314300bb513e7a9f3af636e13b0\">Introduce .is_local method for connection layer</a></li>\n</ul>\n<blockquote>\n<p>抽象了对本地client的判断逻辑，从原有的islocalClient抽象出了对各类连接的方法connIsLocal</p>\n</blockquote>\n<ul>\n<li><a href=\"https://github.com/redis/redis/commit/884ca601b21ec6ef4d216ae850c0cf503f762623\">Optimize the performance of msetnx command by call lookupkey only once (</a></li>\n</ul>\n<blockquote>\n<p>优化mset的多次lookup操作</p>\n</blockquote>\n<ul>\n<li><a href=\"https://github.com/redis/redis/commit/d2d6bc18ebc63265c2ee55ed79ab6ad2044b3bc3\">Add cluster info and cluster nodes to bug report (#11656)</a></li>\n</ul>\n<blockquote>\n<p>增加了cluster info命令以及在core后打印cluster的信息</p>\n</blockquote>\n<ul>\n<li><a href=\"https://github.com/redis/redis/commit/383d902ce68131cf40d6122ce09e305e672e8555\">reprocess command when client is unblocked on keys (#11012) · redis/redis@383d902</a></li>\n</ul>\n<blockquote>\n<p>对blocked client做了很大量的重构，【TODO】</p>\n</blockquote>\n"},{"title":"Redis中的Timeout处理","abbrlink":11484,"date":"2023-01-10T15:07:22.000Z","_content":"\n今天简单的学习一下timeout的底层逻辑，本模块的逻辑是blocked以及client的底层支持。当然，这个抽象也是在Redis 6中进行了代码抽象。\n\n在整个文件中包含三块逻辑：\n1. 解析命令中的timeout的逻辑抽象\n2. 处理阻塞client的超时逻辑\n3. 阻塞client的操作管理\n\n## client的超时管理\n\n超时管理主要是基于rax树来管理，以timeout为key，client为value。同时支持了增删改查的逻辑操作：\n\n- addClientToTimeoutTable\n- removeClientFromTimeoutTable\n- checkBlockedClientTimeout\n\n而每个client都会记录自身的timeout，并对timeout进行编码。同时，client 会增加 CLIENT_IN_TO_TABLE 标记，表示自身已经写入 timeout 的 rax 树中。\n\n## client超时处理\n\n当 client 已经超时，则需要有地方去触发超时逻辑。其中包括三处逻辑：\n- beforeSleep -> handleBlockedClientsTimeout\n- unblockClient -> removeClientFromTimeoutTable\n- clientsCron -> clientsCronHandleTimeout\n\n前俩者主要是针对阻塞 client 的处理，其中会在解除阻塞、超时逻辑中删除在rax中的client信息并同时 unblock 当前的 client。而后者主要是检查 client 是否空闲过久，若是则直接关闭 client。\n\n## 解析timeout逻辑\n\n这个逻辑相对简单，就是针对不同单位的值读取 robj 信息，并对 timeout 的范围进行检查。\n\n\n> 特殊逻辑：mustObeyClient 有趣的判断，不对aof和master的client进行处理。","source":"_posts/Redis中的Timeout处理.md","raw":"---\ntitle: Redis中的Timeout处理\nabbrlink: 11484\ndate: 2023-01-10 23:07:22\ntags:\n---\n\n今天简单的学习一下timeout的底层逻辑，本模块的逻辑是blocked以及client的底层支持。当然，这个抽象也是在Redis 6中进行了代码抽象。\n\n在整个文件中包含三块逻辑：\n1. 解析命令中的timeout的逻辑抽象\n2. 处理阻塞client的超时逻辑\n3. 阻塞client的操作管理\n\n## client的超时管理\n\n超时管理主要是基于rax树来管理，以timeout为key，client为value。同时支持了增删改查的逻辑操作：\n\n- addClientToTimeoutTable\n- removeClientFromTimeoutTable\n- checkBlockedClientTimeout\n\n而每个client都会记录自身的timeout，并对timeout进行编码。同时，client 会增加 CLIENT_IN_TO_TABLE 标记，表示自身已经写入 timeout 的 rax 树中。\n\n## client超时处理\n\n当 client 已经超时，则需要有地方去触发超时逻辑。其中包括三处逻辑：\n- beforeSleep -> handleBlockedClientsTimeout\n- unblockClient -> removeClientFromTimeoutTable\n- clientsCron -> clientsCronHandleTimeout\n\n前俩者主要是针对阻塞 client 的处理，其中会在解除阻塞、超时逻辑中删除在rax中的client信息并同时 unblock 当前的 client。而后者主要是检查 client 是否空闲过久，若是则直接关闭 client。\n\n## 解析timeout逻辑\n\n这个逻辑相对简单，就是针对不同单位的值读取 robj 信息，并对 timeout 的范围进行检查。\n\n\n> 特殊逻辑：mustObeyClient 有趣的判断，不对aof和master的client进行处理。","slug":"Redis中的Timeout处理","published":1,"updated":"2023-01-10T15:07:44.962Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clf3c2gcq00034cuqarnf2xeg","content":"<p>今天简单的学习一下timeout的底层逻辑，本模块的逻辑是blocked以及client的底层支持。当然，这个抽象也是在Redis 6中进行了代码抽象。</p>\n<p>在整个文件中包含三块逻辑：</p>\n<ol>\n<li>解析命令中的timeout的逻辑抽象</li>\n<li>处理阻塞client的超时逻辑</li>\n<li>阻塞client的操作管理</li>\n</ol>\n<h2 id=\"client的超时管理\"><a href=\"#client的超时管理\" class=\"headerlink\" title=\"client的超时管理\"></a>client的超时管理</h2><p>超时管理主要是基于rax树来管理，以timeout为key，client为value。同时支持了增删改查的逻辑操作：</p>\n<ul>\n<li>addClientToTimeoutTable</li>\n<li>removeClientFromTimeoutTable</li>\n<li>checkBlockedClientTimeout</li>\n</ul>\n<p>而每个client都会记录自身的timeout，并对timeout进行编码。同时，client 会增加 CLIENT_IN_TO_TABLE 标记，表示自身已经写入 timeout 的 rax 树中。</p>\n<h2 id=\"client超时处理\"><a href=\"#client超时处理\" class=\"headerlink\" title=\"client超时处理\"></a>client超时处理</h2><p>当 client 已经超时，则需要有地方去触发超时逻辑。其中包括三处逻辑：</p>\n<ul>\n<li>beforeSleep -&gt; handleBlockedClientsTimeout</li>\n<li>unblockClient -&gt; removeClientFromTimeoutTable</li>\n<li>clientsCron -&gt; clientsCronHandleTimeout</li>\n</ul>\n<p>前俩者主要是针对阻塞 client 的处理，其中会在解除阻塞、超时逻辑中删除在rax中的client信息并同时 unblock 当前的 client。而后者主要是检查 client 是否空闲过久，若是则直接关闭 client。</p>\n<h2 id=\"解析timeout逻辑\"><a href=\"#解析timeout逻辑\" class=\"headerlink\" title=\"解析timeout逻辑\"></a>解析timeout逻辑</h2><p>这个逻辑相对简单，就是针对不同单位的值读取 robj 信息，并对 timeout 的范围进行检查。</p>\n<blockquote>\n<p>特殊逻辑：mustObeyClient 有趣的判断，不对aof和master的client进行处理。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>今天简单的学习一下timeout的底层逻辑，本模块的逻辑是blocked以及client的底层支持。当然，这个抽象也是在Redis 6中进行了代码抽象。</p>\n<p>在整个文件中包含三块逻辑：</p>\n<ol>\n<li>解析命令中的timeout的逻辑抽象</li>\n<li>处理阻塞client的超时逻辑</li>\n<li>阻塞client的操作管理</li>\n</ol>\n<h2 id=\"client的超时管理\"><a href=\"#client的超时管理\" class=\"headerlink\" title=\"client的超时管理\"></a>client的超时管理</h2><p>超时管理主要是基于rax树来管理，以timeout为key，client为value。同时支持了增删改查的逻辑操作：</p>\n<ul>\n<li>addClientToTimeoutTable</li>\n<li>removeClientFromTimeoutTable</li>\n<li>checkBlockedClientTimeout</li>\n</ul>\n<p>而每个client都会记录自身的timeout，并对timeout进行编码。同时，client 会增加 CLIENT_IN_TO_TABLE 标记，表示自身已经写入 timeout 的 rax 树中。</p>\n<h2 id=\"client超时处理\"><a href=\"#client超时处理\" class=\"headerlink\" title=\"client超时处理\"></a>client超时处理</h2><p>当 client 已经超时，则需要有地方去触发超时逻辑。其中包括三处逻辑：</p>\n<ul>\n<li>beforeSleep -&gt; handleBlockedClientsTimeout</li>\n<li>unblockClient -&gt; removeClientFromTimeoutTable</li>\n<li>clientsCron -&gt; clientsCronHandleTimeout</li>\n</ul>\n<p>前俩者主要是针对阻塞 client 的处理，其中会在解除阻塞、超时逻辑中删除在rax中的client信息并同时 unblock 当前的 client。而后者主要是检查 client 是否空闲过久，若是则直接关闭 client。</p>\n<h2 id=\"解析timeout逻辑\"><a href=\"#解析timeout逻辑\" class=\"headerlink\" title=\"解析timeout逻辑\"></a>解析timeout逻辑</h2><p>这个逻辑相对简单，就是针对不同单位的值读取 robj 信息，并对 timeout 的范围进行检查。</p>\n<blockquote>\n<p>特殊逻辑：mustObeyClient 有趣的判断，不对aof和master的client进行处理。</p>\n</blockquote>\n"},{"title":"Redis中的Failover机制","abbrlink":59749,"date":"2023-01-02T14:37:08.000Z","_content":"\n在Redis7中，实现了主动的Failover机制，以支持用户能主动的进行主从切换。PR参考：[implement FAILOVER command by allenfarris · Pull Request #8315 · redis/redis](https://github.com/redis/redis/pull/8315)\n\n### Failover命令\n\n```\nFAILOVER [ABORT] [TO <HOST> <IP>] [FORCE] [TIMEOUT <timeout>] \n```\n\n命令包括几种操作：\n- ABORT：直接中断failover操作\n- TO：明确failover的实例\n- FORCE：强制failover操作\n- TIMEOUT：制定failover的超时时间，避免长时间的等待。\n\n从最简单的failover操作来看，当前的操作必须在Master实例上运行，同时可以指定或者随机一个replica进行failover操作。\n\n在设置完failover后，整个Master实例会进入一个 FAILOVER_WAIT_FOR_SYNC 的状态，同时暂停整个实例的变更，操作等同于`CLIENT PAUSE`\n\n而在整个failover中，存在3类状态：\n- NO_FAILOVER：无状态\n- FAILOVER_WAIT_FOR_SYNC：等待同步\n- FAILOVER_IN_PROGRESS：进行中\n\n进入 FAILOVER_WAIT_FOR_SYNC 状态后，实例会定期检查当前的failover情况。若超时，则确定是否存在force标识，存在则强制进行切主操作。否则则中断 failover 进度。\n\n正常流程，则会选择一个 replica 作为目标实例进行 failover。 目标实例的标准若非自行选择，则要求 offset 必须拉齐，保证数据完整性。\n\n等待 replica 数据同步完成后，便进入 FAILOVER_IN_PROGRESS 进行实例切换。\n\n### 实例切换\n\n在 FAILOVER_IN_PROGRESS 过程中，需要关注什么下会转换为 NO_FAILOVER 状态。在建立关系后，旧 Master 收到新 Master 的 `+CONTINUE` 或 `+FULLRESYNC` 信息，则认为关系已经建立，可以清理掉 failover 状态。\n\n而在建立连接时，旧 Master 会发送 `PSYNC <replid> <reploff> FAILOVER` 命令给新 Master。此操作主要是告知新 Master 需要从原有的 Replica 状态转换为 Master。\n\n### 数据保证\n\n在整个 Failover 过程中，旧 Master 会进行停写，同时，不再对所有 Replica 进行数据传输（包括PING操作），以此，实际的数据不会变化，这样对整个复制链的数据迁移是友好的。故，理论上在 主从切换时，大概率是增量同步，且数据不会丢失。","source":"_posts/Redis中的Failover机制.md","raw":"---\ntitle: Redis中的Failover机制\nabbrlink: 59749\ndate: 2023-01-02 22:37:08\ntags:\n---\n\n在Redis7中，实现了主动的Failover机制，以支持用户能主动的进行主从切换。PR参考：[implement FAILOVER command by allenfarris · Pull Request #8315 · redis/redis](https://github.com/redis/redis/pull/8315)\n\n### Failover命令\n\n```\nFAILOVER [ABORT] [TO <HOST> <IP>] [FORCE] [TIMEOUT <timeout>] \n```\n\n命令包括几种操作：\n- ABORT：直接中断failover操作\n- TO：明确failover的实例\n- FORCE：强制failover操作\n- TIMEOUT：制定failover的超时时间，避免长时间的等待。\n\n从最简单的failover操作来看，当前的操作必须在Master实例上运行，同时可以指定或者随机一个replica进行failover操作。\n\n在设置完failover后，整个Master实例会进入一个 FAILOVER_WAIT_FOR_SYNC 的状态，同时暂停整个实例的变更，操作等同于`CLIENT PAUSE`\n\n而在整个failover中，存在3类状态：\n- NO_FAILOVER：无状态\n- FAILOVER_WAIT_FOR_SYNC：等待同步\n- FAILOVER_IN_PROGRESS：进行中\n\n进入 FAILOVER_WAIT_FOR_SYNC 状态后，实例会定期检查当前的failover情况。若超时，则确定是否存在force标识，存在则强制进行切主操作。否则则中断 failover 进度。\n\n正常流程，则会选择一个 replica 作为目标实例进行 failover。 目标实例的标准若非自行选择，则要求 offset 必须拉齐，保证数据完整性。\n\n等待 replica 数据同步完成后，便进入 FAILOVER_IN_PROGRESS 进行实例切换。\n\n### 实例切换\n\n在 FAILOVER_IN_PROGRESS 过程中，需要关注什么下会转换为 NO_FAILOVER 状态。在建立关系后，旧 Master 收到新 Master 的 `+CONTINUE` 或 `+FULLRESYNC` 信息，则认为关系已经建立，可以清理掉 failover 状态。\n\n而在建立连接时，旧 Master 会发送 `PSYNC <replid> <reploff> FAILOVER` 命令给新 Master。此操作主要是告知新 Master 需要从原有的 Replica 状态转换为 Master。\n\n### 数据保证\n\n在整个 Failover 过程中，旧 Master 会进行停写，同时，不再对所有 Replica 进行数据传输（包括PING操作），以此，实际的数据不会变化，这样对整个复制链的数据迁移是友好的。故，理论上在 主从切换时，大概率是增量同步，且数据不会丢失。","slug":"Redis中的Failover机制","published":1,"updated":"2023-01-02T14:37:30.208Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clf3c2gct00054cuq90qb91wb","content":"<p>在Redis7中，实现了主动的Failover机制，以支持用户能主动的进行主从切换。PR参考：<a href=\"https://github.com/redis/redis/pull/8315\">implement FAILOVER command by allenfarris · Pull Request #8315 · redis/redis</a></p>\n<h3 id=\"Failover命令\"><a href=\"#Failover命令\" class=\"headerlink\" title=\"Failover命令\"></a>Failover命令</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FAILOVER [ABORT] [TO &lt;HOST&gt; &lt;IP&gt;] [FORCE] [TIMEOUT &lt;timeout&gt;] </span><br></pre></td></tr></table></figure>\n\n<p>命令包括几种操作：</p>\n<ul>\n<li>ABORT：直接中断failover操作</li>\n<li>TO：明确failover的实例</li>\n<li>FORCE：强制failover操作</li>\n<li>TIMEOUT：制定failover的超时时间，避免长时间的等待。</li>\n</ul>\n<p>从最简单的failover操作来看，当前的操作必须在Master实例上运行，同时可以指定或者随机一个replica进行failover操作。</p>\n<p>在设置完failover后，整个Master实例会进入一个 FAILOVER_WAIT_FOR_SYNC 的状态，同时暂停整个实例的变更，操作等同于<code>CLIENT PAUSE</code></p>\n<p>而在整个failover中，存在3类状态：</p>\n<ul>\n<li>NO_FAILOVER：无状态</li>\n<li>FAILOVER_WAIT_FOR_SYNC：等待同步</li>\n<li>FAILOVER_IN_PROGRESS：进行中</li>\n</ul>\n<p>进入 FAILOVER_WAIT_FOR_SYNC 状态后，实例会定期检查当前的failover情况。若超时，则确定是否存在force标识，存在则强制进行切主操作。否则则中断 failover 进度。</p>\n<p>正常流程，则会选择一个 replica 作为目标实例进行 failover。 目标实例的标准若非自行选择，则要求 offset 必须拉齐，保证数据完整性。</p>\n<p>等待 replica 数据同步完成后，便进入 FAILOVER_IN_PROGRESS 进行实例切换。</p>\n<h3 id=\"实例切换\"><a href=\"#实例切换\" class=\"headerlink\" title=\"实例切换\"></a>实例切换</h3><p>在 FAILOVER_IN_PROGRESS 过程中，需要关注什么下会转换为 NO_FAILOVER 状态。在建立关系后，旧 Master 收到新 Master 的 <code>+CONTINUE</code> 或 <code>+FULLRESYNC</code> 信息，则认为关系已经建立，可以清理掉 failover 状态。</p>\n<p>而在建立连接时，旧 Master 会发送 <code>PSYNC &lt;replid&gt; &lt;reploff&gt; FAILOVER</code> 命令给新 Master。此操作主要是告知新 Master 需要从原有的 Replica 状态转换为 Master。</p>\n<h3 id=\"数据保证\"><a href=\"#数据保证\" class=\"headerlink\" title=\"数据保证\"></a>数据保证</h3><p>在整个 Failover 过程中，旧 Master 会进行停写，同时，不再对所有 Replica 进行数据传输（包括PING操作），以此，实际的数据不会变化，这样对整个复制链的数据迁移是友好的。故，理论上在 主从切换时，大概率是增量同步，且数据不会丢失。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在Redis7中，实现了主动的Failover机制，以支持用户能主动的进行主从切换。PR参考：<a href=\"https://github.com/redis/redis/pull/8315\">implement FAILOVER command by allenfarris · Pull Request #8315 · redis/redis</a></p>\n<h3 id=\"Failover命令\"><a href=\"#Failover命令\" class=\"headerlink\" title=\"Failover命令\"></a>Failover命令</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FAILOVER [ABORT] [TO &lt;HOST&gt; &lt;IP&gt;] [FORCE] [TIMEOUT &lt;timeout&gt;] </span><br></pre></td></tr></table></figure>\n\n<p>命令包括几种操作：</p>\n<ul>\n<li>ABORT：直接中断failover操作</li>\n<li>TO：明确failover的实例</li>\n<li>FORCE：强制failover操作</li>\n<li>TIMEOUT：制定failover的超时时间，避免长时间的等待。</li>\n</ul>\n<p>从最简单的failover操作来看，当前的操作必须在Master实例上运行，同时可以指定或者随机一个replica进行failover操作。</p>\n<p>在设置完failover后，整个Master实例会进入一个 FAILOVER_WAIT_FOR_SYNC 的状态，同时暂停整个实例的变更，操作等同于<code>CLIENT PAUSE</code></p>\n<p>而在整个failover中，存在3类状态：</p>\n<ul>\n<li>NO_FAILOVER：无状态</li>\n<li>FAILOVER_WAIT_FOR_SYNC：等待同步</li>\n<li>FAILOVER_IN_PROGRESS：进行中</li>\n</ul>\n<p>进入 FAILOVER_WAIT_FOR_SYNC 状态后，实例会定期检查当前的failover情况。若超时，则确定是否存在force标识，存在则强制进行切主操作。否则则中断 failover 进度。</p>\n<p>正常流程，则会选择一个 replica 作为目标实例进行 failover。 目标实例的标准若非自行选择，则要求 offset 必须拉齐，保证数据完整性。</p>\n<p>等待 replica 数据同步完成后，便进入 FAILOVER_IN_PROGRESS 进行实例切换。</p>\n<h3 id=\"实例切换\"><a href=\"#实例切换\" class=\"headerlink\" title=\"实例切换\"></a>实例切换</h3><p>在 FAILOVER_IN_PROGRESS 过程中，需要关注什么下会转换为 NO_FAILOVER 状态。在建立关系后，旧 Master 收到新 Master 的 <code>+CONTINUE</code> 或 <code>+FULLRESYNC</code> 信息，则认为关系已经建立，可以清理掉 failover 状态。</p>\n<p>而在建立连接时，旧 Master 会发送 <code>PSYNC &lt;replid&gt; &lt;reploff&gt; FAILOVER</code> 命令给新 Master。此操作主要是告知新 Master 需要从原有的 Replica 状态转换为 Master。</p>\n<h3 id=\"数据保证\"><a href=\"#数据保证\" class=\"headerlink\" title=\"数据保证\"></a>数据保证</h3><p>在整个 Failover 过程中，旧 Master 会进行停写，同时，不再对所有 Replica 进行数据传输（包括PING操作），以此，实际的数据不会变化，这样对整个复制链的数据迁移是友好的。故，理论上在 主从切换时，大概率是增量同步，且数据不会丢失。</p>\n"},{"title":"Redis中的内存统计","abbrlink":39146,"date":"2023-01-05T15:56:45.000Z","_content":"\nRedis中的内存计算，由于最初未使用很好的分类，导致最初的内存统计只能通过反推。通过各项指标的计算，并进行扣除已知的项目，剩余的内存被就认为是业务所需的空间。此文单独将相关的内存项目进行归纳，确定有多少空间是被认为是Redis自身所需的空间。\n\n### 计算逻辑\n\n由于整个计算逻辑相对比较简单，那当前就直接贴出代码：\n\n```\nint getMaxmemoryState(size_t *total, size_t *logical, size_t *tofree, float *level) {\n    size_t mem_reported, mem_used, mem_tofree;\n\n    /* Check if we are over the memory usage limit. If we are not, no need\n     * to subtract the slaves output buffers. We can just return ASAP. */\n    mem_reported = zmalloc_used_memory();\n    if (total) *total = mem_reported;\n\n    /* We may return ASAP if there is no need to compute the level. */\n    if (!server.maxmemory) {\n        if (level) *level = 0;\n        return C_OK;\n    }\n    if (mem_reported <= server.maxmemory && !level) return C_OK;\n\n    /* Remove the size of slaves output buffers and AOF buffer from the\n     * count of used memory. */\n    mem_used = mem_reported;\n    size_t overhead = freeMemoryGetNotCountedMemory();\n    mem_used = (mem_used > overhead) ? mem_used-overhead : 0;\n\n    /* Compute the ratio of memory usage. */\n    if (level) *level = (float)mem_used / (float)server.maxmemory;\n\n    if (mem_reported <= server.maxmemory) return C_OK;\n\n    /* Check if we are still over the memory limit. */\n    if (mem_used <= server.maxmemory) return C_OK;\n\n    /* Compute how much memory we need to free. */\n    mem_tofree = mem_used - server.maxmemory;\n\n    if (logical) *logical = mem_used;\n    if (tofree) *tofree = mem_tofree;\n\n    return C_ERR;\n}\n```\n\n当前方法主要用于在内存淘汰的计算，故，优先判断 maxmemory 和 malloc 的空间，确定是否需要淘汰。\n\n剩余的空间，主要是用于判断 无需处理的空间：overhead。这时候，整个逻辑可以得到3块数据：\n\n1. logical - 实际业务使用的空间\n2. tofree - 实际需要释放的空间\n3. total - 总共申请的空间\n\n同时，level 是为了给 Module 模式下用于判断空间情况。故本期不做详解。\n\n### 非业务的空间\n\n针对非业务空间，其实存在很多可以考虑的。但是，在整个社区版本中，主要针对俩块空间进行豁免：aof_buf、repl_buffer_mem。\n\n```\n    if ((long long)server.repl_buffer_mem > server.repl_backlog_size) {\n        /* We use list structure to manage replication buffer blocks, so backlog\n         * also occupies some extra memory, we can't know exact blocks numbers,\n         * we only get approximate size according to per block size. */\n        size_t extra_approx_size =\n            (server.repl_backlog_size/PROTO_REPLY_CHUNK_BYTES + 1) *\n            (sizeof(replBufBlock)+sizeof(listNode));\n        size_t counted_mem = server.repl_backlog_size + extra_approx_size;\n        if (server.repl_buffer_mem > counted_mem) {\n            overhead += (server.repl_buffer_mem - counted_mem);\n        }\n    }\n\n    if (server.aof_state != AOF_OFF) {\n        overhead += sdsAllocSize(server.aof_buf);\n    }\n    return overhead;\n```\n\n其中，repl_buffer_mem 的空间，由于会被定期清理，故，主要会豁免掉超出的部分。\n\n### 可观测的空间\n\n既然整个的内存空间，并不能豁免太多空间，那么，我们还需要确定一下，哪些空间属于业务可观测。\n\n此时，可观测的空间可以通过命令查看：\n```\nMEMORY DOCTOR\n```\n\n普通的字段信息：\n\n|字段                   |描述   |来源|\n|--|--|--|\n|peak_allocated         |最大的内存空间|server.stat_peak_memory|\n|peak_perc              |当前使用的空间占有的比例||\n|total_allocated        |实际分配的全部|zmalloc_used|\n|startup_allocated      |启动时的初始化空间|initial_memory_usage|\n|repl_backlog           |实际的backlog空间||\n|clients_slaves         |backlog超出的空间，Redis7独有||\n|clients_normal         |普通客户端实际限制的空间|stat_clients_type_memory|\n|cluster_links          |cluster模式下的连接空间|stat_cluster_links_memory|\n|aof_buffer             |aof的buffer空间|aof_buf|\n|lua_caches             |统计整个lua中使用的空间，包括script空间||\n|functions_caches       |统计整个function中使用的空间||\n|overhead_total         |包括所有的空间||\n|dataset                |除去上述的空间后，剩下的数据空间||\n|total_keys             |所有db的key个数|dictSize(db->dict)|\n|bytes_per_key          |每个key平均占有的空间||\n|dataset_perc           |数据空间的占比||\n\n碎片空间的字段信息：\n\n|字段                   |描述   |来源|\n|--|--|--|\n|total_frag             |实际使用空间较分配空间的比例|rss / used|\n|total_frag_bytes       |实际使用空间超出分配空间的大小|rss - used|\n|rss_extra              |实际使用空间较常驻空间的比例|rss / resident|\n|rss_extra_bytes        |实际使用空间超出常驻空间的大小|rss - resident|\n|allocator_frag         |活跃的空间较分配空间的比例|active / allocated|\n|allocator_frag_bytes   |活跃的空间超出分配空间的大小|active - allocated|\n|allocator_rss          |分配空间较活跃的空间的比例|resident / active|\n|allocator_rss_bytes    |分配空间超出活跃的空间的大小|resident - active|\n\n\n其中 resident, active, allocated 三个变量的意义至关重要：\n\n- resident：实际使用的物理内存数，但是与OS的RSS不同，这里不包含共享库和other non heap mappings（这里的我的理解是一般的page分为Anonymous page和File-backed Pages，前者映射我们熟悉的堆栈，后者一般用于文件缓存，所以这里拿到的其实是进程实际的RSS减去共享库和File-backed Pages[1]）。\n- active：与 resident 不同，这不包括 jemalloc 保留以供重用的页面(purge will clean that)。\n- allocated：与 zmalloc_used_memory 不同，它通过考虑此进程完成的所有分配（不仅是 zmalloc）来匹配 stats.resident。zmalloc的内存计算中 AOF buffers 以及 slaves output buffers 不被计算在内。\n","source":"_posts/Redis中的内存统计.md","raw":"---\ntitle: Redis中的内存统计\nabbrlink: 39146\ndate: 2023-01-05 23:56:45\ntags:\n---\n\nRedis中的内存计算，由于最初未使用很好的分类，导致最初的内存统计只能通过反推。通过各项指标的计算，并进行扣除已知的项目，剩余的内存被就认为是业务所需的空间。此文单独将相关的内存项目进行归纳，确定有多少空间是被认为是Redis自身所需的空间。\n\n### 计算逻辑\n\n由于整个计算逻辑相对比较简单，那当前就直接贴出代码：\n\n```\nint getMaxmemoryState(size_t *total, size_t *logical, size_t *tofree, float *level) {\n    size_t mem_reported, mem_used, mem_tofree;\n\n    /* Check if we are over the memory usage limit. If we are not, no need\n     * to subtract the slaves output buffers. We can just return ASAP. */\n    mem_reported = zmalloc_used_memory();\n    if (total) *total = mem_reported;\n\n    /* We may return ASAP if there is no need to compute the level. */\n    if (!server.maxmemory) {\n        if (level) *level = 0;\n        return C_OK;\n    }\n    if (mem_reported <= server.maxmemory && !level) return C_OK;\n\n    /* Remove the size of slaves output buffers and AOF buffer from the\n     * count of used memory. */\n    mem_used = mem_reported;\n    size_t overhead = freeMemoryGetNotCountedMemory();\n    mem_used = (mem_used > overhead) ? mem_used-overhead : 0;\n\n    /* Compute the ratio of memory usage. */\n    if (level) *level = (float)mem_used / (float)server.maxmemory;\n\n    if (mem_reported <= server.maxmemory) return C_OK;\n\n    /* Check if we are still over the memory limit. */\n    if (mem_used <= server.maxmemory) return C_OK;\n\n    /* Compute how much memory we need to free. */\n    mem_tofree = mem_used - server.maxmemory;\n\n    if (logical) *logical = mem_used;\n    if (tofree) *tofree = mem_tofree;\n\n    return C_ERR;\n}\n```\n\n当前方法主要用于在内存淘汰的计算，故，优先判断 maxmemory 和 malloc 的空间，确定是否需要淘汰。\n\n剩余的空间，主要是用于判断 无需处理的空间：overhead。这时候，整个逻辑可以得到3块数据：\n\n1. logical - 实际业务使用的空间\n2. tofree - 实际需要释放的空间\n3. total - 总共申请的空间\n\n同时，level 是为了给 Module 模式下用于判断空间情况。故本期不做详解。\n\n### 非业务的空间\n\n针对非业务空间，其实存在很多可以考虑的。但是，在整个社区版本中，主要针对俩块空间进行豁免：aof_buf、repl_buffer_mem。\n\n```\n    if ((long long)server.repl_buffer_mem > server.repl_backlog_size) {\n        /* We use list structure to manage replication buffer blocks, so backlog\n         * also occupies some extra memory, we can't know exact blocks numbers,\n         * we only get approximate size according to per block size. */\n        size_t extra_approx_size =\n            (server.repl_backlog_size/PROTO_REPLY_CHUNK_BYTES + 1) *\n            (sizeof(replBufBlock)+sizeof(listNode));\n        size_t counted_mem = server.repl_backlog_size + extra_approx_size;\n        if (server.repl_buffer_mem > counted_mem) {\n            overhead += (server.repl_buffer_mem - counted_mem);\n        }\n    }\n\n    if (server.aof_state != AOF_OFF) {\n        overhead += sdsAllocSize(server.aof_buf);\n    }\n    return overhead;\n```\n\n其中，repl_buffer_mem 的空间，由于会被定期清理，故，主要会豁免掉超出的部分。\n\n### 可观测的空间\n\n既然整个的内存空间，并不能豁免太多空间，那么，我们还需要确定一下，哪些空间属于业务可观测。\n\n此时，可观测的空间可以通过命令查看：\n```\nMEMORY DOCTOR\n```\n\n普通的字段信息：\n\n|字段                   |描述   |来源|\n|--|--|--|\n|peak_allocated         |最大的内存空间|server.stat_peak_memory|\n|peak_perc              |当前使用的空间占有的比例||\n|total_allocated        |实际分配的全部|zmalloc_used|\n|startup_allocated      |启动时的初始化空间|initial_memory_usage|\n|repl_backlog           |实际的backlog空间||\n|clients_slaves         |backlog超出的空间，Redis7独有||\n|clients_normal         |普通客户端实际限制的空间|stat_clients_type_memory|\n|cluster_links          |cluster模式下的连接空间|stat_cluster_links_memory|\n|aof_buffer             |aof的buffer空间|aof_buf|\n|lua_caches             |统计整个lua中使用的空间，包括script空间||\n|functions_caches       |统计整个function中使用的空间||\n|overhead_total         |包括所有的空间||\n|dataset                |除去上述的空间后，剩下的数据空间||\n|total_keys             |所有db的key个数|dictSize(db->dict)|\n|bytes_per_key          |每个key平均占有的空间||\n|dataset_perc           |数据空间的占比||\n\n碎片空间的字段信息：\n\n|字段                   |描述   |来源|\n|--|--|--|\n|total_frag             |实际使用空间较分配空间的比例|rss / used|\n|total_frag_bytes       |实际使用空间超出分配空间的大小|rss - used|\n|rss_extra              |实际使用空间较常驻空间的比例|rss / resident|\n|rss_extra_bytes        |实际使用空间超出常驻空间的大小|rss - resident|\n|allocator_frag         |活跃的空间较分配空间的比例|active / allocated|\n|allocator_frag_bytes   |活跃的空间超出分配空间的大小|active - allocated|\n|allocator_rss          |分配空间较活跃的空间的比例|resident / active|\n|allocator_rss_bytes    |分配空间超出活跃的空间的大小|resident - active|\n\n\n其中 resident, active, allocated 三个变量的意义至关重要：\n\n- resident：实际使用的物理内存数，但是与OS的RSS不同，这里不包含共享库和other non heap mappings（这里的我的理解是一般的page分为Anonymous page和File-backed Pages，前者映射我们熟悉的堆栈，后者一般用于文件缓存，所以这里拿到的其实是进程实际的RSS减去共享库和File-backed Pages[1]）。\n- active：与 resident 不同，这不包括 jemalloc 保留以供重用的页面(purge will clean that)。\n- allocated：与 zmalloc_used_memory 不同，它通过考虑此进程完成的所有分配（不仅是 zmalloc）来匹配 stats.resident。zmalloc的内存计算中 AOF buffers 以及 slaves output buffers 不被计算在内。\n","slug":"Redis中的内存统计","published":1,"updated":"2023-01-05T15:57:24.432Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clf3c2gcu00064cuqhgisb52j","content":"<p>Redis中的内存计算，由于最初未使用很好的分类，导致最初的内存统计只能通过反推。通过各项指标的计算，并进行扣除已知的项目，剩余的内存被就认为是业务所需的空间。此文单独将相关的内存项目进行归纳，确定有多少空间是被认为是Redis自身所需的空间。</p>\n<h3 id=\"计算逻辑\"><a href=\"#计算逻辑\" class=\"headerlink\" title=\"计算逻辑\"></a>计算逻辑</h3><p>由于整个计算逻辑相对比较简单，那当前就直接贴出代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int getMaxmemoryState(size_t *total, size_t *logical, size_t *tofree, float *level) &#123;</span><br><span class=\"line\">    size_t mem_reported, mem_used, mem_tofree;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* Check if we are over the memory usage limit. If we are not, no need</span><br><span class=\"line\">     * to subtract the slaves output buffers. We can just return ASAP. */</span><br><span class=\"line\">    mem_reported = zmalloc_used_memory();</span><br><span class=\"line\">    if (total) *total = mem_reported;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* We may return ASAP if there is no need to compute the level. */</span><br><span class=\"line\">    if (!server.maxmemory) &#123;</span><br><span class=\"line\">        if (level) *level = 0;</span><br><span class=\"line\">        return C_OK;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (mem_reported &lt;= server.maxmemory &amp;&amp; !level) return C_OK;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* Remove the size of slaves output buffers and AOF buffer from the</span><br><span class=\"line\">     * count of used memory. */</span><br><span class=\"line\">    mem_used = mem_reported;</span><br><span class=\"line\">    size_t overhead = freeMemoryGetNotCountedMemory();</span><br><span class=\"line\">    mem_used = (mem_used &gt; overhead) ? mem_used-overhead : 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* Compute the ratio of memory usage. */</span><br><span class=\"line\">    if (level) *level = (float)mem_used / (float)server.maxmemory;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (mem_reported &lt;= server.maxmemory) return C_OK;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* Check if we are still over the memory limit. */</span><br><span class=\"line\">    if (mem_used &lt;= server.maxmemory) return C_OK;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* Compute how much memory we need to free. */</span><br><span class=\"line\">    mem_tofree = mem_used - server.maxmemory;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (logical) *logical = mem_used;</span><br><span class=\"line\">    if (tofree) *tofree = mem_tofree;</span><br><span class=\"line\"></span><br><span class=\"line\">    return C_ERR;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当前方法主要用于在内存淘汰的计算，故，优先判断 maxmemory 和 malloc 的空间，确定是否需要淘汰。</p>\n<p>剩余的空间，主要是用于判断 无需处理的空间：overhead。这时候，整个逻辑可以得到3块数据：</p>\n<ol>\n<li>logical - 实际业务使用的空间</li>\n<li>tofree - 实际需要释放的空间</li>\n<li>total - 总共申请的空间</li>\n</ol>\n<p>同时，level 是为了给 Module 模式下用于判断空间情况。故本期不做详解。</p>\n<h3 id=\"非业务的空间\"><a href=\"#非业务的空间\" class=\"headerlink\" title=\"非业务的空间\"></a>非业务的空间</h3><p>针对非业务空间，其实存在很多可以考虑的。但是，在整个社区版本中，主要针对俩块空间进行豁免：aof_buf、repl_buffer_mem。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if ((long long)server.repl_buffer_mem &gt; server.repl_backlog_size) &#123;</span><br><span class=\"line\">    /* We use list structure to manage replication buffer blocks, so backlog</span><br><span class=\"line\">     * also occupies some extra memory, we can&#x27;t know exact blocks numbers,</span><br><span class=\"line\">     * we only get approximate size according to per block size. */</span><br><span class=\"line\">    size_t extra_approx_size =</span><br><span class=\"line\">        (server.repl_backlog_size/PROTO_REPLY_CHUNK_BYTES + 1) *</span><br><span class=\"line\">        (sizeof(replBufBlock)+sizeof(listNode));</span><br><span class=\"line\">    size_t counted_mem = server.repl_backlog_size + extra_approx_size;</span><br><span class=\"line\">    if (server.repl_buffer_mem &gt; counted_mem) &#123;</span><br><span class=\"line\">        overhead += (server.repl_buffer_mem - counted_mem);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">if (server.aof_state != AOF_OFF) &#123;</span><br><span class=\"line\">    overhead += sdsAllocSize(server.aof_buf);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return overhead;</span><br></pre></td></tr></table></figure>\n\n<p>其中，repl_buffer_mem 的空间，由于会被定期清理，故，主要会豁免掉超出的部分。</p>\n<h3 id=\"可观测的空间\"><a href=\"#可观测的空间\" class=\"headerlink\" title=\"可观测的空间\"></a>可观测的空间</h3><p>既然整个的内存空间，并不能豁免太多空间，那么，我们还需要确定一下，哪些空间属于业务可观测。</p>\n<p>此时，可观测的空间可以通过命令查看：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MEMORY DOCTOR</span><br></pre></td></tr></table></figure>\n\n<p>普通的字段信息：</p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>描述</th>\n<th>来源</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>peak_allocated</td>\n<td>最大的内存空间</td>\n<td>server.stat_peak_memory</td>\n</tr>\n<tr>\n<td>peak_perc</td>\n<td>当前使用的空间占有的比例</td>\n<td></td>\n</tr>\n<tr>\n<td>total_allocated</td>\n<td>实际分配的全部</td>\n<td>zmalloc_used</td>\n</tr>\n<tr>\n<td>startup_allocated</td>\n<td>启动时的初始化空间</td>\n<td>initial_memory_usage</td>\n</tr>\n<tr>\n<td>repl_backlog</td>\n<td>实际的backlog空间</td>\n<td></td>\n</tr>\n<tr>\n<td>clients_slaves</td>\n<td>backlog超出的空间，Redis7独有</td>\n<td></td>\n</tr>\n<tr>\n<td>clients_normal</td>\n<td>普通客户端实际限制的空间</td>\n<td>stat_clients_type_memory</td>\n</tr>\n<tr>\n<td>cluster_links</td>\n<td>cluster模式下的连接空间</td>\n<td>stat_cluster_links_memory</td>\n</tr>\n<tr>\n<td>aof_buffer</td>\n<td>aof的buffer空间</td>\n<td>aof_buf</td>\n</tr>\n<tr>\n<td>lua_caches</td>\n<td>统计整个lua中使用的空间，包括script空间</td>\n<td></td>\n</tr>\n<tr>\n<td>functions_caches</td>\n<td>统计整个function中使用的空间</td>\n<td></td>\n</tr>\n<tr>\n<td>overhead_total</td>\n<td>包括所有的空间</td>\n<td></td>\n</tr>\n<tr>\n<td>dataset</td>\n<td>除去上述的空间后，剩下的数据空间</td>\n<td></td>\n</tr>\n<tr>\n<td>total_keys</td>\n<td>所有db的key个数</td>\n<td>dictSize(db-&gt;dict)</td>\n</tr>\n<tr>\n<td>bytes_per_key</td>\n<td>每个key平均占有的空间</td>\n<td></td>\n</tr>\n<tr>\n<td>dataset_perc</td>\n<td>数据空间的占比</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>碎片空间的字段信息：</p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>描述</th>\n<th>来源</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>total_frag</td>\n<td>实际使用空间较分配空间的比例</td>\n<td>rss / used</td>\n</tr>\n<tr>\n<td>total_frag_bytes</td>\n<td>实际使用空间超出分配空间的大小</td>\n<td>rss - used</td>\n</tr>\n<tr>\n<td>rss_extra</td>\n<td>实际使用空间较常驻空间的比例</td>\n<td>rss / resident</td>\n</tr>\n<tr>\n<td>rss_extra_bytes</td>\n<td>实际使用空间超出常驻空间的大小</td>\n<td>rss - resident</td>\n</tr>\n<tr>\n<td>allocator_frag</td>\n<td>活跃的空间较分配空间的比例</td>\n<td>active / allocated</td>\n</tr>\n<tr>\n<td>allocator_frag_bytes</td>\n<td>活跃的空间超出分配空间的大小</td>\n<td>active - allocated</td>\n</tr>\n<tr>\n<td>allocator_rss</td>\n<td>分配空间较活跃的空间的比例</td>\n<td>resident / active</td>\n</tr>\n<tr>\n<td>allocator_rss_bytes</td>\n<td>分配空间超出活跃的空间的大小</td>\n<td>resident - active</td>\n</tr>\n</tbody></table>\n<p>其中 resident, active, allocated 三个变量的意义至关重要：</p>\n<ul>\n<li>resident：实际使用的物理内存数，但是与OS的RSS不同，这里不包含共享库和other non heap mappings（这里的我的理解是一般的page分为Anonymous page和File-backed Pages，前者映射我们熟悉的堆栈，后者一般用于文件缓存，所以这里拿到的其实是进程实际的RSS减去共享库和File-backed Pages[1]）。</li>\n<li>active：与 resident 不同，这不包括 jemalloc 保留以供重用的页面(purge will clean that)。</li>\n<li>allocated：与 zmalloc_used_memory 不同，它通过考虑此进程完成的所有分配（不仅是 zmalloc）来匹配 stats.resident。zmalloc的内存计算中 AOF buffers 以及 slaves output buffers 不被计算在内。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>Redis中的内存计算，由于最初未使用很好的分类，导致最初的内存统计只能通过反推。通过各项指标的计算，并进行扣除已知的项目，剩余的内存被就认为是业务所需的空间。此文单独将相关的内存项目进行归纳，确定有多少空间是被认为是Redis自身所需的空间。</p>\n<h3 id=\"计算逻辑\"><a href=\"#计算逻辑\" class=\"headerlink\" title=\"计算逻辑\"></a>计算逻辑</h3><p>由于整个计算逻辑相对比较简单，那当前就直接贴出代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int getMaxmemoryState(size_t *total, size_t *logical, size_t *tofree, float *level) &#123;</span><br><span class=\"line\">    size_t mem_reported, mem_used, mem_tofree;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* Check if we are over the memory usage limit. If we are not, no need</span><br><span class=\"line\">     * to subtract the slaves output buffers. We can just return ASAP. */</span><br><span class=\"line\">    mem_reported = zmalloc_used_memory();</span><br><span class=\"line\">    if (total) *total = mem_reported;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* We may return ASAP if there is no need to compute the level. */</span><br><span class=\"line\">    if (!server.maxmemory) &#123;</span><br><span class=\"line\">        if (level) *level = 0;</span><br><span class=\"line\">        return C_OK;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (mem_reported &lt;= server.maxmemory &amp;&amp; !level) return C_OK;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* Remove the size of slaves output buffers and AOF buffer from the</span><br><span class=\"line\">     * count of used memory. */</span><br><span class=\"line\">    mem_used = mem_reported;</span><br><span class=\"line\">    size_t overhead = freeMemoryGetNotCountedMemory();</span><br><span class=\"line\">    mem_used = (mem_used &gt; overhead) ? mem_used-overhead : 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* Compute the ratio of memory usage. */</span><br><span class=\"line\">    if (level) *level = (float)mem_used / (float)server.maxmemory;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (mem_reported &lt;= server.maxmemory) return C_OK;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* Check if we are still over the memory limit. */</span><br><span class=\"line\">    if (mem_used &lt;= server.maxmemory) return C_OK;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* Compute how much memory we need to free. */</span><br><span class=\"line\">    mem_tofree = mem_used - server.maxmemory;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (logical) *logical = mem_used;</span><br><span class=\"line\">    if (tofree) *tofree = mem_tofree;</span><br><span class=\"line\"></span><br><span class=\"line\">    return C_ERR;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当前方法主要用于在内存淘汰的计算，故，优先判断 maxmemory 和 malloc 的空间，确定是否需要淘汰。</p>\n<p>剩余的空间，主要是用于判断 无需处理的空间：overhead。这时候，整个逻辑可以得到3块数据：</p>\n<ol>\n<li>logical - 实际业务使用的空间</li>\n<li>tofree - 实际需要释放的空间</li>\n<li>total - 总共申请的空间</li>\n</ol>\n<p>同时，level 是为了给 Module 模式下用于判断空间情况。故本期不做详解。</p>\n<h3 id=\"非业务的空间\"><a href=\"#非业务的空间\" class=\"headerlink\" title=\"非业务的空间\"></a>非业务的空间</h3><p>针对非业务空间，其实存在很多可以考虑的。但是，在整个社区版本中，主要针对俩块空间进行豁免：aof_buf、repl_buffer_mem。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if ((long long)server.repl_buffer_mem &gt; server.repl_backlog_size) &#123;</span><br><span class=\"line\">    /* We use list structure to manage replication buffer blocks, so backlog</span><br><span class=\"line\">     * also occupies some extra memory, we can&#x27;t know exact blocks numbers,</span><br><span class=\"line\">     * we only get approximate size according to per block size. */</span><br><span class=\"line\">    size_t extra_approx_size =</span><br><span class=\"line\">        (server.repl_backlog_size/PROTO_REPLY_CHUNK_BYTES + 1) *</span><br><span class=\"line\">        (sizeof(replBufBlock)+sizeof(listNode));</span><br><span class=\"line\">    size_t counted_mem = server.repl_backlog_size + extra_approx_size;</span><br><span class=\"line\">    if (server.repl_buffer_mem &gt; counted_mem) &#123;</span><br><span class=\"line\">        overhead += (server.repl_buffer_mem - counted_mem);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">if (server.aof_state != AOF_OFF) &#123;</span><br><span class=\"line\">    overhead += sdsAllocSize(server.aof_buf);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return overhead;</span><br></pre></td></tr></table></figure>\n\n<p>其中，repl_buffer_mem 的空间，由于会被定期清理，故，主要会豁免掉超出的部分。</p>\n<h3 id=\"可观测的空间\"><a href=\"#可观测的空间\" class=\"headerlink\" title=\"可观测的空间\"></a>可观测的空间</h3><p>既然整个的内存空间，并不能豁免太多空间，那么，我们还需要确定一下，哪些空间属于业务可观测。</p>\n<p>此时，可观测的空间可以通过命令查看：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MEMORY DOCTOR</span><br></pre></td></tr></table></figure>\n\n<p>普通的字段信息：</p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>描述</th>\n<th>来源</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>peak_allocated</td>\n<td>最大的内存空间</td>\n<td>server.stat_peak_memory</td>\n</tr>\n<tr>\n<td>peak_perc</td>\n<td>当前使用的空间占有的比例</td>\n<td></td>\n</tr>\n<tr>\n<td>total_allocated</td>\n<td>实际分配的全部</td>\n<td>zmalloc_used</td>\n</tr>\n<tr>\n<td>startup_allocated</td>\n<td>启动时的初始化空间</td>\n<td>initial_memory_usage</td>\n</tr>\n<tr>\n<td>repl_backlog</td>\n<td>实际的backlog空间</td>\n<td></td>\n</tr>\n<tr>\n<td>clients_slaves</td>\n<td>backlog超出的空间，Redis7独有</td>\n<td></td>\n</tr>\n<tr>\n<td>clients_normal</td>\n<td>普通客户端实际限制的空间</td>\n<td>stat_clients_type_memory</td>\n</tr>\n<tr>\n<td>cluster_links</td>\n<td>cluster模式下的连接空间</td>\n<td>stat_cluster_links_memory</td>\n</tr>\n<tr>\n<td>aof_buffer</td>\n<td>aof的buffer空间</td>\n<td>aof_buf</td>\n</tr>\n<tr>\n<td>lua_caches</td>\n<td>统计整个lua中使用的空间，包括script空间</td>\n<td></td>\n</tr>\n<tr>\n<td>functions_caches</td>\n<td>统计整个function中使用的空间</td>\n<td></td>\n</tr>\n<tr>\n<td>overhead_total</td>\n<td>包括所有的空间</td>\n<td></td>\n</tr>\n<tr>\n<td>dataset</td>\n<td>除去上述的空间后，剩下的数据空间</td>\n<td></td>\n</tr>\n<tr>\n<td>total_keys</td>\n<td>所有db的key个数</td>\n<td>dictSize(db-&gt;dict)</td>\n</tr>\n<tr>\n<td>bytes_per_key</td>\n<td>每个key平均占有的空间</td>\n<td></td>\n</tr>\n<tr>\n<td>dataset_perc</td>\n<td>数据空间的占比</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>碎片空间的字段信息：</p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>描述</th>\n<th>来源</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>total_frag</td>\n<td>实际使用空间较分配空间的比例</td>\n<td>rss / used</td>\n</tr>\n<tr>\n<td>total_frag_bytes</td>\n<td>实际使用空间超出分配空间的大小</td>\n<td>rss - used</td>\n</tr>\n<tr>\n<td>rss_extra</td>\n<td>实际使用空间较常驻空间的比例</td>\n<td>rss / resident</td>\n</tr>\n<tr>\n<td>rss_extra_bytes</td>\n<td>实际使用空间超出常驻空间的大小</td>\n<td>rss - resident</td>\n</tr>\n<tr>\n<td>allocator_frag</td>\n<td>活跃的空间较分配空间的比例</td>\n<td>active / allocated</td>\n</tr>\n<tr>\n<td>allocator_frag_bytes</td>\n<td>活跃的空间超出分配空间的大小</td>\n<td>active - allocated</td>\n</tr>\n<tr>\n<td>allocator_rss</td>\n<td>分配空间较活跃的空间的比例</td>\n<td>resident / active</td>\n</tr>\n<tr>\n<td>allocator_rss_bytes</td>\n<td>分配空间超出活跃的空间的大小</td>\n<td>resident - active</td>\n</tr>\n</tbody></table>\n<p>其中 resident, active, allocated 三个变量的意义至关重要：</p>\n<ul>\n<li>resident：实际使用的物理内存数，但是与OS的RSS不同，这里不包含共享库和other non heap mappings（这里的我的理解是一般的page分为Anonymous page和File-backed Pages，前者映射我们熟悉的堆栈，后者一般用于文件缓存，所以这里拿到的其实是进程实际的RSS减去共享库和File-backed Pages[1]）。</li>\n<li>active：与 resident 不同，这不包括 jemalloc 保留以供重用的页面(purge will clean that)。</li>\n<li>allocated：与 zmalloc_used_memory 不同，它通过考虑此进程完成的所有分配（不仅是 zmalloc）来匹配 stats.resident。zmalloc的内存计算中 AOF buffers 以及 slaves output buffers 不被计算在内。</li>\n</ul>\n"},{"title":"Redis新协议-RESP3","abbrlink":9738,"date":"2023-01-08T15:44:38.000Z","_content":"\n在新的Redis中，由于存在一些Lua、Function、Module等插件类功能，其中需要依赖基础的call方法来调用原生方法，此时就需要对实际命令调用后结果进行解析。这也引入了对协议解析的抽象层。\n\n## 关于协议\n\n新的Resp3协议引入了很多概念，包括了Map、BigNumber、Set等，为了更好的了解协议情况，直接贴出解析入口方法：\n\n```\n/* Parse a reply pointed to by parser->curr_location. */\nint parseReply(ReplyParser *parser, void *p_ctx) {\n    switch (parser->curr_location[0]) {\n        case '$': return parseBulk(parser, p_ctx);\n        case '+': return parseSimpleString(parser, p_ctx);\n        case '-': return parseError(parser, p_ctx);\n        case ':': return parseLong(parser, p_ctx);\n        case '*': return parseArray(parser, p_ctx);\n        case '~': return parseSet(parser, p_ctx);\n        case '%': return parseMap(parser, p_ctx);\n        case '#': return parseBool(parser, p_ctx);\n        case ',': return parseDouble(parser, p_ctx);\n        case '_': return parseNull(parser, p_ctx);\n        case '(': return parseBigNumber(parser, p_ctx);\n        case '=': return parseVerbatimString(parser, p_ctx);\n        case '|': return parseAttributes(parser, p_ctx);\n        default: if (parser->callbacks.error) parser->callbacks.error(p_ctx);\n    }\n    return C_ERR;\n}\n\n```\n\n由此可见，此处有13个协议标记，单独予以归类：\n- 简单类型：`+`、`-`、`:`、`#`、`,`、`(`、`=`、`_`\n- 复杂类型：`$`、`*`、`~`、`%`、`|`\n\n为了统一进行解析，此处对协议解析进行了抽象：\n\n```\nstatic const ReplyParserCallbacks DefaultParserCallbacks = {\n    .null_callback = callReplyNull,\n    .bulk_string_callback = callReplyBulkString,\n    .null_bulk_string_callback = callReplyNullBulkString,\n    .null_array_callback = callReplyNullArray,\n    .error_callback = callReplyError,\n    .simple_str_callback = callReplySimpleStr,\n    .long_callback = callReplyLong,\n    .array_callback = callReplyArray,\n    .set_callback = callReplySet,\n    .map_callback = callReplyMap,\n    .double_callback = callReplyDouble,\n    .bool_callback = callReplyBool,\n    .big_number_callback = callReplyBigNumber,\n    .verbatim_string_callback = callReplyVerbatimString,\n    .attribute_callback = callReplyAttribute,\n    .error = callReplyParseError,\n};\n```\n\n实际的场景主要在于Module需要解析协议进行处理，以及Lua需要将协议转换为lua数据并执行。\n从最初的代码中，可以看到解析主要依赖俩块数据：`parser`、`ctx`，前者代码解析时回调，而后者主要是解析时传入的上下文信息。\n\n## 协议内容\n\n此处，针对不同类型的默认解析器进行讲解，方便后续理解\n\n### parseNull 解析\n\n协议为 `_` 数据，解析直接赋值相关类型以及长度，占用空间为3字节。\n\n```\nstatic int parseNull(ReplyParser *parser, void *p_ctx) {\n    const char *proto = parser->curr_location;\n    char *p = strchr(proto+1,'\\r');\n    parser->curr_location = p + 2; /* for \\r\\n */\n    parser->callbacks.null_callback(p_ctx, proto, parser->curr_location - proto);\n    return C_OK;\n}\n\nstatic void callReplyNull(void *ctx, const char *proto, size_t proto_len) {\n    CallReply *rep = ctx;\n    callReplySetSharedData(rep, REDISMODULE_REPLY_NULL, proto, proto_len, REPLY_FLAG_RESP3);\n}\n```\n\n### parseBulk 解析\n\n协议为 `$` 开头的数据，并解析出 2字节的长度信息以及实际的内容，如果长度为-1，则认为是空数据。与Null相同意思。\n\n```\nstatic int parseBulk(ReplyParser *parser, void *p_ctx) {\n    const char *proto = parser->curr_location;\n    char *p = strchr(proto+1,'\\r');\n    long long bulklen;\n    parser->curr_location = p + 2; /* for \\r\\n */\n\n    string2ll(proto+1,p-proto-1,&bulklen);\n    if (bulklen == -1) {\n        parser->callbacks.null_bulk_string_callback(p_ctx, proto, parser->curr_location - proto);\n    } else {\n        const char *str = parser->curr_location;\n        parser->curr_location += bulklen;\n        parser->curr_location += 2; /* for \\r\\n */\n        parser->callbacks.bulk_string_callback(p_ctx, str, bulklen, proto, parser->curr_location - proto);\n    }\n\n    return C_OK;\n}\n```\n\n### parseError 解析\n\n协议为 `-` 开头的数据，并解析出实际的内容，并直接设置具体内容。\n\n```\nstatic int parseError(ReplyParser *parser, void *p_ctx) {\n    const char *proto = parser->curr_location;\n    char *p = strchr(proto+1,'\\r');\n    parser->curr_location = p + 2; // for \\r\\n\n    parser->callbacks.error_callback(p_ctx, proto+1, p-proto-1, proto, parser->curr_location - proto);\n    return C_OK;\n}\n```\n\n### parseSimpleString 解析\n\n协议为 `-` 开头的数据，并解析出实际的内容，并直接设置具体内容。与Error一样的操作。\n\n```\nstatic int parseSimpleString(ReplyParser *parser, void *p_ctx) {\n    const char *proto = parser->curr_location;\n    char *p = strchr(proto+1,'\\r');\n    parser->curr_location = p + 2; /* for \\r\\n */\n    parser->callbacks.simple_str_callback(p_ctx, proto+1, p-proto-1, proto, parser->curr_location - proto);\n    return C_OK;\n}\n```\n\n### parseLong 解析\n\n协议为 `:` 开头的数据，并解析出 2字节的数据信息。\n\n```\nstatic int parseLong(ReplyParser *parser, void *p_ctx) {\n    const char *proto = parser->curr_location;\n    char *p = strchr(proto+1,'\\r');\n    parser->curr_location = p + 2; /* for \\r\\n */\n    long long val;\n    string2ll(proto+1,p-proto-1,&val);\n    parser->callbacks.long_callback(p_ctx, val, proto, parser->curr_location - proto);\n    return C_OK;\n}\n\nstatic void callReplyLong(void *ctx, long long val, const char *proto, size_t proto_len) {\n    CallReply *rep = ctx;\n    callReplySetSharedData(rep, REDISMODULE_REPLY_INTEGER, proto, proto_len, 0);\n    rep->val.ll = val;\n}\n\n```\n\n### parseArray 解析\n\n协议为 `$` 开头的数据，并解析出 2字节的元素个数信息，并最终调用`callReplyParseCollection` 进行递归解析协议内容。后续会单独讲解解析后的数据如何存放。\n\n```\nstatic int parseArray(ReplyParser *parser, void *p_ctx) {\n    const char *proto = parser->curr_location;\n    char *p = strchr(proto+1,'\\r');\n    long long len;\n    string2ll(proto+1,p-proto-1,&len);\n    p += 2;\n    parser->curr_location = p;\n    if (len == -1) {\n        parser->callbacks.null_array_callback(p_ctx, proto, parser->curr_location - proto);\n    } else {\n        parser->callbacks.array_callback(parser, p_ctx, len, proto);\n    }\n    return C_OK;\n}\n\nstatic void callReplyArray(ReplyParser *parser, void *ctx, size_t len, const char *proto) {\n    CallReply *rep = ctx;\n    rep->type = REDISMODULE_REPLY_ARRAY;\n    callReplyParseCollection(parser, rep, len, proto, 1);\n}\n```\n\n### parseSet 解析\n\n协议为 `~` 开头的数据，并解析出 2字节的元素个数信息，并最终调用`callReplyParseCollection` 进行递归解析协议内容。由此可见，Set和Array内容基本上相似。\n\n```\nstatic int parseSet(ReplyParser *parser, void *p_ctx) {\n    const char *proto = parser->curr_location;\n    char *p = strchr(proto+1,'\\r');\n    long long len;\n    string2ll(proto+1,p-proto-1,&len);\n    p += 2;\n    parser->curr_location = p;\n    parser->callbacks.set_callback(parser, p_ctx, len, proto);\n    return C_OK;\n}\n\nstatic void callReplySet(ReplyParser *parser, void *ctx, size_t len, const char *proto) {\n    CallReply *rep = ctx;\n    rep->type = REDISMODULE_REPLY_SET;\n    callReplyParseCollection(parser, rep, len, proto, 1);\n    rep->flags |= REPLY_FLAG_RESP3;\n}\n```\n\n### parseMap 解析\n\n协议为 `%` 开头的数据，并解析出 2字节的元素个数信息，并最终调用`callReplyParseCollection` 进行递归解析协议内容。由此可见，Set、Array、Map内容基本上相似。\n\n```\nstatic int parseMap(ReplyParser *parser, void *p_ctx) {\n    const char *proto = parser->curr_location;\n    char *p = strchr(proto+1,'\\r');\n    long long len;\n    string2ll(proto+1,p-proto-1,&len);\n    p += 2;\n    parser->curr_location = p;\n    parser->callbacks.map_callback(parser, p_ctx, len, proto);\n    return C_OK;\n}\n\nstatic void callReplyMap(ReplyParser *parser, void *ctx, size_t len, const char *proto) {\n    CallReply *rep = ctx;\n    rep->type = REDISMODULE_REPLY_MAP;\n    callReplyParseCollection(parser, rep, len, proto, 2);\n    rep->flags |= REPLY_FLAG_RESP3;\n}\n\n```\n\n\n### parseDouble 解析\n\n协议为 `,` 开头的数据，并解析出全量数据，并以此复制到buffer中，并进行转换，其中最大的空间为：`5*1024`。\n\n```\nstatic int parseDouble(ReplyParser *parser, void *p_ctx) {\n    const char *proto = parser->curr_location;\n    char *p = strchr(proto+1,'\\r');\n    parser->curr_location = p + 2; /* for \\r\\n */\n    char buf[MAX_LONG_DOUBLE_CHARS+1];\n    size_t len = p-proto-1;\n    double d;\n    if (len <= MAX_LONG_DOUBLE_CHARS) {\n        memcpy(buf,proto+1,len);\n        buf[len] = '\\0';\n        d = strtod(buf,NULL); /* We expect a valid representation. */\n    } else {\n        d = 0;\n    }\n    parser->callbacks.double_callback(p_ctx, d, proto, parser->curr_location - proto);\n    return C_OK;\n}\n\n```\n\n\n### parseBool 解析\n\n协议为 `#` 开头的数据，并解析一个字节：`t` 或者 `f`，来区分bool的数值。\n\n```\nstatic int parseBool(ReplyParser *parser, void *p_ctx) {\n    const char *proto = parser->curr_location;\n    char *p = strchr(proto+1,'\\r');\n    parser->curr_location = p + 2; /* for \\r\\n */\n    parser->callbacks.bool_callback(p_ctx, proto[1] == 't', proto, parser->curr_location - proto);\n    return C_OK;\n}\n\nstatic void callReplyBool(void *ctx, int val, const char *proto, size_t proto_len) {\n    CallReply *rep = ctx;\n    callReplySetSharedData(rep, REDISMODULE_REPLY_BOOL, proto, proto_len, REPLY_FLAG_RESP3);\n    rep->val.ll = val;\n}\n```\n\n### parseBigNumber 解析\n\n协议为 `(` 开头的数据，并解析出全量数据，并以此复制到buffer中，最终的表现形式还是为字符串。\n\n```\nstatic int parseBigNumber(ReplyParser *parser, void *p_ctx) {\n    const char *proto = parser->curr_location;\n    char *p = strchr(proto+1,'\\r');\n    parser->curr_location = p + 2; /* for \\r\\n */\n    parser->callbacks.big_number_callback(p_ctx, proto+1, p-proto-1, proto, parser->curr_location - proto);\n    return C_OK;\n}\n\nstatic void callReplyBigNumber(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len) {\n    CallReply *rep = ctx;\n    callReplySetSharedData(rep, REDISMODULE_REPLY_BIG_NUMBER, proto, proto_len, REPLY_FLAG_RESP3);\n    rep->len = len;\n    rep->val.str = str;\n}\n```\n\n### parseAttributes 解析\n\n协议为 `|` 开头的数据，并解析出 2字节的元素个数信息，并最终调用`callReplyParseCollection` 进行递归解析协议内容，解析后，会再次调用 `parseReply` 单独解析内容。\n\n```\nstatic int parseAttributes(ReplyParser *parser, void *p_ctx) {\n    const char *proto = parser->curr_location;\n    char *p = strchr(proto+1,'\\r');\n    long long len;\n    string2ll(proto+1,p-proto-1,&len);\n    p += 2;\n    parser->curr_location = p;\n    parser->callbacks.attribute_callback(parser, p_ctx, len, proto);\n    return C_OK;\n}\n\nstatic void callReplyAttribute(ReplyParser *parser, void *ctx, size_t len, const char *proto) {\n    CallReply *rep = ctx;\n    rep->attribute = zcalloc(sizeof(CallReply));\n\n    /* Continue parsing the attribute reply */\n    rep->attribute->len = len;\n    rep->attribute->type = REDISMODULE_REPLY_ATTRIBUTE;\n    callReplyParseCollection(parser, rep->attribute, len, proto, 2);\n    rep->attribute->flags |= REPLY_FLAG_PARSED | REPLY_FLAG_RESP3;\n    rep->attribute->private_data = rep->private_data;\n\n    /* Continue parsing the reply */\n    parseReply(parser, rep);\n\n    /* In this case we need to fix the proto address and len, it should start from the attribute */\n    rep->proto = proto;\n    rep->proto_len = parser->curr_location - proto;\n    rep->flags |= REPLY_FLAG_RESP3;\n}\n\n```\n\n### parseVerbatimString 解析\n\n协议为 `=` 开头的数据，并解析出2字节的长度后，由会取出4个字节作为format信息，最终剩余的空间为二进制安全字符串。\n\n```\nstatic int parseVerbatimString(ReplyParser *parser, void *p_ctx) {\n    const char *proto = parser->curr_location;\n    char *p = strchr(proto+1,'\\r');\n    long long bulklen;\n    parser->curr_location = p + 2; /* for \\r\\n */\n    string2ll(proto+1,p-proto-1,&bulklen);\n    const char *format = parser->curr_location;\n    parser->curr_location += bulklen;\n    parser->curr_location += 2; /* for \\r\\n */\n    parser->callbacks.verbatim_string_callback(p_ctx, format, format + 4, bulklen - 4, proto, parser->curr_location - proto);\n    return C_OK;\n}\n\nstatic void callReplyVerbatimString(void *ctx, const char *format, const char *str, size_t len, const char *proto, size_t proto_len) {\n    CallReply *rep = ctx;\n    callReplySetSharedData(rep, REDISMODULE_REPLY_VERBATIM_STRING, proto, proto_len, REPLY_FLAG_RESP3);\n    rep->len = len;\n    rep->val.verbatim_str.str = str;\n    rep->val.verbatim_str.format = format;\n}\n```\n\n\n\n## 特殊源码\n\n### 协议结构\n\n单独来了解一下默认协议的表示结构体：\n\n```\nstruct CallReply {\n    void *private_data;\n    sds original_proto; /* Available only for root reply. */\n    const char *proto;\n    size_t proto_len;\n    int type;       /* REPLY_... */\n    int flags;      /* REPLY_FLAG... */\n    size_t len;     /* Length of a string, or the number elements in an array. */\n    union {\n        const char *str; /* String pointer for string and error replies. This\n                          * does not need to be freed, always points inside\n                          * a reply->proto buffer of the reply object or, in\n                          * case of array elements, of parent reply objects. */\n        struct {\n            const char *str;\n            const char *format;\n        } verbatim_str;  /* Reply value for verbatim string */\n        long long ll;    /* Reply value for integer reply. */\n        double d;        /* Reply value for double reply. */\n        struct CallReply *array; /* Array of sub-reply elements. used for set, array, map, and attribute */\n    } val;\n    list *deferred_error_list;   /* list of errors in sds form or NULL */\n    struct CallReply *attribute; /* attribute reply, NULL if not exists */\n};\n```\n\n大体可以分为三块内容：\n1. 协议信息\n2. 数据部分\n3. 析构处理\n\n#### 协议信息\n\n```\n    void *private_data;\n    sds original_proto; /* Available only for root reply. */\n    const char *proto;\n    size_t proto_len;\n    int type;       /* REPLY_... */\n    int flags;      /* REPLY_FLAG... */\n    size_t len;     /* Length of a string, or the number elements in an array. */\n```\n\n从上到下分别为：特殊透传数据、reply根地址、reply当前解析地址、reply长度、当前协议类型、当前的标记位。\n\n#### 数据部分\n\n```\n    size_t len;     /* Length of a string, or the number elements in an array. */\n    union {\n        const char *str; /* String pointer for string and error replies. This\n                          * does not need to be freed, always points inside\n                          * a reply->proto buffer of the reply object or, in\n                          * case of array elements, of parent reply objects. */\n        struct {\n            const char *str;\n            const char *format;\n        } verbatim_str;  /* Reply value for verbatim string */\n        long long ll;    /* Reply value for integer reply. */\n        double d;        /* Reply value for double reply. */\n        struct CallReply *array; /* Array of sub-reply elements. used for set, array, map, and attribute */\n    } val;\n\t   struct CallReply *attribute; /* attribute reply, NULL if not exists */\n```\n\n整体通过一个union属性来包裹了value信息，其中有string、verbatim_str、number、double、array类型，同时这部分还有一个len代表元素的长度信息。\n\n其中，我们将 `attribute` 也做为数据部分看待，因为，它也可以表示实际的信息。\n\n### 析构处理\n\n```\n    list *deferred_error_list;   /* list of errors in sds form or NULL */\n```\n\n这块的逻辑主要是在于完成解析后，数据的释放流程：\n\n```\nvoid freeCallReply(CallReply *rep) {\n    if (!(rep->flags & REPLY_FLAG_ROOT)) {\n        return;\n    }\n    if (rep->flags & REPLY_FLAG_PARSED) {\n        freeCallReplyInternal(rep);\n    }\n    sdsfree(rep->original_proto);\n    if (rep->deferred_error_list)\n        listRelease(rep->deferred_error_list);\n    zfree(rep);\n}\n```\n\n### 递归逻辑\n\n本节单独解析 `callReplyParseCollection` 方法，源码如下：\n\n```\nstatic void callReplyParseCollection(ReplyParser *parser, CallReply *rep, size_t len, const char *proto, size_t elements_per_entry) {\n    rep->len = len;\n    rep->val.array = zcalloc(elements_per_entry * len * sizeof(CallReply));\n    for (size_t i = 0; i < len * elements_per_entry; i += elements_per_entry) {\n        for (size_t j = 0 ; j < elements_per_entry ; ++j) {\n            rep->val.array[i + j].private_data = rep->private_data;\n            parseReply(parser, rep->val.array + i + j);\n            rep->val.array[i + j].flags |= REPLY_FLAG_PARSED;\n            if (rep->val.array[i + j].flags & REPLY_FLAG_RESP3) {\n                /* If one of the sub-replies is RESP3, then the current reply is also RESP3. */\n                rep->flags |= REPLY_FLAG_RESP3;\n            }\n        }\n    }\n    rep->proto = proto;\n    rep->proto_len = parser->curr_location - proto;\n}\n```\n\n其中有趣的点在于，为了支持Map和Array的操作，增加了len和elements_per_entry变量。前者表示元素个数，后者则代表，每个元素中，存在多少个数据。例如Map每个元素存在key和value俩类数据，而Array只存在Value。这么设计最终完成了Map和Array的统一，以及更好的支持了Map本身递归表示的能力。","source":"_posts/Redis新协议-RESP3.md","raw":"---\ntitle: Redis新协议-RESP3\nabbrlink: 9738\ndate: 2023-01-08 23:44:38\ntags:\n---\n\n在新的Redis中，由于存在一些Lua、Function、Module等插件类功能，其中需要依赖基础的call方法来调用原生方法，此时就需要对实际命令调用后结果进行解析。这也引入了对协议解析的抽象层。\n\n## 关于协议\n\n新的Resp3协议引入了很多概念，包括了Map、BigNumber、Set等，为了更好的了解协议情况，直接贴出解析入口方法：\n\n```\n/* Parse a reply pointed to by parser->curr_location. */\nint parseReply(ReplyParser *parser, void *p_ctx) {\n    switch (parser->curr_location[0]) {\n        case '$': return parseBulk(parser, p_ctx);\n        case '+': return parseSimpleString(parser, p_ctx);\n        case '-': return parseError(parser, p_ctx);\n        case ':': return parseLong(parser, p_ctx);\n        case '*': return parseArray(parser, p_ctx);\n        case '~': return parseSet(parser, p_ctx);\n        case '%': return parseMap(parser, p_ctx);\n        case '#': return parseBool(parser, p_ctx);\n        case ',': return parseDouble(parser, p_ctx);\n        case '_': return parseNull(parser, p_ctx);\n        case '(': return parseBigNumber(parser, p_ctx);\n        case '=': return parseVerbatimString(parser, p_ctx);\n        case '|': return parseAttributes(parser, p_ctx);\n        default: if (parser->callbacks.error) parser->callbacks.error(p_ctx);\n    }\n    return C_ERR;\n}\n\n```\n\n由此可见，此处有13个协议标记，单独予以归类：\n- 简单类型：`+`、`-`、`:`、`#`、`,`、`(`、`=`、`_`\n- 复杂类型：`$`、`*`、`~`、`%`、`|`\n\n为了统一进行解析，此处对协议解析进行了抽象：\n\n```\nstatic const ReplyParserCallbacks DefaultParserCallbacks = {\n    .null_callback = callReplyNull,\n    .bulk_string_callback = callReplyBulkString,\n    .null_bulk_string_callback = callReplyNullBulkString,\n    .null_array_callback = callReplyNullArray,\n    .error_callback = callReplyError,\n    .simple_str_callback = callReplySimpleStr,\n    .long_callback = callReplyLong,\n    .array_callback = callReplyArray,\n    .set_callback = callReplySet,\n    .map_callback = callReplyMap,\n    .double_callback = callReplyDouble,\n    .bool_callback = callReplyBool,\n    .big_number_callback = callReplyBigNumber,\n    .verbatim_string_callback = callReplyVerbatimString,\n    .attribute_callback = callReplyAttribute,\n    .error = callReplyParseError,\n};\n```\n\n实际的场景主要在于Module需要解析协议进行处理，以及Lua需要将协议转换为lua数据并执行。\n从最初的代码中，可以看到解析主要依赖俩块数据：`parser`、`ctx`，前者代码解析时回调，而后者主要是解析时传入的上下文信息。\n\n## 协议内容\n\n此处，针对不同类型的默认解析器进行讲解，方便后续理解\n\n### parseNull 解析\n\n协议为 `_` 数据，解析直接赋值相关类型以及长度，占用空间为3字节。\n\n```\nstatic int parseNull(ReplyParser *parser, void *p_ctx) {\n    const char *proto = parser->curr_location;\n    char *p = strchr(proto+1,'\\r');\n    parser->curr_location = p + 2; /* for \\r\\n */\n    parser->callbacks.null_callback(p_ctx, proto, parser->curr_location - proto);\n    return C_OK;\n}\n\nstatic void callReplyNull(void *ctx, const char *proto, size_t proto_len) {\n    CallReply *rep = ctx;\n    callReplySetSharedData(rep, REDISMODULE_REPLY_NULL, proto, proto_len, REPLY_FLAG_RESP3);\n}\n```\n\n### parseBulk 解析\n\n协议为 `$` 开头的数据，并解析出 2字节的长度信息以及实际的内容，如果长度为-1，则认为是空数据。与Null相同意思。\n\n```\nstatic int parseBulk(ReplyParser *parser, void *p_ctx) {\n    const char *proto = parser->curr_location;\n    char *p = strchr(proto+1,'\\r');\n    long long bulklen;\n    parser->curr_location = p + 2; /* for \\r\\n */\n\n    string2ll(proto+1,p-proto-1,&bulklen);\n    if (bulklen == -1) {\n        parser->callbacks.null_bulk_string_callback(p_ctx, proto, parser->curr_location - proto);\n    } else {\n        const char *str = parser->curr_location;\n        parser->curr_location += bulklen;\n        parser->curr_location += 2; /* for \\r\\n */\n        parser->callbacks.bulk_string_callback(p_ctx, str, bulklen, proto, parser->curr_location - proto);\n    }\n\n    return C_OK;\n}\n```\n\n### parseError 解析\n\n协议为 `-` 开头的数据，并解析出实际的内容，并直接设置具体内容。\n\n```\nstatic int parseError(ReplyParser *parser, void *p_ctx) {\n    const char *proto = parser->curr_location;\n    char *p = strchr(proto+1,'\\r');\n    parser->curr_location = p + 2; // for \\r\\n\n    parser->callbacks.error_callback(p_ctx, proto+1, p-proto-1, proto, parser->curr_location - proto);\n    return C_OK;\n}\n```\n\n### parseSimpleString 解析\n\n协议为 `-` 开头的数据，并解析出实际的内容，并直接设置具体内容。与Error一样的操作。\n\n```\nstatic int parseSimpleString(ReplyParser *parser, void *p_ctx) {\n    const char *proto = parser->curr_location;\n    char *p = strchr(proto+1,'\\r');\n    parser->curr_location = p + 2; /* for \\r\\n */\n    parser->callbacks.simple_str_callback(p_ctx, proto+1, p-proto-1, proto, parser->curr_location - proto);\n    return C_OK;\n}\n```\n\n### parseLong 解析\n\n协议为 `:` 开头的数据，并解析出 2字节的数据信息。\n\n```\nstatic int parseLong(ReplyParser *parser, void *p_ctx) {\n    const char *proto = parser->curr_location;\n    char *p = strchr(proto+1,'\\r');\n    parser->curr_location = p + 2; /* for \\r\\n */\n    long long val;\n    string2ll(proto+1,p-proto-1,&val);\n    parser->callbacks.long_callback(p_ctx, val, proto, parser->curr_location - proto);\n    return C_OK;\n}\n\nstatic void callReplyLong(void *ctx, long long val, const char *proto, size_t proto_len) {\n    CallReply *rep = ctx;\n    callReplySetSharedData(rep, REDISMODULE_REPLY_INTEGER, proto, proto_len, 0);\n    rep->val.ll = val;\n}\n\n```\n\n### parseArray 解析\n\n协议为 `$` 开头的数据，并解析出 2字节的元素个数信息，并最终调用`callReplyParseCollection` 进行递归解析协议内容。后续会单独讲解解析后的数据如何存放。\n\n```\nstatic int parseArray(ReplyParser *parser, void *p_ctx) {\n    const char *proto = parser->curr_location;\n    char *p = strchr(proto+1,'\\r');\n    long long len;\n    string2ll(proto+1,p-proto-1,&len);\n    p += 2;\n    parser->curr_location = p;\n    if (len == -1) {\n        parser->callbacks.null_array_callback(p_ctx, proto, parser->curr_location - proto);\n    } else {\n        parser->callbacks.array_callback(parser, p_ctx, len, proto);\n    }\n    return C_OK;\n}\n\nstatic void callReplyArray(ReplyParser *parser, void *ctx, size_t len, const char *proto) {\n    CallReply *rep = ctx;\n    rep->type = REDISMODULE_REPLY_ARRAY;\n    callReplyParseCollection(parser, rep, len, proto, 1);\n}\n```\n\n### parseSet 解析\n\n协议为 `~` 开头的数据，并解析出 2字节的元素个数信息，并最终调用`callReplyParseCollection` 进行递归解析协议内容。由此可见，Set和Array内容基本上相似。\n\n```\nstatic int parseSet(ReplyParser *parser, void *p_ctx) {\n    const char *proto = parser->curr_location;\n    char *p = strchr(proto+1,'\\r');\n    long long len;\n    string2ll(proto+1,p-proto-1,&len);\n    p += 2;\n    parser->curr_location = p;\n    parser->callbacks.set_callback(parser, p_ctx, len, proto);\n    return C_OK;\n}\n\nstatic void callReplySet(ReplyParser *parser, void *ctx, size_t len, const char *proto) {\n    CallReply *rep = ctx;\n    rep->type = REDISMODULE_REPLY_SET;\n    callReplyParseCollection(parser, rep, len, proto, 1);\n    rep->flags |= REPLY_FLAG_RESP3;\n}\n```\n\n### parseMap 解析\n\n协议为 `%` 开头的数据，并解析出 2字节的元素个数信息，并最终调用`callReplyParseCollection` 进行递归解析协议内容。由此可见，Set、Array、Map内容基本上相似。\n\n```\nstatic int parseMap(ReplyParser *parser, void *p_ctx) {\n    const char *proto = parser->curr_location;\n    char *p = strchr(proto+1,'\\r');\n    long long len;\n    string2ll(proto+1,p-proto-1,&len);\n    p += 2;\n    parser->curr_location = p;\n    parser->callbacks.map_callback(parser, p_ctx, len, proto);\n    return C_OK;\n}\n\nstatic void callReplyMap(ReplyParser *parser, void *ctx, size_t len, const char *proto) {\n    CallReply *rep = ctx;\n    rep->type = REDISMODULE_REPLY_MAP;\n    callReplyParseCollection(parser, rep, len, proto, 2);\n    rep->flags |= REPLY_FLAG_RESP3;\n}\n\n```\n\n\n### parseDouble 解析\n\n协议为 `,` 开头的数据，并解析出全量数据，并以此复制到buffer中，并进行转换，其中最大的空间为：`5*1024`。\n\n```\nstatic int parseDouble(ReplyParser *parser, void *p_ctx) {\n    const char *proto = parser->curr_location;\n    char *p = strchr(proto+1,'\\r');\n    parser->curr_location = p + 2; /* for \\r\\n */\n    char buf[MAX_LONG_DOUBLE_CHARS+1];\n    size_t len = p-proto-1;\n    double d;\n    if (len <= MAX_LONG_DOUBLE_CHARS) {\n        memcpy(buf,proto+1,len);\n        buf[len] = '\\0';\n        d = strtod(buf,NULL); /* We expect a valid representation. */\n    } else {\n        d = 0;\n    }\n    parser->callbacks.double_callback(p_ctx, d, proto, parser->curr_location - proto);\n    return C_OK;\n}\n\n```\n\n\n### parseBool 解析\n\n协议为 `#` 开头的数据，并解析一个字节：`t` 或者 `f`，来区分bool的数值。\n\n```\nstatic int parseBool(ReplyParser *parser, void *p_ctx) {\n    const char *proto = parser->curr_location;\n    char *p = strchr(proto+1,'\\r');\n    parser->curr_location = p + 2; /* for \\r\\n */\n    parser->callbacks.bool_callback(p_ctx, proto[1] == 't', proto, parser->curr_location - proto);\n    return C_OK;\n}\n\nstatic void callReplyBool(void *ctx, int val, const char *proto, size_t proto_len) {\n    CallReply *rep = ctx;\n    callReplySetSharedData(rep, REDISMODULE_REPLY_BOOL, proto, proto_len, REPLY_FLAG_RESP3);\n    rep->val.ll = val;\n}\n```\n\n### parseBigNumber 解析\n\n协议为 `(` 开头的数据，并解析出全量数据，并以此复制到buffer中，最终的表现形式还是为字符串。\n\n```\nstatic int parseBigNumber(ReplyParser *parser, void *p_ctx) {\n    const char *proto = parser->curr_location;\n    char *p = strchr(proto+1,'\\r');\n    parser->curr_location = p + 2; /* for \\r\\n */\n    parser->callbacks.big_number_callback(p_ctx, proto+1, p-proto-1, proto, parser->curr_location - proto);\n    return C_OK;\n}\n\nstatic void callReplyBigNumber(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len) {\n    CallReply *rep = ctx;\n    callReplySetSharedData(rep, REDISMODULE_REPLY_BIG_NUMBER, proto, proto_len, REPLY_FLAG_RESP3);\n    rep->len = len;\n    rep->val.str = str;\n}\n```\n\n### parseAttributes 解析\n\n协议为 `|` 开头的数据，并解析出 2字节的元素个数信息，并最终调用`callReplyParseCollection` 进行递归解析协议内容，解析后，会再次调用 `parseReply` 单独解析内容。\n\n```\nstatic int parseAttributes(ReplyParser *parser, void *p_ctx) {\n    const char *proto = parser->curr_location;\n    char *p = strchr(proto+1,'\\r');\n    long long len;\n    string2ll(proto+1,p-proto-1,&len);\n    p += 2;\n    parser->curr_location = p;\n    parser->callbacks.attribute_callback(parser, p_ctx, len, proto);\n    return C_OK;\n}\n\nstatic void callReplyAttribute(ReplyParser *parser, void *ctx, size_t len, const char *proto) {\n    CallReply *rep = ctx;\n    rep->attribute = zcalloc(sizeof(CallReply));\n\n    /* Continue parsing the attribute reply */\n    rep->attribute->len = len;\n    rep->attribute->type = REDISMODULE_REPLY_ATTRIBUTE;\n    callReplyParseCollection(parser, rep->attribute, len, proto, 2);\n    rep->attribute->flags |= REPLY_FLAG_PARSED | REPLY_FLAG_RESP3;\n    rep->attribute->private_data = rep->private_data;\n\n    /* Continue parsing the reply */\n    parseReply(parser, rep);\n\n    /* In this case we need to fix the proto address and len, it should start from the attribute */\n    rep->proto = proto;\n    rep->proto_len = parser->curr_location - proto;\n    rep->flags |= REPLY_FLAG_RESP3;\n}\n\n```\n\n### parseVerbatimString 解析\n\n协议为 `=` 开头的数据，并解析出2字节的长度后，由会取出4个字节作为format信息，最终剩余的空间为二进制安全字符串。\n\n```\nstatic int parseVerbatimString(ReplyParser *parser, void *p_ctx) {\n    const char *proto = parser->curr_location;\n    char *p = strchr(proto+1,'\\r');\n    long long bulklen;\n    parser->curr_location = p + 2; /* for \\r\\n */\n    string2ll(proto+1,p-proto-1,&bulklen);\n    const char *format = parser->curr_location;\n    parser->curr_location += bulklen;\n    parser->curr_location += 2; /* for \\r\\n */\n    parser->callbacks.verbatim_string_callback(p_ctx, format, format + 4, bulklen - 4, proto, parser->curr_location - proto);\n    return C_OK;\n}\n\nstatic void callReplyVerbatimString(void *ctx, const char *format, const char *str, size_t len, const char *proto, size_t proto_len) {\n    CallReply *rep = ctx;\n    callReplySetSharedData(rep, REDISMODULE_REPLY_VERBATIM_STRING, proto, proto_len, REPLY_FLAG_RESP3);\n    rep->len = len;\n    rep->val.verbatim_str.str = str;\n    rep->val.verbatim_str.format = format;\n}\n```\n\n\n\n## 特殊源码\n\n### 协议结构\n\n单独来了解一下默认协议的表示结构体：\n\n```\nstruct CallReply {\n    void *private_data;\n    sds original_proto; /* Available only for root reply. */\n    const char *proto;\n    size_t proto_len;\n    int type;       /* REPLY_... */\n    int flags;      /* REPLY_FLAG... */\n    size_t len;     /* Length of a string, or the number elements in an array. */\n    union {\n        const char *str; /* String pointer for string and error replies. This\n                          * does not need to be freed, always points inside\n                          * a reply->proto buffer of the reply object or, in\n                          * case of array elements, of parent reply objects. */\n        struct {\n            const char *str;\n            const char *format;\n        } verbatim_str;  /* Reply value for verbatim string */\n        long long ll;    /* Reply value for integer reply. */\n        double d;        /* Reply value for double reply. */\n        struct CallReply *array; /* Array of sub-reply elements. used for set, array, map, and attribute */\n    } val;\n    list *deferred_error_list;   /* list of errors in sds form or NULL */\n    struct CallReply *attribute; /* attribute reply, NULL if not exists */\n};\n```\n\n大体可以分为三块内容：\n1. 协议信息\n2. 数据部分\n3. 析构处理\n\n#### 协议信息\n\n```\n    void *private_data;\n    sds original_proto; /* Available only for root reply. */\n    const char *proto;\n    size_t proto_len;\n    int type;       /* REPLY_... */\n    int flags;      /* REPLY_FLAG... */\n    size_t len;     /* Length of a string, or the number elements in an array. */\n```\n\n从上到下分别为：特殊透传数据、reply根地址、reply当前解析地址、reply长度、当前协议类型、当前的标记位。\n\n#### 数据部分\n\n```\n    size_t len;     /* Length of a string, or the number elements in an array. */\n    union {\n        const char *str; /* String pointer for string and error replies. This\n                          * does not need to be freed, always points inside\n                          * a reply->proto buffer of the reply object or, in\n                          * case of array elements, of parent reply objects. */\n        struct {\n            const char *str;\n            const char *format;\n        } verbatim_str;  /* Reply value for verbatim string */\n        long long ll;    /* Reply value for integer reply. */\n        double d;        /* Reply value for double reply. */\n        struct CallReply *array; /* Array of sub-reply elements. used for set, array, map, and attribute */\n    } val;\n\t   struct CallReply *attribute; /* attribute reply, NULL if not exists */\n```\n\n整体通过一个union属性来包裹了value信息，其中有string、verbatim_str、number、double、array类型，同时这部分还有一个len代表元素的长度信息。\n\n其中，我们将 `attribute` 也做为数据部分看待，因为，它也可以表示实际的信息。\n\n### 析构处理\n\n```\n    list *deferred_error_list;   /* list of errors in sds form or NULL */\n```\n\n这块的逻辑主要是在于完成解析后，数据的释放流程：\n\n```\nvoid freeCallReply(CallReply *rep) {\n    if (!(rep->flags & REPLY_FLAG_ROOT)) {\n        return;\n    }\n    if (rep->flags & REPLY_FLAG_PARSED) {\n        freeCallReplyInternal(rep);\n    }\n    sdsfree(rep->original_proto);\n    if (rep->deferred_error_list)\n        listRelease(rep->deferred_error_list);\n    zfree(rep);\n}\n```\n\n### 递归逻辑\n\n本节单独解析 `callReplyParseCollection` 方法，源码如下：\n\n```\nstatic void callReplyParseCollection(ReplyParser *parser, CallReply *rep, size_t len, const char *proto, size_t elements_per_entry) {\n    rep->len = len;\n    rep->val.array = zcalloc(elements_per_entry * len * sizeof(CallReply));\n    for (size_t i = 0; i < len * elements_per_entry; i += elements_per_entry) {\n        for (size_t j = 0 ; j < elements_per_entry ; ++j) {\n            rep->val.array[i + j].private_data = rep->private_data;\n            parseReply(parser, rep->val.array + i + j);\n            rep->val.array[i + j].flags |= REPLY_FLAG_PARSED;\n            if (rep->val.array[i + j].flags & REPLY_FLAG_RESP3) {\n                /* If one of the sub-replies is RESP3, then the current reply is also RESP3. */\n                rep->flags |= REPLY_FLAG_RESP3;\n            }\n        }\n    }\n    rep->proto = proto;\n    rep->proto_len = parser->curr_location - proto;\n}\n```\n\n其中有趣的点在于，为了支持Map和Array的操作，增加了len和elements_per_entry变量。前者表示元素个数，后者则代表，每个元素中，存在多少个数据。例如Map每个元素存在key和value俩类数据，而Array只存在Value。这么设计最终完成了Map和Array的统一，以及更好的支持了Map本身递归表示的能力。","slug":"Redis新协议-RESP3","published":1,"updated":"2023-01-08T15:45:29.672Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clf3c2gcv00074cuq4vxl57qu","content":"<p>在新的Redis中，由于存在一些Lua、Function、Module等插件类功能，其中需要依赖基础的call方法来调用原生方法，此时就需要对实际命令调用后结果进行解析。这也引入了对协议解析的抽象层。</p>\n<h2 id=\"关于协议\"><a href=\"#关于协议\" class=\"headerlink\" title=\"关于协议\"></a>关于协议</h2><p>新的Resp3协议引入了很多概念，包括了Map、BigNumber、Set等，为了更好的了解协议情况，直接贴出解析入口方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* Parse a reply pointed to by parser-&gt;curr_location. */</span><br><span class=\"line\">int parseReply(ReplyParser *parser, void *p_ctx) &#123;</span><br><span class=\"line\">    switch (parser-&gt;curr_location[0]) &#123;</span><br><span class=\"line\">        case &#x27;$&#x27;: return parseBulk(parser, p_ctx);</span><br><span class=\"line\">        case &#x27;+&#x27;: return parseSimpleString(parser, p_ctx);</span><br><span class=\"line\">        case &#x27;-&#x27;: return parseError(parser, p_ctx);</span><br><span class=\"line\">        case &#x27;:&#x27;: return parseLong(parser, p_ctx);</span><br><span class=\"line\">        case &#x27;*&#x27;: return parseArray(parser, p_ctx);</span><br><span class=\"line\">        case &#x27;~&#x27;: return parseSet(parser, p_ctx);</span><br><span class=\"line\">        case &#x27;%&#x27;: return parseMap(parser, p_ctx);</span><br><span class=\"line\">        case &#x27;#&#x27;: return parseBool(parser, p_ctx);</span><br><span class=\"line\">        case &#x27;,&#x27;: return parseDouble(parser, p_ctx);</span><br><span class=\"line\">        case &#x27;_&#x27;: return parseNull(parser, p_ctx);</span><br><span class=\"line\">        case &#x27;(&#x27;: return parseBigNumber(parser, p_ctx);</span><br><span class=\"line\">        case &#x27;=&#x27;: return parseVerbatimString(parser, p_ctx);</span><br><span class=\"line\">        case &#x27;|&#x27;: return parseAttributes(parser, p_ctx);</span><br><span class=\"line\">        default: if (parser-&gt;callbacks.error) parser-&gt;callbacks.error(p_ctx);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return C_ERR;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>由此可见，此处有13个协议标记，单独予以归类：</p>\n<ul>\n<li>简单类型：<code>+</code>、<code>-</code>、<code>:</code>、<code>#</code>、<code>,</code>、<code>(</code>、<code>=</code>、<code>_</code></li>\n<li>复杂类型：<code>$</code>、<code>*</code>、<code>~</code>、<code>%</code>、<code>|</code></li>\n</ul>\n<p>为了统一进行解析，此处对协议解析进行了抽象：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static const ReplyParserCallbacks DefaultParserCallbacks = &#123;</span><br><span class=\"line\">    .null_callback = callReplyNull,</span><br><span class=\"line\">    .bulk_string_callback = callReplyBulkString,</span><br><span class=\"line\">    .null_bulk_string_callback = callReplyNullBulkString,</span><br><span class=\"line\">    .null_array_callback = callReplyNullArray,</span><br><span class=\"line\">    .error_callback = callReplyError,</span><br><span class=\"line\">    .simple_str_callback = callReplySimpleStr,</span><br><span class=\"line\">    .long_callback = callReplyLong,</span><br><span class=\"line\">    .array_callback = callReplyArray,</span><br><span class=\"line\">    .set_callback = callReplySet,</span><br><span class=\"line\">    .map_callback = callReplyMap,</span><br><span class=\"line\">    .double_callback = callReplyDouble,</span><br><span class=\"line\">    .bool_callback = callReplyBool,</span><br><span class=\"line\">    .big_number_callback = callReplyBigNumber,</span><br><span class=\"line\">    .verbatim_string_callback = callReplyVerbatimString,</span><br><span class=\"line\">    .attribute_callback = callReplyAttribute,</span><br><span class=\"line\">    .error = callReplyParseError,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>实际的场景主要在于Module需要解析协议进行处理，以及Lua需要将协议转换为lua数据并执行。<br>从最初的代码中，可以看到解析主要依赖俩块数据：<code>parser</code>、<code>ctx</code>，前者代码解析时回调，而后者主要是解析时传入的上下文信息。</p>\n<h2 id=\"协议内容\"><a href=\"#协议内容\" class=\"headerlink\" title=\"协议内容\"></a>协议内容</h2><p>此处，针对不同类型的默认解析器进行讲解，方便后续理解</p>\n<h3 id=\"parseNull-解析\"><a href=\"#parseNull-解析\" class=\"headerlink\" title=\"parseNull 解析\"></a>parseNull 解析</h3><p>协议为 <code>_</code> 数据，解析直接赋值相关类型以及长度，占用空间为3字节。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int parseNull(ReplyParser *parser, void *p_ctx) &#123;</span><br><span class=\"line\">    const char *proto = parser-&gt;curr_location;</span><br><span class=\"line\">    char *p = strchr(proto+1,&#x27;\\r&#x27;);</span><br><span class=\"line\">    parser-&gt;curr_location = p + 2; /* for \\r\\n */</span><br><span class=\"line\">    parser-&gt;callbacks.null_callback(p_ctx, proto, parser-&gt;curr_location - proto);</span><br><span class=\"line\">    return C_OK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static void callReplyNull(void *ctx, const char *proto, size_t proto_len) &#123;</span><br><span class=\"line\">    CallReply *rep = ctx;</span><br><span class=\"line\">    callReplySetSharedData(rep, REDISMODULE_REPLY_NULL, proto, proto_len, REPLY_FLAG_RESP3);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"parseBulk-解析\"><a href=\"#parseBulk-解析\" class=\"headerlink\" title=\"parseBulk 解析\"></a>parseBulk 解析</h3><p>协议为 <code>$</code> 开头的数据，并解析出 2字节的长度信息以及实际的内容，如果长度为-1，则认为是空数据。与Null相同意思。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int parseBulk(ReplyParser *parser, void *p_ctx) &#123;</span><br><span class=\"line\">    const char *proto = parser-&gt;curr_location;</span><br><span class=\"line\">    char *p = strchr(proto+1,&#x27;\\r&#x27;);</span><br><span class=\"line\">    long long bulklen;</span><br><span class=\"line\">    parser-&gt;curr_location = p + 2; /* for \\r\\n */</span><br><span class=\"line\"></span><br><span class=\"line\">    string2ll(proto+1,p-proto-1,&amp;bulklen);</span><br><span class=\"line\">    if (bulklen == -1) &#123;</span><br><span class=\"line\">        parser-&gt;callbacks.null_bulk_string_callback(p_ctx, proto, parser-&gt;curr_location - proto);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        const char *str = parser-&gt;curr_location;</span><br><span class=\"line\">        parser-&gt;curr_location += bulklen;</span><br><span class=\"line\">        parser-&gt;curr_location += 2; /* for \\r\\n */</span><br><span class=\"line\">        parser-&gt;callbacks.bulk_string_callback(p_ctx, str, bulklen, proto, parser-&gt;curr_location - proto);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return C_OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"parseError-解析\"><a href=\"#parseError-解析\" class=\"headerlink\" title=\"parseError 解析\"></a>parseError 解析</h3><p>协议为 <code>-</code> 开头的数据，并解析出实际的内容，并直接设置具体内容。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int parseError(ReplyParser *parser, void *p_ctx) &#123;</span><br><span class=\"line\">    const char *proto = parser-&gt;curr_location;</span><br><span class=\"line\">    char *p = strchr(proto+1,&#x27;\\r&#x27;);</span><br><span class=\"line\">    parser-&gt;curr_location = p + 2; // for \\r\\n</span><br><span class=\"line\">    parser-&gt;callbacks.error_callback(p_ctx, proto+1, p-proto-1, proto, parser-&gt;curr_location - proto);</span><br><span class=\"line\">    return C_OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"parseSimpleString-解析\"><a href=\"#parseSimpleString-解析\" class=\"headerlink\" title=\"parseSimpleString 解析\"></a>parseSimpleString 解析</h3><p>协议为 <code>-</code> 开头的数据，并解析出实际的内容，并直接设置具体内容。与Error一样的操作。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int parseSimpleString(ReplyParser *parser, void *p_ctx) &#123;</span><br><span class=\"line\">    const char *proto = parser-&gt;curr_location;</span><br><span class=\"line\">    char *p = strchr(proto+1,&#x27;\\r&#x27;);</span><br><span class=\"line\">    parser-&gt;curr_location = p + 2; /* for \\r\\n */</span><br><span class=\"line\">    parser-&gt;callbacks.simple_str_callback(p_ctx, proto+1, p-proto-1, proto, parser-&gt;curr_location - proto);</span><br><span class=\"line\">    return C_OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"parseLong-解析\"><a href=\"#parseLong-解析\" class=\"headerlink\" title=\"parseLong 解析\"></a>parseLong 解析</h3><p>协议为 <code>:</code> 开头的数据，并解析出 2字节的数据信息。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int parseLong(ReplyParser *parser, void *p_ctx) &#123;</span><br><span class=\"line\">    const char *proto = parser-&gt;curr_location;</span><br><span class=\"line\">    char *p = strchr(proto+1,&#x27;\\r&#x27;);</span><br><span class=\"line\">    parser-&gt;curr_location = p + 2; /* for \\r\\n */</span><br><span class=\"line\">    long long val;</span><br><span class=\"line\">    string2ll(proto+1,p-proto-1,&amp;val);</span><br><span class=\"line\">    parser-&gt;callbacks.long_callback(p_ctx, val, proto, parser-&gt;curr_location - proto);</span><br><span class=\"line\">    return C_OK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static void callReplyLong(void *ctx, long long val, const char *proto, size_t proto_len) &#123;</span><br><span class=\"line\">    CallReply *rep = ctx;</span><br><span class=\"line\">    callReplySetSharedData(rep, REDISMODULE_REPLY_INTEGER, proto, proto_len, 0);</span><br><span class=\"line\">    rep-&gt;val.ll = val;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"parseArray-解析\"><a href=\"#parseArray-解析\" class=\"headerlink\" title=\"parseArray 解析\"></a>parseArray 解析</h3><p>协议为 <code>$</code> 开头的数据，并解析出 2字节的元素个数信息，并最终调用<code>callReplyParseCollection</code> 进行递归解析协议内容。后续会单独讲解解析后的数据如何存放。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int parseArray(ReplyParser *parser, void *p_ctx) &#123;</span><br><span class=\"line\">    const char *proto = parser-&gt;curr_location;</span><br><span class=\"line\">    char *p = strchr(proto+1,&#x27;\\r&#x27;);</span><br><span class=\"line\">    long long len;</span><br><span class=\"line\">    string2ll(proto+1,p-proto-1,&amp;len);</span><br><span class=\"line\">    p += 2;</span><br><span class=\"line\">    parser-&gt;curr_location = p;</span><br><span class=\"line\">    if (len == -1) &#123;</span><br><span class=\"line\">        parser-&gt;callbacks.null_array_callback(p_ctx, proto, parser-&gt;curr_location - proto);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        parser-&gt;callbacks.array_callback(parser, p_ctx, len, proto);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return C_OK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static void callReplyArray(ReplyParser *parser, void *ctx, size_t len, const char *proto) &#123;</span><br><span class=\"line\">    CallReply *rep = ctx;</span><br><span class=\"line\">    rep-&gt;type = REDISMODULE_REPLY_ARRAY;</span><br><span class=\"line\">    callReplyParseCollection(parser, rep, len, proto, 1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"parseSet-解析\"><a href=\"#parseSet-解析\" class=\"headerlink\" title=\"parseSet 解析\"></a>parseSet 解析</h3><p>协议为 <code>~</code> 开头的数据，并解析出 2字节的元素个数信息，并最终调用<code>callReplyParseCollection</code> 进行递归解析协议内容。由此可见，Set和Array内容基本上相似。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int parseSet(ReplyParser *parser, void *p_ctx) &#123;</span><br><span class=\"line\">    const char *proto = parser-&gt;curr_location;</span><br><span class=\"line\">    char *p = strchr(proto+1,&#x27;\\r&#x27;);</span><br><span class=\"line\">    long long len;</span><br><span class=\"line\">    string2ll(proto+1,p-proto-1,&amp;len);</span><br><span class=\"line\">    p += 2;</span><br><span class=\"line\">    parser-&gt;curr_location = p;</span><br><span class=\"line\">    parser-&gt;callbacks.set_callback(parser, p_ctx, len, proto);</span><br><span class=\"line\">    return C_OK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static void callReplySet(ReplyParser *parser, void *ctx, size_t len, const char *proto) &#123;</span><br><span class=\"line\">    CallReply *rep = ctx;</span><br><span class=\"line\">    rep-&gt;type = REDISMODULE_REPLY_SET;</span><br><span class=\"line\">    callReplyParseCollection(parser, rep, len, proto, 1);</span><br><span class=\"line\">    rep-&gt;flags |= REPLY_FLAG_RESP3;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"parseMap-解析\"><a href=\"#parseMap-解析\" class=\"headerlink\" title=\"parseMap 解析\"></a>parseMap 解析</h3><p>协议为 <code>%</code> 开头的数据，并解析出 2字节的元素个数信息，并最终调用<code>callReplyParseCollection</code> 进行递归解析协议内容。由此可见，Set、Array、Map内容基本上相似。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int parseMap(ReplyParser *parser, void *p_ctx) &#123;</span><br><span class=\"line\">    const char *proto = parser-&gt;curr_location;</span><br><span class=\"line\">    char *p = strchr(proto+1,&#x27;\\r&#x27;);</span><br><span class=\"line\">    long long len;</span><br><span class=\"line\">    string2ll(proto+1,p-proto-1,&amp;len);</span><br><span class=\"line\">    p += 2;</span><br><span class=\"line\">    parser-&gt;curr_location = p;</span><br><span class=\"line\">    parser-&gt;callbacks.map_callback(parser, p_ctx, len, proto);</span><br><span class=\"line\">    return C_OK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static void callReplyMap(ReplyParser *parser, void *ctx, size_t len, const char *proto) &#123;</span><br><span class=\"line\">    CallReply *rep = ctx;</span><br><span class=\"line\">    rep-&gt;type = REDISMODULE_REPLY_MAP;</span><br><span class=\"line\">    callReplyParseCollection(parser, rep, len, proto, 2);</span><br><span class=\"line\">    rep-&gt;flags |= REPLY_FLAG_RESP3;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"parseDouble-解析\"><a href=\"#parseDouble-解析\" class=\"headerlink\" title=\"parseDouble 解析\"></a>parseDouble 解析</h3><p>协议为 <code>,</code> 开头的数据，并解析出全量数据，并以此复制到buffer中，并进行转换，其中最大的空间为：<code>5*1024</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int parseDouble(ReplyParser *parser, void *p_ctx) &#123;</span><br><span class=\"line\">    const char *proto = parser-&gt;curr_location;</span><br><span class=\"line\">    char *p = strchr(proto+1,&#x27;\\r&#x27;);</span><br><span class=\"line\">    parser-&gt;curr_location = p + 2; /* for \\r\\n */</span><br><span class=\"line\">    char buf[MAX_LONG_DOUBLE_CHARS+1];</span><br><span class=\"line\">    size_t len = p-proto-1;</span><br><span class=\"line\">    double d;</span><br><span class=\"line\">    if (len &lt;= MAX_LONG_DOUBLE_CHARS) &#123;</span><br><span class=\"line\">        memcpy(buf,proto+1,len);</span><br><span class=\"line\">        buf[len] = &#x27;\\0&#x27;;</span><br><span class=\"line\">        d = strtod(buf,NULL); /* We expect a valid representation. */</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        d = 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    parser-&gt;callbacks.double_callback(p_ctx, d, proto, parser-&gt;curr_location - proto);</span><br><span class=\"line\">    return C_OK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"parseBool-解析\"><a href=\"#parseBool-解析\" class=\"headerlink\" title=\"parseBool 解析\"></a>parseBool 解析</h3><p>协议为 <code>#</code> 开头的数据，并解析一个字节：<code>t</code> 或者 <code>f</code>，来区分bool的数值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int parseBool(ReplyParser *parser, void *p_ctx) &#123;</span><br><span class=\"line\">    const char *proto = parser-&gt;curr_location;</span><br><span class=\"line\">    char *p = strchr(proto+1,&#x27;\\r&#x27;);</span><br><span class=\"line\">    parser-&gt;curr_location = p + 2; /* for \\r\\n */</span><br><span class=\"line\">    parser-&gt;callbacks.bool_callback(p_ctx, proto[1] == &#x27;t&#x27;, proto, parser-&gt;curr_location - proto);</span><br><span class=\"line\">    return C_OK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static void callReplyBool(void *ctx, int val, const char *proto, size_t proto_len) &#123;</span><br><span class=\"line\">    CallReply *rep = ctx;</span><br><span class=\"line\">    callReplySetSharedData(rep, REDISMODULE_REPLY_BOOL, proto, proto_len, REPLY_FLAG_RESP3);</span><br><span class=\"line\">    rep-&gt;val.ll = val;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"parseBigNumber-解析\"><a href=\"#parseBigNumber-解析\" class=\"headerlink\" title=\"parseBigNumber 解析\"></a>parseBigNumber 解析</h3><p>协议为 <code>(</code> 开头的数据，并解析出全量数据，并以此复制到buffer中，最终的表现形式还是为字符串。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int parseBigNumber(ReplyParser *parser, void *p_ctx) &#123;</span><br><span class=\"line\">    const char *proto = parser-&gt;curr_location;</span><br><span class=\"line\">    char *p = strchr(proto+1,&#x27;\\r&#x27;);</span><br><span class=\"line\">    parser-&gt;curr_location = p + 2; /* for \\r\\n */</span><br><span class=\"line\">    parser-&gt;callbacks.big_number_callback(p_ctx, proto+1, p-proto-1, proto, parser-&gt;curr_location - proto);</span><br><span class=\"line\">    return C_OK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static void callReplyBigNumber(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len) &#123;</span><br><span class=\"line\">    CallReply *rep = ctx;</span><br><span class=\"line\">    callReplySetSharedData(rep, REDISMODULE_REPLY_BIG_NUMBER, proto, proto_len, REPLY_FLAG_RESP3);</span><br><span class=\"line\">    rep-&gt;len = len;</span><br><span class=\"line\">    rep-&gt;val.str = str;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"parseAttributes-解析\"><a href=\"#parseAttributes-解析\" class=\"headerlink\" title=\"parseAttributes 解析\"></a>parseAttributes 解析</h3><p>协议为 <code>|</code> 开头的数据，并解析出 2字节的元素个数信息，并最终调用<code>callReplyParseCollection</code> 进行递归解析协议内容，解析后，会再次调用 <code>parseReply</code> 单独解析内容。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int parseAttributes(ReplyParser *parser, void *p_ctx) &#123;</span><br><span class=\"line\">    const char *proto = parser-&gt;curr_location;</span><br><span class=\"line\">    char *p = strchr(proto+1,&#x27;\\r&#x27;);</span><br><span class=\"line\">    long long len;</span><br><span class=\"line\">    string2ll(proto+1,p-proto-1,&amp;len);</span><br><span class=\"line\">    p += 2;</span><br><span class=\"line\">    parser-&gt;curr_location = p;</span><br><span class=\"line\">    parser-&gt;callbacks.attribute_callback(parser, p_ctx, len, proto);</span><br><span class=\"line\">    return C_OK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static void callReplyAttribute(ReplyParser *parser, void *ctx, size_t len, const char *proto) &#123;</span><br><span class=\"line\">    CallReply *rep = ctx;</span><br><span class=\"line\">    rep-&gt;attribute = zcalloc(sizeof(CallReply));</span><br><span class=\"line\"></span><br><span class=\"line\">    /* Continue parsing the attribute reply */</span><br><span class=\"line\">    rep-&gt;attribute-&gt;len = len;</span><br><span class=\"line\">    rep-&gt;attribute-&gt;type = REDISMODULE_REPLY_ATTRIBUTE;</span><br><span class=\"line\">    callReplyParseCollection(parser, rep-&gt;attribute, len, proto, 2);</span><br><span class=\"line\">    rep-&gt;attribute-&gt;flags |= REPLY_FLAG_PARSED | REPLY_FLAG_RESP3;</span><br><span class=\"line\">    rep-&gt;attribute-&gt;private_data = rep-&gt;private_data;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* Continue parsing the reply */</span><br><span class=\"line\">    parseReply(parser, rep);</span><br><span class=\"line\"></span><br><span class=\"line\">    /* In this case we need to fix the proto address and len, it should start from the attribute */</span><br><span class=\"line\">    rep-&gt;proto = proto;</span><br><span class=\"line\">    rep-&gt;proto_len = parser-&gt;curr_location - proto;</span><br><span class=\"line\">    rep-&gt;flags |= REPLY_FLAG_RESP3;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"parseVerbatimString-解析\"><a href=\"#parseVerbatimString-解析\" class=\"headerlink\" title=\"parseVerbatimString 解析\"></a>parseVerbatimString 解析</h3><p>协议为 <code>=</code> 开头的数据，并解析出2字节的长度后，由会取出4个字节作为format信息，最终剩余的空间为二进制安全字符串。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int parseVerbatimString(ReplyParser *parser, void *p_ctx) &#123;</span><br><span class=\"line\">    const char *proto = parser-&gt;curr_location;</span><br><span class=\"line\">    char *p = strchr(proto+1,&#x27;\\r&#x27;);</span><br><span class=\"line\">    long long bulklen;</span><br><span class=\"line\">    parser-&gt;curr_location = p + 2; /* for \\r\\n */</span><br><span class=\"line\">    string2ll(proto+1,p-proto-1,&amp;bulklen);</span><br><span class=\"line\">    const char *format = parser-&gt;curr_location;</span><br><span class=\"line\">    parser-&gt;curr_location += bulklen;</span><br><span class=\"line\">    parser-&gt;curr_location += 2; /* for \\r\\n */</span><br><span class=\"line\">    parser-&gt;callbacks.verbatim_string_callback(p_ctx, format, format + 4, bulklen - 4, proto, parser-&gt;curr_location - proto);</span><br><span class=\"line\">    return C_OK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static void callReplyVerbatimString(void *ctx, const char *format, const char *str, size_t len, const char *proto, size_t proto_len) &#123;</span><br><span class=\"line\">    CallReply *rep = ctx;</span><br><span class=\"line\">    callReplySetSharedData(rep, REDISMODULE_REPLY_VERBATIM_STRING, proto, proto_len, REPLY_FLAG_RESP3);</span><br><span class=\"line\">    rep-&gt;len = len;</span><br><span class=\"line\">    rep-&gt;val.verbatim_str.str = str;</span><br><span class=\"line\">    rep-&gt;val.verbatim_str.format = format;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"特殊源码\"><a href=\"#特殊源码\" class=\"headerlink\" title=\"特殊源码\"></a>特殊源码</h2><h3 id=\"协议结构\"><a href=\"#协议结构\" class=\"headerlink\" title=\"协议结构\"></a>协议结构</h3><p>单独来了解一下默认协议的表示结构体：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct CallReply &#123;</span><br><span class=\"line\">    void *private_data;</span><br><span class=\"line\">    sds original_proto; /* Available only for root reply. */</span><br><span class=\"line\">    const char *proto;</span><br><span class=\"line\">    size_t proto_len;</span><br><span class=\"line\">    int type;       /* REPLY_... */</span><br><span class=\"line\">    int flags;      /* REPLY_FLAG... */</span><br><span class=\"line\">    size_t len;     /* Length of a string, or the number elements in an array. */</span><br><span class=\"line\">    union &#123;</span><br><span class=\"line\">        const char *str; /* String pointer for string and error replies. This</span><br><span class=\"line\">                          * does not need to be freed, always points inside</span><br><span class=\"line\">                          * a reply-&gt;proto buffer of the reply object or, in</span><br><span class=\"line\">                          * case of array elements, of parent reply objects. */</span><br><span class=\"line\">        struct &#123;</span><br><span class=\"line\">            const char *str;</span><br><span class=\"line\">            const char *format;</span><br><span class=\"line\">        &#125; verbatim_str;  /* Reply value for verbatim string */</span><br><span class=\"line\">        long long ll;    /* Reply value for integer reply. */</span><br><span class=\"line\">        double d;        /* Reply value for double reply. */</span><br><span class=\"line\">        struct CallReply *array; /* Array of sub-reply elements. used for set, array, map, and attribute */</span><br><span class=\"line\">    &#125; val;</span><br><span class=\"line\">    list *deferred_error_list;   /* list of errors in sds form or NULL */</span><br><span class=\"line\">    struct CallReply *attribute; /* attribute reply, NULL if not exists */</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>大体可以分为三块内容：</p>\n<ol>\n<li>协议信息</li>\n<li>数据部分</li>\n<li>析构处理</li>\n</ol>\n<h4 id=\"协议信息\"><a href=\"#协议信息\" class=\"headerlink\" title=\"协议信息\"></a>协议信息</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void *private_data;</span><br><span class=\"line\">sds original_proto; /* Available only for root reply. */</span><br><span class=\"line\">const char *proto;</span><br><span class=\"line\">size_t proto_len;</span><br><span class=\"line\">int type;       /* REPLY_... */</span><br><span class=\"line\">int flags;      /* REPLY_FLAG... */</span><br><span class=\"line\">size_t len;     /* Length of a string, or the number elements in an array. */</span><br></pre></td></tr></table></figure>\n\n<p>从上到下分别为：特殊透传数据、reply根地址、reply当前解析地址、reply长度、当前协议类型、当前的标记位。</p>\n<h4 id=\"数据部分\"><a href=\"#数据部分\" class=\"headerlink\" title=\"数据部分\"></a>数据部分</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">size_t len;     /* Length of a string, or the number elements in an array. */</span><br><span class=\"line\">union &#123;</span><br><span class=\"line\">    const char *str; /* String pointer for string and error replies. This</span><br><span class=\"line\">                      * does not need to be freed, always points inside</span><br><span class=\"line\">                      * a reply-&gt;proto buffer of the reply object or, in</span><br><span class=\"line\">                      * case of array elements, of parent reply objects. */</span><br><span class=\"line\">    struct &#123;</span><br><span class=\"line\">        const char *str;</span><br><span class=\"line\">        const char *format;</span><br><span class=\"line\">    &#125; verbatim_str;  /* Reply value for verbatim string */</span><br><span class=\"line\">    long long ll;    /* Reply value for integer reply. */</span><br><span class=\"line\">    double d;        /* Reply value for double reply. */</span><br><span class=\"line\">    struct CallReply *array; /* Array of sub-reply elements. used for set, array, map, and attribute */</span><br><span class=\"line\">&#125; val;</span><br><span class=\"line\">struct CallReply *attribute; /* attribute reply, NULL if not exists */</span><br></pre></td></tr></table></figure>\n\n<p>整体通过一个union属性来包裹了value信息，其中有string、verbatim_str、number、double、array类型，同时这部分还有一个len代表元素的长度信息。</p>\n<p>其中，我们将 <code>attribute</code> 也做为数据部分看待，因为，它也可以表示实际的信息。</p>\n<h3 id=\"析构处理\"><a href=\"#析构处理\" class=\"headerlink\" title=\"析构处理\"></a>析构处理</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list *deferred_error_list;   /* list of errors in sds form or NULL */</span><br></pre></td></tr></table></figure>\n\n<p>这块的逻辑主要是在于完成解析后，数据的释放流程：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void freeCallReply(CallReply *rep) &#123;</span><br><span class=\"line\">    if (!(rep-&gt;flags &amp; REPLY_FLAG_ROOT)) &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (rep-&gt;flags &amp; REPLY_FLAG_PARSED) &#123;</span><br><span class=\"line\">        freeCallReplyInternal(rep);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sdsfree(rep-&gt;original_proto);</span><br><span class=\"line\">    if (rep-&gt;deferred_error_list)</span><br><span class=\"line\">        listRelease(rep-&gt;deferred_error_list);</span><br><span class=\"line\">    zfree(rep);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"递归逻辑\"><a href=\"#递归逻辑\" class=\"headerlink\" title=\"递归逻辑\"></a>递归逻辑</h3><p>本节单独解析 <code>callReplyParseCollection</code> 方法，源码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void callReplyParseCollection(ReplyParser *parser, CallReply *rep, size_t len, const char *proto, size_t elements_per_entry) &#123;</span><br><span class=\"line\">    rep-&gt;len = len;</span><br><span class=\"line\">    rep-&gt;val.array = zcalloc(elements_per_entry * len * sizeof(CallReply));</span><br><span class=\"line\">    for (size_t i = 0; i &lt; len * elements_per_entry; i += elements_per_entry) &#123;</span><br><span class=\"line\">        for (size_t j = 0 ; j &lt; elements_per_entry ; ++j) &#123;</span><br><span class=\"line\">            rep-&gt;val.array[i + j].private_data = rep-&gt;private_data;</span><br><span class=\"line\">            parseReply(parser, rep-&gt;val.array + i + j);</span><br><span class=\"line\">            rep-&gt;val.array[i + j].flags |= REPLY_FLAG_PARSED;</span><br><span class=\"line\">            if (rep-&gt;val.array[i + j].flags &amp; REPLY_FLAG_RESP3) &#123;</span><br><span class=\"line\">                /* If one of the sub-replies is RESP3, then the current reply is also RESP3. */</span><br><span class=\"line\">                rep-&gt;flags |= REPLY_FLAG_RESP3;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    rep-&gt;proto = proto;</span><br><span class=\"line\">    rep-&gt;proto_len = parser-&gt;curr_location - proto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中有趣的点在于，为了支持Map和Array的操作，增加了len和elements_per_entry变量。前者表示元素个数，后者则代表，每个元素中，存在多少个数据。例如Map每个元素存在key和value俩类数据，而Array只存在Value。这么设计最终完成了Map和Array的统一，以及更好的支持了Map本身递归表示的能力。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在新的Redis中，由于存在一些Lua、Function、Module等插件类功能，其中需要依赖基础的call方法来调用原生方法，此时就需要对实际命令调用后结果进行解析。这也引入了对协议解析的抽象层。</p>\n<h2 id=\"关于协议\"><a href=\"#关于协议\" class=\"headerlink\" title=\"关于协议\"></a>关于协议</h2><p>新的Resp3协议引入了很多概念，包括了Map、BigNumber、Set等，为了更好的了解协议情况，直接贴出解析入口方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* Parse a reply pointed to by parser-&gt;curr_location. */</span><br><span class=\"line\">int parseReply(ReplyParser *parser, void *p_ctx) &#123;</span><br><span class=\"line\">    switch (parser-&gt;curr_location[0]) &#123;</span><br><span class=\"line\">        case &#x27;$&#x27;: return parseBulk(parser, p_ctx);</span><br><span class=\"line\">        case &#x27;+&#x27;: return parseSimpleString(parser, p_ctx);</span><br><span class=\"line\">        case &#x27;-&#x27;: return parseError(parser, p_ctx);</span><br><span class=\"line\">        case &#x27;:&#x27;: return parseLong(parser, p_ctx);</span><br><span class=\"line\">        case &#x27;*&#x27;: return parseArray(parser, p_ctx);</span><br><span class=\"line\">        case &#x27;~&#x27;: return parseSet(parser, p_ctx);</span><br><span class=\"line\">        case &#x27;%&#x27;: return parseMap(parser, p_ctx);</span><br><span class=\"line\">        case &#x27;#&#x27;: return parseBool(parser, p_ctx);</span><br><span class=\"line\">        case &#x27;,&#x27;: return parseDouble(parser, p_ctx);</span><br><span class=\"line\">        case &#x27;_&#x27;: return parseNull(parser, p_ctx);</span><br><span class=\"line\">        case &#x27;(&#x27;: return parseBigNumber(parser, p_ctx);</span><br><span class=\"line\">        case &#x27;=&#x27;: return parseVerbatimString(parser, p_ctx);</span><br><span class=\"line\">        case &#x27;|&#x27;: return parseAttributes(parser, p_ctx);</span><br><span class=\"line\">        default: if (parser-&gt;callbacks.error) parser-&gt;callbacks.error(p_ctx);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return C_ERR;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>由此可见，此处有13个协议标记，单独予以归类：</p>\n<ul>\n<li>简单类型：<code>+</code>、<code>-</code>、<code>:</code>、<code>#</code>、<code>,</code>、<code>(</code>、<code>=</code>、<code>_</code></li>\n<li>复杂类型：<code>$</code>、<code>*</code>、<code>~</code>、<code>%</code>、<code>|</code></li>\n</ul>\n<p>为了统一进行解析，此处对协议解析进行了抽象：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static const ReplyParserCallbacks DefaultParserCallbacks = &#123;</span><br><span class=\"line\">    .null_callback = callReplyNull,</span><br><span class=\"line\">    .bulk_string_callback = callReplyBulkString,</span><br><span class=\"line\">    .null_bulk_string_callback = callReplyNullBulkString,</span><br><span class=\"line\">    .null_array_callback = callReplyNullArray,</span><br><span class=\"line\">    .error_callback = callReplyError,</span><br><span class=\"line\">    .simple_str_callback = callReplySimpleStr,</span><br><span class=\"line\">    .long_callback = callReplyLong,</span><br><span class=\"line\">    .array_callback = callReplyArray,</span><br><span class=\"line\">    .set_callback = callReplySet,</span><br><span class=\"line\">    .map_callback = callReplyMap,</span><br><span class=\"line\">    .double_callback = callReplyDouble,</span><br><span class=\"line\">    .bool_callback = callReplyBool,</span><br><span class=\"line\">    .big_number_callback = callReplyBigNumber,</span><br><span class=\"line\">    .verbatim_string_callback = callReplyVerbatimString,</span><br><span class=\"line\">    .attribute_callback = callReplyAttribute,</span><br><span class=\"line\">    .error = callReplyParseError,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>实际的场景主要在于Module需要解析协议进行处理，以及Lua需要将协议转换为lua数据并执行。<br>从最初的代码中，可以看到解析主要依赖俩块数据：<code>parser</code>、<code>ctx</code>，前者代码解析时回调，而后者主要是解析时传入的上下文信息。</p>\n<h2 id=\"协议内容\"><a href=\"#协议内容\" class=\"headerlink\" title=\"协议内容\"></a>协议内容</h2><p>此处，针对不同类型的默认解析器进行讲解，方便后续理解</p>\n<h3 id=\"parseNull-解析\"><a href=\"#parseNull-解析\" class=\"headerlink\" title=\"parseNull 解析\"></a>parseNull 解析</h3><p>协议为 <code>_</code> 数据，解析直接赋值相关类型以及长度，占用空间为3字节。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int parseNull(ReplyParser *parser, void *p_ctx) &#123;</span><br><span class=\"line\">    const char *proto = parser-&gt;curr_location;</span><br><span class=\"line\">    char *p = strchr(proto+1,&#x27;\\r&#x27;);</span><br><span class=\"line\">    parser-&gt;curr_location = p + 2; /* for \\r\\n */</span><br><span class=\"line\">    parser-&gt;callbacks.null_callback(p_ctx, proto, parser-&gt;curr_location - proto);</span><br><span class=\"line\">    return C_OK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static void callReplyNull(void *ctx, const char *proto, size_t proto_len) &#123;</span><br><span class=\"line\">    CallReply *rep = ctx;</span><br><span class=\"line\">    callReplySetSharedData(rep, REDISMODULE_REPLY_NULL, proto, proto_len, REPLY_FLAG_RESP3);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"parseBulk-解析\"><a href=\"#parseBulk-解析\" class=\"headerlink\" title=\"parseBulk 解析\"></a>parseBulk 解析</h3><p>协议为 <code>$</code> 开头的数据，并解析出 2字节的长度信息以及实际的内容，如果长度为-1，则认为是空数据。与Null相同意思。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int parseBulk(ReplyParser *parser, void *p_ctx) &#123;</span><br><span class=\"line\">    const char *proto = parser-&gt;curr_location;</span><br><span class=\"line\">    char *p = strchr(proto+1,&#x27;\\r&#x27;);</span><br><span class=\"line\">    long long bulklen;</span><br><span class=\"line\">    parser-&gt;curr_location = p + 2; /* for \\r\\n */</span><br><span class=\"line\"></span><br><span class=\"line\">    string2ll(proto+1,p-proto-1,&amp;bulklen);</span><br><span class=\"line\">    if (bulklen == -1) &#123;</span><br><span class=\"line\">        parser-&gt;callbacks.null_bulk_string_callback(p_ctx, proto, parser-&gt;curr_location - proto);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        const char *str = parser-&gt;curr_location;</span><br><span class=\"line\">        parser-&gt;curr_location += bulklen;</span><br><span class=\"line\">        parser-&gt;curr_location += 2; /* for \\r\\n */</span><br><span class=\"line\">        parser-&gt;callbacks.bulk_string_callback(p_ctx, str, bulklen, proto, parser-&gt;curr_location - proto);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return C_OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"parseError-解析\"><a href=\"#parseError-解析\" class=\"headerlink\" title=\"parseError 解析\"></a>parseError 解析</h3><p>协议为 <code>-</code> 开头的数据，并解析出实际的内容，并直接设置具体内容。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int parseError(ReplyParser *parser, void *p_ctx) &#123;</span><br><span class=\"line\">    const char *proto = parser-&gt;curr_location;</span><br><span class=\"line\">    char *p = strchr(proto+1,&#x27;\\r&#x27;);</span><br><span class=\"line\">    parser-&gt;curr_location = p + 2; // for \\r\\n</span><br><span class=\"line\">    parser-&gt;callbacks.error_callback(p_ctx, proto+1, p-proto-1, proto, parser-&gt;curr_location - proto);</span><br><span class=\"line\">    return C_OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"parseSimpleString-解析\"><a href=\"#parseSimpleString-解析\" class=\"headerlink\" title=\"parseSimpleString 解析\"></a>parseSimpleString 解析</h3><p>协议为 <code>-</code> 开头的数据，并解析出实际的内容，并直接设置具体内容。与Error一样的操作。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int parseSimpleString(ReplyParser *parser, void *p_ctx) &#123;</span><br><span class=\"line\">    const char *proto = parser-&gt;curr_location;</span><br><span class=\"line\">    char *p = strchr(proto+1,&#x27;\\r&#x27;);</span><br><span class=\"line\">    parser-&gt;curr_location = p + 2; /* for \\r\\n */</span><br><span class=\"line\">    parser-&gt;callbacks.simple_str_callback(p_ctx, proto+1, p-proto-1, proto, parser-&gt;curr_location - proto);</span><br><span class=\"line\">    return C_OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"parseLong-解析\"><a href=\"#parseLong-解析\" class=\"headerlink\" title=\"parseLong 解析\"></a>parseLong 解析</h3><p>协议为 <code>:</code> 开头的数据，并解析出 2字节的数据信息。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int parseLong(ReplyParser *parser, void *p_ctx) &#123;</span><br><span class=\"line\">    const char *proto = parser-&gt;curr_location;</span><br><span class=\"line\">    char *p = strchr(proto+1,&#x27;\\r&#x27;);</span><br><span class=\"line\">    parser-&gt;curr_location = p + 2; /* for \\r\\n */</span><br><span class=\"line\">    long long val;</span><br><span class=\"line\">    string2ll(proto+1,p-proto-1,&amp;val);</span><br><span class=\"line\">    parser-&gt;callbacks.long_callback(p_ctx, val, proto, parser-&gt;curr_location - proto);</span><br><span class=\"line\">    return C_OK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static void callReplyLong(void *ctx, long long val, const char *proto, size_t proto_len) &#123;</span><br><span class=\"line\">    CallReply *rep = ctx;</span><br><span class=\"line\">    callReplySetSharedData(rep, REDISMODULE_REPLY_INTEGER, proto, proto_len, 0);</span><br><span class=\"line\">    rep-&gt;val.ll = val;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"parseArray-解析\"><a href=\"#parseArray-解析\" class=\"headerlink\" title=\"parseArray 解析\"></a>parseArray 解析</h3><p>协议为 <code>$</code> 开头的数据，并解析出 2字节的元素个数信息，并最终调用<code>callReplyParseCollection</code> 进行递归解析协议内容。后续会单独讲解解析后的数据如何存放。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int parseArray(ReplyParser *parser, void *p_ctx) &#123;</span><br><span class=\"line\">    const char *proto = parser-&gt;curr_location;</span><br><span class=\"line\">    char *p = strchr(proto+1,&#x27;\\r&#x27;);</span><br><span class=\"line\">    long long len;</span><br><span class=\"line\">    string2ll(proto+1,p-proto-1,&amp;len);</span><br><span class=\"line\">    p += 2;</span><br><span class=\"line\">    parser-&gt;curr_location = p;</span><br><span class=\"line\">    if (len == -1) &#123;</span><br><span class=\"line\">        parser-&gt;callbacks.null_array_callback(p_ctx, proto, parser-&gt;curr_location - proto);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        parser-&gt;callbacks.array_callback(parser, p_ctx, len, proto);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return C_OK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static void callReplyArray(ReplyParser *parser, void *ctx, size_t len, const char *proto) &#123;</span><br><span class=\"line\">    CallReply *rep = ctx;</span><br><span class=\"line\">    rep-&gt;type = REDISMODULE_REPLY_ARRAY;</span><br><span class=\"line\">    callReplyParseCollection(parser, rep, len, proto, 1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"parseSet-解析\"><a href=\"#parseSet-解析\" class=\"headerlink\" title=\"parseSet 解析\"></a>parseSet 解析</h3><p>协议为 <code>~</code> 开头的数据，并解析出 2字节的元素个数信息，并最终调用<code>callReplyParseCollection</code> 进行递归解析协议内容。由此可见，Set和Array内容基本上相似。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int parseSet(ReplyParser *parser, void *p_ctx) &#123;</span><br><span class=\"line\">    const char *proto = parser-&gt;curr_location;</span><br><span class=\"line\">    char *p = strchr(proto+1,&#x27;\\r&#x27;);</span><br><span class=\"line\">    long long len;</span><br><span class=\"line\">    string2ll(proto+1,p-proto-1,&amp;len);</span><br><span class=\"line\">    p += 2;</span><br><span class=\"line\">    parser-&gt;curr_location = p;</span><br><span class=\"line\">    parser-&gt;callbacks.set_callback(parser, p_ctx, len, proto);</span><br><span class=\"line\">    return C_OK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static void callReplySet(ReplyParser *parser, void *ctx, size_t len, const char *proto) &#123;</span><br><span class=\"line\">    CallReply *rep = ctx;</span><br><span class=\"line\">    rep-&gt;type = REDISMODULE_REPLY_SET;</span><br><span class=\"line\">    callReplyParseCollection(parser, rep, len, proto, 1);</span><br><span class=\"line\">    rep-&gt;flags |= REPLY_FLAG_RESP3;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"parseMap-解析\"><a href=\"#parseMap-解析\" class=\"headerlink\" title=\"parseMap 解析\"></a>parseMap 解析</h3><p>协议为 <code>%</code> 开头的数据，并解析出 2字节的元素个数信息，并最终调用<code>callReplyParseCollection</code> 进行递归解析协议内容。由此可见，Set、Array、Map内容基本上相似。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int parseMap(ReplyParser *parser, void *p_ctx) &#123;</span><br><span class=\"line\">    const char *proto = parser-&gt;curr_location;</span><br><span class=\"line\">    char *p = strchr(proto+1,&#x27;\\r&#x27;);</span><br><span class=\"line\">    long long len;</span><br><span class=\"line\">    string2ll(proto+1,p-proto-1,&amp;len);</span><br><span class=\"line\">    p += 2;</span><br><span class=\"line\">    parser-&gt;curr_location = p;</span><br><span class=\"line\">    parser-&gt;callbacks.map_callback(parser, p_ctx, len, proto);</span><br><span class=\"line\">    return C_OK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static void callReplyMap(ReplyParser *parser, void *ctx, size_t len, const char *proto) &#123;</span><br><span class=\"line\">    CallReply *rep = ctx;</span><br><span class=\"line\">    rep-&gt;type = REDISMODULE_REPLY_MAP;</span><br><span class=\"line\">    callReplyParseCollection(parser, rep, len, proto, 2);</span><br><span class=\"line\">    rep-&gt;flags |= REPLY_FLAG_RESP3;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"parseDouble-解析\"><a href=\"#parseDouble-解析\" class=\"headerlink\" title=\"parseDouble 解析\"></a>parseDouble 解析</h3><p>协议为 <code>,</code> 开头的数据，并解析出全量数据，并以此复制到buffer中，并进行转换，其中最大的空间为：<code>5*1024</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int parseDouble(ReplyParser *parser, void *p_ctx) &#123;</span><br><span class=\"line\">    const char *proto = parser-&gt;curr_location;</span><br><span class=\"line\">    char *p = strchr(proto+1,&#x27;\\r&#x27;);</span><br><span class=\"line\">    parser-&gt;curr_location = p + 2; /* for \\r\\n */</span><br><span class=\"line\">    char buf[MAX_LONG_DOUBLE_CHARS+1];</span><br><span class=\"line\">    size_t len = p-proto-1;</span><br><span class=\"line\">    double d;</span><br><span class=\"line\">    if (len &lt;= MAX_LONG_DOUBLE_CHARS) &#123;</span><br><span class=\"line\">        memcpy(buf,proto+1,len);</span><br><span class=\"line\">        buf[len] = &#x27;\\0&#x27;;</span><br><span class=\"line\">        d = strtod(buf,NULL); /* We expect a valid representation. */</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        d = 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    parser-&gt;callbacks.double_callback(p_ctx, d, proto, parser-&gt;curr_location - proto);</span><br><span class=\"line\">    return C_OK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"parseBool-解析\"><a href=\"#parseBool-解析\" class=\"headerlink\" title=\"parseBool 解析\"></a>parseBool 解析</h3><p>协议为 <code>#</code> 开头的数据，并解析一个字节：<code>t</code> 或者 <code>f</code>，来区分bool的数值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int parseBool(ReplyParser *parser, void *p_ctx) &#123;</span><br><span class=\"line\">    const char *proto = parser-&gt;curr_location;</span><br><span class=\"line\">    char *p = strchr(proto+1,&#x27;\\r&#x27;);</span><br><span class=\"line\">    parser-&gt;curr_location = p + 2; /* for \\r\\n */</span><br><span class=\"line\">    parser-&gt;callbacks.bool_callback(p_ctx, proto[1] == &#x27;t&#x27;, proto, parser-&gt;curr_location - proto);</span><br><span class=\"line\">    return C_OK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static void callReplyBool(void *ctx, int val, const char *proto, size_t proto_len) &#123;</span><br><span class=\"line\">    CallReply *rep = ctx;</span><br><span class=\"line\">    callReplySetSharedData(rep, REDISMODULE_REPLY_BOOL, proto, proto_len, REPLY_FLAG_RESP3);</span><br><span class=\"line\">    rep-&gt;val.ll = val;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"parseBigNumber-解析\"><a href=\"#parseBigNumber-解析\" class=\"headerlink\" title=\"parseBigNumber 解析\"></a>parseBigNumber 解析</h3><p>协议为 <code>(</code> 开头的数据，并解析出全量数据，并以此复制到buffer中，最终的表现形式还是为字符串。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int parseBigNumber(ReplyParser *parser, void *p_ctx) &#123;</span><br><span class=\"line\">    const char *proto = parser-&gt;curr_location;</span><br><span class=\"line\">    char *p = strchr(proto+1,&#x27;\\r&#x27;);</span><br><span class=\"line\">    parser-&gt;curr_location = p + 2; /* for \\r\\n */</span><br><span class=\"line\">    parser-&gt;callbacks.big_number_callback(p_ctx, proto+1, p-proto-1, proto, parser-&gt;curr_location - proto);</span><br><span class=\"line\">    return C_OK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static void callReplyBigNumber(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len) &#123;</span><br><span class=\"line\">    CallReply *rep = ctx;</span><br><span class=\"line\">    callReplySetSharedData(rep, REDISMODULE_REPLY_BIG_NUMBER, proto, proto_len, REPLY_FLAG_RESP3);</span><br><span class=\"line\">    rep-&gt;len = len;</span><br><span class=\"line\">    rep-&gt;val.str = str;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"parseAttributes-解析\"><a href=\"#parseAttributes-解析\" class=\"headerlink\" title=\"parseAttributes 解析\"></a>parseAttributes 解析</h3><p>协议为 <code>|</code> 开头的数据，并解析出 2字节的元素个数信息，并最终调用<code>callReplyParseCollection</code> 进行递归解析协议内容，解析后，会再次调用 <code>parseReply</code> 单独解析内容。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int parseAttributes(ReplyParser *parser, void *p_ctx) &#123;</span><br><span class=\"line\">    const char *proto = parser-&gt;curr_location;</span><br><span class=\"line\">    char *p = strchr(proto+1,&#x27;\\r&#x27;);</span><br><span class=\"line\">    long long len;</span><br><span class=\"line\">    string2ll(proto+1,p-proto-1,&amp;len);</span><br><span class=\"line\">    p += 2;</span><br><span class=\"line\">    parser-&gt;curr_location = p;</span><br><span class=\"line\">    parser-&gt;callbacks.attribute_callback(parser, p_ctx, len, proto);</span><br><span class=\"line\">    return C_OK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static void callReplyAttribute(ReplyParser *parser, void *ctx, size_t len, const char *proto) &#123;</span><br><span class=\"line\">    CallReply *rep = ctx;</span><br><span class=\"line\">    rep-&gt;attribute = zcalloc(sizeof(CallReply));</span><br><span class=\"line\"></span><br><span class=\"line\">    /* Continue parsing the attribute reply */</span><br><span class=\"line\">    rep-&gt;attribute-&gt;len = len;</span><br><span class=\"line\">    rep-&gt;attribute-&gt;type = REDISMODULE_REPLY_ATTRIBUTE;</span><br><span class=\"line\">    callReplyParseCollection(parser, rep-&gt;attribute, len, proto, 2);</span><br><span class=\"line\">    rep-&gt;attribute-&gt;flags |= REPLY_FLAG_PARSED | REPLY_FLAG_RESP3;</span><br><span class=\"line\">    rep-&gt;attribute-&gt;private_data = rep-&gt;private_data;</span><br><span class=\"line\"></span><br><span class=\"line\">    /* Continue parsing the reply */</span><br><span class=\"line\">    parseReply(parser, rep);</span><br><span class=\"line\"></span><br><span class=\"line\">    /* In this case we need to fix the proto address and len, it should start from the attribute */</span><br><span class=\"line\">    rep-&gt;proto = proto;</span><br><span class=\"line\">    rep-&gt;proto_len = parser-&gt;curr_location - proto;</span><br><span class=\"line\">    rep-&gt;flags |= REPLY_FLAG_RESP3;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"parseVerbatimString-解析\"><a href=\"#parseVerbatimString-解析\" class=\"headerlink\" title=\"parseVerbatimString 解析\"></a>parseVerbatimString 解析</h3><p>协议为 <code>=</code> 开头的数据，并解析出2字节的长度后，由会取出4个字节作为format信息，最终剩余的空间为二进制安全字符串。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int parseVerbatimString(ReplyParser *parser, void *p_ctx) &#123;</span><br><span class=\"line\">    const char *proto = parser-&gt;curr_location;</span><br><span class=\"line\">    char *p = strchr(proto+1,&#x27;\\r&#x27;);</span><br><span class=\"line\">    long long bulklen;</span><br><span class=\"line\">    parser-&gt;curr_location = p + 2; /* for \\r\\n */</span><br><span class=\"line\">    string2ll(proto+1,p-proto-1,&amp;bulklen);</span><br><span class=\"line\">    const char *format = parser-&gt;curr_location;</span><br><span class=\"line\">    parser-&gt;curr_location += bulklen;</span><br><span class=\"line\">    parser-&gt;curr_location += 2; /* for \\r\\n */</span><br><span class=\"line\">    parser-&gt;callbacks.verbatim_string_callback(p_ctx, format, format + 4, bulklen - 4, proto, parser-&gt;curr_location - proto);</span><br><span class=\"line\">    return C_OK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static void callReplyVerbatimString(void *ctx, const char *format, const char *str, size_t len, const char *proto, size_t proto_len) &#123;</span><br><span class=\"line\">    CallReply *rep = ctx;</span><br><span class=\"line\">    callReplySetSharedData(rep, REDISMODULE_REPLY_VERBATIM_STRING, proto, proto_len, REPLY_FLAG_RESP3);</span><br><span class=\"line\">    rep-&gt;len = len;</span><br><span class=\"line\">    rep-&gt;val.verbatim_str.str = str;</span><br><span class=\"line\">    rep-&gt;val.verbatim_str.format = format;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"特殊源码\"><a href=\"#特殊源码\" class=\"headerlink\" title=\"特殊源码\"></a>特殊源码</h2><h3 id=\"协议结构\"><a href=\"#协议结构\" class=\"headerlink\" title=\"协议结构\"></a>协议结构</h3><p>单独来了解一下默认协议的表示结构体：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct CallReply &#123;</span><br><span class=\"line\">    void *private_data;</span><br><span class=\"line\">    sds original_proto; /* Available only for root reply. */</span><br><span class=\"line\">    const char *proto;</span><br><span class=\"line\">    size_t proto_len;</span><br><span class=\"line\">    int type;       /* REPLY_... */</span><br><span class=\"line\">    int flags;      /* REPLY_FLAG... */</span><br><span class=\"line\">    size_t len;     /* Length of a string, or the number elements in an array. */</span><br><span class=\"line\">    union &#123;</span><br><span class=\"line\">        const char *str; /* String pointer for string and error replies. This</span><br><span class=\"line\">                          * does not need to be freed, always points inside</span><br><span class=\"line\">                          * a reply-&gt;proto buffer of the reply object or, in</span><br><span class=\"line\">                          * case of array elements, of parent reply objects. */</span><br><span class=\"line\">        struct &#123;</span><br><span class=\"line\">            const char *str;</span><br><span class=\"line\">            const char *format;</span><br><span class=\"line\">        &#125; verbatim_str;  /* Reply value for verbatim string */</span><br><span class=\"line\">        long long ll;    /* Reply value for integer reply. */</span><br><span class=\"line\">        double d;        /* Reply value for double reply. */</span><br><span class=\"line\">        struct CallReply *array; /* Array of sub-reply elements. used for set, array, map, and attribute */</span><br><span class=\"line\">    &#125; val;</span><br><span class=\"line\">    list *deferred_error_list;   /* list of errors in sds form or NULL */</span><br><span class=\"line\">    struct CallReply *attribute; /* attribute reply, NULL if not exists */</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>大体可以分为三块内容：</p>\n<ol>\n<li>协议信息</li>\n<li>数据部分</li>\n<li>析构处理</li>\n</ol>\n<h4 id=\"协议信息\"><a href=\"#协议信息\" class=\"headerlink\" title=\"协议信息\"></a>协议信息</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void *private_data;</span><br><span class=\"line\">sds original_proto; /* Available only for root reply. */</span><br><span class=\"line\">const char *proto;</span><br><span class=\"line\">size_t proto_len;</span><br><span class=\"line\">int type;       /* REPLY_... */</span><br><span class=\"line\">int flags;      /* REPLY_FLAG... */</span><br><span class=\"line\">size_t len;     /* Length of a string, or the number elements in an array. */</span><br></pre></td></tr></table></figure>\n\n<p>从上到下分别为：特殊透传数据、reply根地址、reply当前解析地址、reply长度、当前协议类型、当前的标记位。</p>\n<h4 id=\"数据部分\"><a href=\"#数据部分\" class=\"headerlink\" title=\"数据部分\"></a>数据部分</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">size_t len;     /* Length of a string, or the number elements in an array. */</span><br><span class=\"line\">union &#123;</span><br><span class=\"line\">    const char *str; /* String pointer for string and error replies. This</span><br><span class=\"line\">                      * does not need to be freed, always points inside</span><br><span class=\"line\">                      * a reply-&gt;proto buffer of the reply object or, in</span><br><span class=\"line\">                      * case of array elements, of parent reply objects. */</span><br><span class=\"line\">    struct &#123;</span><br><span class=\"line\">        const char *str;</span><br><span class=\"line\">        const char *format;</span><br><span class=\"line\">    &#125; verbatim_str;  /* Reply value for verbatim string */</span><br><span class=\"line\">    long long ll;    /* Reply value for integer reply. */</span><br><span class=\"line\">    double d;        /* Reply value for double reply. */</span><br><span class=\"line\">    struct CallReply *array; /* Array of sub-reply elements. used for set, array, map, and attribute */</span><br><span class=\"line\">&#125; val;</span><br><span class=\"line\">struct CallReply *attribute; /* attribute reply, NULL if not exists */</span><br></pre></td></tr></table></figure>\n\n<p>整体通过一个union属性来包裹了value信息，其中有string、verbatim_str、number、double、array类型，同时这部分还有一个len代表元素的长度信息。</p>\n<p>其中，我们将 <code>attribute</code> 也做为数据部分看待，因为，它也可以表示实际的信息。</p>\n<h3 id=\"析构处理\"><a href=\"#析构处理\" class=\"headerlink\" title=\"析构处理\"></a>析构处理</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list *deferred_error_list;   /* list of errors in sds form or NULL */</span><br></pre></td></tr></table></figure>\n\n<p>这块的逻辑主要是在于完成解析后，数据的释放流程：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void freeCallReply(CallReply *rep) &#123;</span><br><span class=\"line\">    if (!(rep-&gt;flags &amp; REPLY_FLAG_ROOT)) &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if (rep-&gt;flags &amp; REPLY_FLAG_PARSED) &#123;</span><br><span class=\"line\">        freeCallReplyInternal(rep);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sdsfree(rep-&gt;original_proto);</span><br><span class=\"line\">    if (rep-&gt;deferred_error_list)</span><br><span class=\"line\">        listRelease(rep-&gt;deferred_error_list);</span><br><span class=\"line\">    zfree(rep);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"递归逻辑\"><a href=\"#递归逻辑\" class=\"headerlink\" title=\"递归逻辑\"></a>递归逻辑</h3><p>本节单独解析 <code>callReplyParseCollection</code> 方法，源码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void callReplyParseCollection(ReplyParser *parser, CallReply *rep, size_t len, const char *proto, size_t elements_per_entry) &#123;</span><br><span class=\"line\">    rep-&gt;len = len;</span><br><span class=\"line\">    rep-&gt;val.array = zcalloc(elements_per_entry * len * sizeof(CallReply));</span><br><span class=\"line\">    for (size_t i = 0; i &lt; len * elements_per_entry; i += elements_per_entry) &#123;</span><br><span class=\"line\">        for (size_t j = 0 ; j &lt; elements_per_entry ; ++j) &#123;</span><br><span class=\"line\">            rep-&gt;val.array[i + j].private_data = rep-&gt;private_data;</span><br><span class=\"line\">            parseReply(parser, rep-&gt;val.array + i + j);</span><br><span class=\"line\">            rep-&gt;val.array[i + j].flags |= REPLY_FLAG_PARSED;</span><br><span class=\"line\">            if (rep-&gt;val.array[i + j].flags &amp; REPLY_FLAG_RESP3) &#123;</span><br><span class=\"line\">                /* If one of the sub-replies is RESP3, then the current reply is also RESP3. */</span><br><span class=\"line\">                rep-&gt;flags |= REPLY_FLAG_RESP3;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    rep-&gt;proto = proto;</span><br><span class=\"line\">    rep-&gt;proto_len = parser-&gt;curr_location - proto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中有趣的点在于，为了支持Map和Array的操作，增加了len和elements_per_entry变量。前者表示元素个数，后者则代表，每个元素中，存在多少个数据。例如Map每个元素存在key和value俩类数据，而Array只存在Value。这么设计最终完成了Map和Array的统一，以及更好的支持了Map本身递归表示的能力。</p>\n"},{"title":"Hello World","abbrlink":16107,"_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\nabbrlink: 16107\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2023-01-01T16:03:57.669Z","updated":"2023-01-01T16:03:57.669Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clf3c2gcw00084cuq6v9z6h95","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"可怕的Debug命令","abbrlink":20649,"date":"2023-01-03T16:02:08.000Z","_content":"\ndebug命令在在UT还是日常都是尖端科技。通过该命令可以对整个Redis实例进行特殊的处理，包括但不限于coredump、sleep、rdb、propagate等操作。本文单独针对不同的操作来记录debug命令的功能。\n\n当然，在Redis7 中，支持了 enable_debug_cmd 配置，保证 debug 操作只在本机的客户端中才可执行。\n\n### 无风险操作\n\n```\ndebug help\n```\n\nhelp命令主要用于介绍debug的功能，但是并不齐全，这或许是避免胆大的用户的误操作吧。\n\n```\ndebug log\n```\n\n打印一个DEBUG LOG 日志。\n\n```\ndebug object <key>\n```\n\n打印一个数据的详细信息，包括相关的地址、引用次数、lru信息，以及encode信息，若是list，则会打印 list 的节点信息。\n\n```\ndebug sdslen <key>\n```\n\n打印一个字符串数据的信息，主要是相关的空间信息\n\n```\ndebug listpack <key>\n```\n\n打印一个 listpack 数据的信息\n\n```\ndebug quicklist <key>\n```\n\n打印一个 quicklist 数据的信息\n\n```\ndebug htstats-key <key>\n```\n\n打印一个 hash 数据的信息\n\n```\ndebug htstats <dbid>\n```\n\n打印当前 db 的信息，包括 ht 和 expire ht 的大小信息\n\n```\ndebug error\n```\n\n返回一个错误的响应\n\n```\ndebug structsize\n```\n\n打印当前系统个类型的大小信息\n\n```\ndebug client-eviction\n```\n\n显示低级客户端逐出池信息，主要确定 client 的状态信息\n\n### 高风险操作\n\n```\ndebug segfault\n```\n\n触发段错误，实现的方式就是mmap申请一个只读的空间，然后再去对其进行赋值。\n\n```\ndebug panic\n```\n\n触发panic错误，这个操作会触发正常的日志打印。主要用于ut层面模拟服务异常\n\n```\ndebug restart\ndebug crash-and-recover\n```\n\n触发重启，如果是 restart 模式，或进行config rewrite 以及 bgsave 操作，否则会直接进行 crash 操作，默认服务故障。\n\n```\ndebug oom\n```\n\n触发oom，这样主要是通过 zmalloc 申请一个 ULONG_MAX 大小的空间。\n\n```\ndebug assert\n```\n\n触发 assert 失败操作，在整个 Redis 逻辑里面，会有各种的 assert 判断，当前操作主要是尝试触发一个 1 == 2 的失败判断，以确定 assert 是否有效。\n\n```\ndebug leak\n```\n\n触发内存泄露，通过 sdsdup 申请一个泄露的内存空间\n\n\n```\ndebug reload [MERGE|NOFLUSH|NOSAVE]\n```\n\n触发数据重载，其中 NOFLUSH 表示不清空原有数据，NOSAVE 表示不保存原有数据到 rdb 文件中，而 MERGE 表示尝试把数据进行加载合并\n\n\n```\ndebug loadaof\n```\n\n触发 aof 加载，其中会进行数据清空，并重新从 aof 文件中加载数据。\n\n```\ndebug drop-cluster-packet-filter\n```\n\n设置 cluster 模式下的包过滤类型。模拟丢包的情况。\n\n```\ndebug sleep <sec>\n```\n\n休眠 sec 秒，支持double类型。\n\n```\ndebug replicate <argv...>\n```\n\n人工触发一次命令传播，容易导致主从同步异常。\n\n```\ndebug change-repl-id\n```\n\n重置 replid 信息，主要用于触发全量同步。\n\n```\ndebug pause-cron <enable>\n```\n\n暂停 cron 操作，模拟 cron 时间过长\n\n### 测试操作\n\n```\ndebug populate <keys> <tag> <num>\n```\n\n模拟生成数据操作，其中会生成 keys 个带有 tag 的数据，每个的长度为 num。\n\n```\ndebug digest\n```\n\n计算db中的快照信息，输出一个32位的字符串，当前方法是一个扫描全表的操作，风险极高。\n\n```\ndebug digest-value <key...>\n```\n\n计算相关 key 的快照信息，每个 key 都输出一个32位的字符串\n\n```\ndebug protocol [string|integer|double|bignum|null|array|set|map| attrib|push|verbatim|true|false]\n```\n\n测试当前的协议情况\n\n```\ndebug stringmatch-test\n```\n\n进行字符串的模糊测试操作：`stringmatchlen_fuzz_test`\n\n\n### 后台操作\n\n```\ndebug set-active-expire <enable>\n```\n\n设置当前 expire 操作是否打开，用于避免触发过期操作引起的数据变化\n\n```\ndebug quicklist-packed-threshold <threshold>\n```\n\n设置 quicklist 的打包阈值\n\n```\ndebug set-skip-checksum-validation <enable>\n```\n\n设置是否需要跳过 rdb 的 sum 检查操作。\n\n```\ndebug aof-flush-sleep <num>\n```\n\n设置 aof flush 的等待时间\n\n\n```\ndebug config-rewrite-force-all\n```\n\n强制 rewrite 所有配置信息\n\n\n```\ndebug set-disable-deny-scripts <enable>\n```\n\n禁止脚本中嵌套脚本操作\n\n\n```\ndebug mallctl <argv>\ndebug mallctl-str <argv>\n```\n\n读取当前 jemalloc 的信息，用于定位内存问题\n\n```\ndebug replybuffer <peak-reset-time <never|reset|<time> | resizing >\n```\n\n是否打开 客户端 buffer 的内存清理能力。","source":"_posts/可怕的Debug命令.md","raw":"---\ntitle: 可怕的Debug命令\nabbrlink: 20649\ndate: 2023-01-04 00:02:08\ntags:\n---\n\ndebug命令在在UT还是日常都是尖端科技。通过该命令可以对整个Redis实例进行特殊的处理，包括但不限于coredump、sleep、rdb、propagate等操作。本文单独针对不同的操作来记录debug命令的功能。\n\n当然，在Redis7 中，支持了 enable_debug_cmd 配置，保证 debug 操作只在本机的客户端中才可执行。\n\n### 无风险操作\n\n```\ndebug help\n```\n\nhelp命令主要用于介绍debug的功能，但是并不齐全，这或许是避免胆大的用户的误操作吧。\n\n```\ndebug log\n```\n\n打印一个DEBUG LOG 日志。\n\n```\ndebug object <key>\n```\n\n打印一个数据的详细信息，包括相关的地址、引用次数、lru信息，以及encode信息，若是list，则会打印 list 的节点信息。\n\n```\ndebug sdslen <key>\n```\n\n打印一个字符串数据的信息，主要是相关的空间信息\n\n```\ndebug listpack <key>\n```\n\n打印一个 listpack 数据的信息\n\n```\ndebug quicklist <key>\n```\n\n打印一个 quicklist 数据的信息\n\n```\ndebug htstats-key <key>\n```\n\n打印一个 hash 数据的信息\n\n```\ndebug htstats <dbid>\n```\n\n打印当前 db 的信息，包括 ht 和 expire ht 的大小信息\n\n```\ndebug error\n```\n\n返回一个错误的响应\n\n```\ndebug structsize\n```\n\n打印当前系统个类型的大小信息\n\n```\ndebug client-eviction\n```\n\n显示低级客户端逐出池信息，主要确定 client 的状态信息\n\n### 高风险操作\n\n```\ndebug segfault\n```\n\n触发段错误，实现的方式就是mmap申请一个只读的空间，然后再去对其进行赋值。\n\n```\ndebug panic\n```\n\n触发panic错误，这个操作会触发正常的日志打印。主要用于ut层面模拟服务异常\n\n```\ndebug restart\ndebug crash-and-recover\n```\n\n触发重启，如果是 restart 模式，或进行config rewrite 以及 bgsave 操作，否则会直接进行 crash 操作，默认服务故障。\n\n```\ndebug oom\n```\n\n触发oom，这样主要是通过 zmalloc 申请一个 ULONG_MAX 大小的空间。\n\n```\ndebug assert\n```\n\n触发 assert 失败操作，在整个 Redis 逻辑里面，会有各种的 assert 判断，当前操作主要是尝试触发一个 1 == 2 的失败判断，以确定 assert 是否有效。\n\n```\ndebug leak\n```\n\n触发内存泄露，通过 sdsdup 申请一个泄露的内存空间\n\n\n```\ndebug reload [MERGE|NOFLUSH|NOSAVE]\n```\n\n触发数据重载，其中 NOFLUSH 表示不清空原有数据，NOSAVE 表示不保存原有数据到 rdb 文件中，而 MERGE 表示尝试把数据进行加载合并\n\n\n```\ndebug loadaof\n```\n\n触发 aof 加载，其中会进行数据清空，并重新从 aof 文件中加载数据。\n\n```\ndebug drop-cluster-packet-filter\n```\n\n设置 cluster 模式下的包过滤类型。模拟丢包的情况。\n\n```\ndebug sleep <sec>\n```\n\n休眠 sec 秒，支持double类型。\n\n```\ndebug replicate <argv...>\n```\n\n人工触发一次命令传播，容易导致主从同步异常。\n\n```\ndebug change-repl-id\n```\n\n重置 replid 信息，主要用于触发全量同步。\n\n```\ndebug pause-cron <enable>\n```\n\n暂停 cron 操作，模拟 cron 时间过长\n\n### 测试操作\n\n```\ndebug populate <keys> <tag> <num>\n```\n\n模拟生成数据操作，其中会生成 keys 个带有 tag 的数据，每个的长度为 num。\n\n```\ndebug digest\n```\n\n计算db中的快照信息，输出一个32位的字符串，当前方法是一个扫描全表的操作，风险极高。\n\n```\ndebug digest-value <key...>\n```\n\n计算相关 key 的快照信息，每个 key 都输出一个32位的字符串\n\n```\ndebug protocol [string|integer|double|bignum|null|array|set|map| attrib|push|verbatim|true|false]\n```\n\n测试当前的协议情况\n\n```\ndebug stringmatch-test\n```\n\n进行字符串的模糊测试操作：`stringmatchlen_fuzz_test`\n\n\n### 后台操作\n\n```\ndebug set-active-expire <enable>\n```\n\n设置当前 expire 操作是否打开，用于避免触发过期操作引起的数据变化\n\n```\ndebug quicklist-packed-threshold <threshold>\n```\n\n设置 quicklist 的打包阈值\n\n```\ndebug set-skip-checksum-validation <enable>\n```\n\n设置是否需要跳过 rdb 的 sum 检查操作。\n\n```\ndebug aof-flush-sleep <num>\n```\n\n设置 aof flush 的等待时间\n\n\n```\ndebug config-rewrite-force-all\n```\n\n强制 rewrite 所有配置信息\n\n\n```\ndebug set-disable-deny-scripts <enable>\n```\n\n禁止脚本中嵌套脚本操作\n\n\n```\ndebug mallctl <argv>\ndebug mallctl-str <argv>\n```\n\n读取当前 jemalloc 的信息，用于定位内存问题\n\n```\ndebug replybuffer <peak-reset-time <never|reset|<time> | resizing >\n```\n\n是否打开 客户端 buffer 的内存清理能力。","slug":"可怕的Debug命令","published":1,"updated":"2023-01-03T16:47:41.866Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clf3c2gcx00094cuqbj86ak4r","content":"<p>debug命令在在UT还是日常都是尖端科技。通过该命令可以对整个Redis实例进行特殊的处理，包括但不限于coredump、sleep、rdb、propagate等操作。本文单独针对不同的操作来记录debug命令的功能。</p>\n<p>当然，在Redis7 中，支持了 enable_debug_cmd 配置，保证 debug 操作只在本机的客户端中才可执行。</p>\n<h3 id=\"无风险操作\"><a href=\"#无风险操作\" class=\"headerlink\" title=\"无风险操作\"></a>无风险操作</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug help</span><br></pre></td></tr></table></figure>\n\n<p>help命令主要用于介绍debug的功能，但是并不齐全，这或许是避免胆大的用户的误操作吧。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug log</span><br></pre></td></tr></table></figure>\n\n<p>打印一个DEBUG LOG 日志。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug object &lt;key&gt;</span><br></pre></td></tr></table></figure>\n\n<p>打印一个数据的详细信息，包括相关的地址、引用次数、lru信息，以及encode信息，若是list，则会打印 list 的节点信息。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug sdslen &lt;key&gt;</span><br></pre></td></tr></table></figure>\n\n<p>打印一个字符串数据的信息，主要是相关的空间信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug listpack &lt;key&gt;</span><br></pre></td></tr></table></figure>\n\n<p>打印一个 listpack 数据的信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug quicklist &lt;key&gt;</span><br></pre></td></tr></table></figure>\n\n<p>打印一个 quicklist 数据的信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug htstats-key &lt;key&gt;</span><br></pre></td></tr></table></figure>\n\n<p>打印一个 hash 数据的信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug htstats &lt;dbid&gt;</span><br></pre></td></tr></table></figure>\n\n<p>打印当前 db 的信息，包括 ht 和 expire ht 的大小信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug error</span><br></pre></td></tr></table></figure>\n\n<p>返回一个错误的响应</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug structsize</span><br></pre></td></tr></table></figure>\n\n<p>打印当前系统个类型的大小信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug client-eviction</span><br></pre></td></tr></table></figure>\n\n<p>显示低级客户端逐出池信息，主要确定 client 的状态信息</p>\n<h3 id=\"高风险操作\"><a href=\"#高风险操作\" class=\"headerlink\" title=\"高风险操作\"></a>高风险操作</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug segfault</span><br></pre></td></tr></table></figure>\n\n<p>触发段错误，实现的方式就是mmap申请一个只读的空间，然后再去对其进行赋值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug panic</span><br></pre></td></tr></table></figure>\n\n<p>触发panic错误，这个操作会触发正常的日志打印。主要用于ut层面模拟服务异常</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug restart</span><br><span class=\"line\">debug crash-and-recover</span><br></pre></td></tr></table></figure>\n\n<p>触发重启，如果是 restart 模式，或进行config rewrite 以及 bgsave 操作，否则会直接进行 crash 操作，默认服务故障。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug oom</span><br></pre></td></tr></table></figure>\n\n<p>触发oom，这样主要是通过 zmalloc 申请一个 ULONG_MAX 大小的空间。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug assert</span><br></pre></td></tr></table></figure>\n\n<p>触发 assert 失败操作，在整个 Redis 逻辑里面，会有各种的 assert 判断，当前操作主要是尝试触发一个 1 == 2 的失败判断，以确定 assert 是否有效。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug leak</span><br></pre></td></tr></table></figure>\n\n<p>触发内存泄露，通过 sdsdup 申请一个泄露的内存空间</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug reload [MERGE|NOFLUSH|NOSAVE]</span><br></pre></td></tr></table></figure>\n\n<p>触发数据重载，其中 NOFLUSH 表示不清空原有数据，NOSAVE 表示不保存原有数据到 rdb 文件中，而 MERGE 表示尝试把数据进行加载合并</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug loadaof</span><br></pre></td></tr></table></figure>\n\n<p>触发 aof 加载，其中会进行数据清空，并重新从 aof 文件中加载数据。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug drop-cluster-packet-filter</span><br></pre></td></tr></table></figure>\n\n<p>设置 cluster 模式下的包过滤类型。模拟丢包的情况。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug sleep &lt;sec&gt;</span><br></pre></td></tr></table></figure>\n\n<p>休眠 sec 秒，支持double类型。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug replicate &lt;argv...&gt;</span><br></pre></td></tr></table></figure>\n\n<p>人工触发一次命令传播，容易导致主从同步异常。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug change-repl-id</span><br></pre></td></tr></table></figure>\n\n<p>重置 replid 信息，主要用于触发全量同步。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug pause-cron &lt;enable&gt;</span><br></pre></td></tr></table></figure>\n\n<p>暂停 cron 操作，模拟 cron 时间过长</p>\n<h3 id=\"测试操作\"><a href=\"#测试操作\" class=\"headerlink\" title=\"测试操作\"></a>测试操作</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug populate &lt;keys&gt; &lt;tag&gt; &lt;num&gt;</span><br></pre></td></tr></table></figure>\n\n<p>模拟生成数据操作，其中会生成 keys 个带有 tag 的数据，每个的长度为 num。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug digest</span><br></pre></td></tr></table></figure>\n\n<p>计算db中的快照信息，输出一个32位的字符串，当前方法是一个扫描全表的操作，风险极高。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug digest-value &lt;key...&gt;</span><br></pre></td></tr></table></figure>\n\n<p>计算相关 key 的快照信息，每个 key 都输出一个32位的字符串</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug protocol [string|integer|double|bignum|null|array|set|map| attrib|push|verbatim|true|false]</span><br></pre></td></tr></table></figure>\n\n<p>测试当前的协议情况</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug stringmatch-test</span><br></pre></td></tr></table></figure>\n\n<p>进行字符串的模糊测试操作：<code>stringmatchlen_fuzz_test</code></p>\n<h3 id=\"后台操作\"><a href=\"#后台操作\" class=\"headerlink\" title=\"后台操作\"></a>后台操作</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug set-active-expire &lt;enable&gt;</span><br></pre></td></tr></table></figure>\n\n<p>设置当前 expire 操作是否打开，用于避免触发过期操作引起的数据变化</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug quicklist-packed-threshold &lt;threshold&gt;</span><br></pre></td></tr></table></figure>\n\n<p>设置 quicklist 的打包阈值</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug set-skip-checksum-validation &lt;enable&gt;</span><br></pre></td></tr></table></figure>\n\n<p>设置是否需要跳过 rdb 的 sum 检查操作。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug aof-flush-sleep &lt;num&gt;</span><br></pre></td></tr></table></figure>\n\n<p>设置 aof flush 的等待时间</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug config-rewrite-force-all</span><br></pre></td></tr></table></figure>\n\n<p>强制 rewrite 所有配置信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug set-disable-deny-scripts &lt;enable&gt;</span><br></pre></td></tr></table></figure>\n\n<p>禁止脚本中嵌套脚本操作</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug mallctl &lt;argv&gt;</span><br><span class=\"line\">debug mallctl-str &lt;argv&gt;</span><br></pre></td></tr></table></figure>\n\n<p>读取当前 jemalloc 的信息，用于定位内存问题</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug replybuffer &lt;peak-reset-time &lt;never|reset|&lt;time&gt; | resizing &gt;</span><br></pre></td></tr></table></figure>\n\n<p>是否打开 客户端 buffer 的内存清理能力。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>debug命令在在UT还是日常都是尖端科技。通过该命令可以对整个Redis实例进行特殊的处理，包括但不限于coredump、sleep、rdb、propagate等操作。本文单独针对不同的操作来记录debug命令的功能。</p>\n<p>当然，在Redis7 中，支持了 enable_debug_cmd 配置，保证 debug 操作只在本机的客户端中才可执行。</p>\n<h3 id=\"无风险操作\"><a href=\"#无风险操作\" class=\"headerlink\" title=\"无风险操作\"></a>无风险操作</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug help</span><br></pre></td></tr></table></figure>\n\n<p>help命令主要用于介绍debug的功能，但是并不齐全，这或许是避免胆大的用户的误操作吧。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug log</span><br></pre></td></tr></table></figure>\n\n<p>打印一个DEBUG LOG 日志。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug object &lt;key&gt;</span><br></pre></td></tr></table></figure>\n\n<p>打印一个数据的详细信息，包括相关的地址、引用次数、lru信息，以及encode信息，若是list，则会打印 list 的节点信息。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug sdslen &lt;key&gt;</span><br></pre></td></tr></table></figure>\n\n<p>打印一个字符串数据的信息，主要是相关的空间信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug listpack &lt;key&gt;</span><br></pre></td></tr></table></figure>\n\n<p>打印一个 listpack 数据的信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug quicklist &lt;key&gt;</span><br></pre></td></tr></table></figure>\n\n<p>打印一个 quicklist 数据的信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug htstats-key &lt;key&gt;</span><br></pre></td></tr></table></figure>\n\n<p>打印一个 hash 数据的信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug htstats &lt;dbid&gt;</span><br></pre></td></tr></table></figure>\n\n<p>打印当前 db 的信息，包括 ht 和 expire ht 的大小信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug error</span><br></pre></td></tr></table></figure>\n\n<p>返回一个错误的响应</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug structsize</span><br></pre></td></tr></table></figure>\n\n<p>打印当前系统个类型的大小信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug client-eviction</span><br></pre></td></tr></table></figure>\n\n<p>显示低级客户端逐出池信息，主要确定 client 的状态信息</p>\n<h3 id=\"高风险操作\"><a href=\"#高风险操作\" class=\"headerlink\" title=\"高风险操作\"></a>高风险操作</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug segfault</span><br></pre></td></tr></table></figure>\n\n<p>触发段错误，实现的方式就是mmap申请一个只读的空间，然后再去对其进行赋值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug panic</span><br></pre></td></tr></table></figure>\n\n<p>触发panic错误，这个操作会触发正常的日志打印。主要用于ut层面模拟服务异常</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug restart</span><br><span class=\"line\">debug crash-and-recover</span><br></pre></td></tr></table></figure>\n\n<p>触发重启，如果是 restart 模式，或进行config rewrite 以及 bgsave 操作，否则会直接进行 crash 操作，默认服务故障。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug oom</span><br></pre></td></tr></table></figure>\n\n<p>触发oom，这样主要是通过 zmalloc 申请一个 ULONG_MAX 大小的空间。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug assert</span><br></pre></td></tr></table></figure>\n\n<p>触发 assert 失败操作，在整个 Redis 逻辑里面，会有各种的 assert 判断，当前操作主要是尝试触发一个 1 == 2 的失败判断，以确定 assert 是否有效。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug leak</span><br></pre></td></tr></table></figure>\n\n<p>触发内存泄露，通过 sdsdup 申请一个泄露的内存空间</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug reload [MERGE|NOFLUSH|NOSAVE]</span><br></pre></td></tr></table></figure>\n\n<p>触发数据重载，其中 NOFLUSH 表示不清空原有数据，NOSAVE 表示不保存原有数据到 rdb 文件中，而 MERGE 表示尝试把数据进行加载合并</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug loadaof</span><br></pre></td></tr></table></figure>\n\n<p>触发 aof 加载，其中会进行数据清空，并重新从 aof 文件中加载数据。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug drop-cluster-packet-filter</span><br></pre></td></tr></table></figure>\n\n<p>设置 cluster 模式下的包过滤类型。模拟丢包的情况。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug sleep &lt;sec&gt;</span><br></pre></td></tr></table></figure>\n\n<p>休眠 sec 秒，支持double类型。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug replicate &lt;argv...&gt;</span><br></pre></td></tr></table></figure>\n\n<p>人工触发一次命令传播，容易导致主从同步异常。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug change-repl-id</span><br></pre></td></tr></table></figure>\n\n<p>重置 replid 信息，主要用于触发全量同步。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug pause-cron &lt;enable&gt;</span><br></pre></td></tr></table></figure>\n\n<p>暂停 cron 操作，模拟 cron 时间过长</p>\n<h3 id=\"测试操作\"><a href=\"#测试操作\" class=\"headerlink\" title=\"测试操作\"></a>测试操作</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug populate &lt;keys&gt; &lt;tag&gt; &lt;num&gt;</span><br></pre></td></tr></table></figure>\n\n<p>模拟生成数据操作，其中会生成 keys 个带有 tag 的数据，每个的长度为 num。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug digest</span><br></pre></td></tr></table></figure>\n\n<p>计算db中的快照信息，输出一个32位的字符串，当前方法是一个扫描全表的操作，风险极高。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug digest-value &lt;key...&gt;</span><br></pre></td></tr></table></figure>\n\n<p>计算相关 key 的快照信息，每个 key 都输出一个32位的字符串</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug protocol [string|integer|double|bignum|null|array|set|map| attrib|push|verbatim|true|false]</span><br></pre></td></tr></table></figure>\n\n<p>测试当前的协议情况</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug stringmatch-test</span><br></pre></td></tr></table></figure>\n\n<p>进行字符串的模糊测试操作：<code>stringmatchlen_fuzz_test</code></p>\n<h3 id=\"后台操作\"><a href=\"#后台操作\" class=\"headerlink\" title=\"后台操作\"></a>后台操作</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug set-active-expire &lt;enable&gt;</span><br></pre></td></tr></table></figure>\n\n<p>设置当前 expire 操作是否打开，用于避免触发过期操作引起的数据变化</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug quicklist-packed-threshold &lt;threshold&gt;</span><br></pre></td></tr></table></figure>\n\n<p>设置 quicklist 的打包阈值</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug set-skip-checksum-validation &lt;enable&gt;</span><br></pre></td></tr></table></figure>\n\n<p>设置是否需要跳过 rdb 的 sum 检查操作。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug aof-flush-sleep &lt;num&gt;</span><br></pre></td></tr></table></figure>\n\n<p>设置 aof flush 的等待时间</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug config-rewrite-force-all</span><br></pre></td></tr></table></figure>\n\n<p>强制 rewrite 所有配置信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug set-disable-deny-scripts &lt;enable&gt;</span><br></pre></td></tr></table></figure>\n\n<p>禁止脚本中嵌套脚本操作</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug mallctl &lt;argv&gt;</span><br><span class=\"line\">debug mallctl-str &lt;argv&gt;</span><br></pre></td></tr></table></figure>\n\n<p>读取当前 jemalloc 的信息，用于定位内存问题</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">debug replybuffer &lt;peak-reset-time &lt;never|reset|&lt;time&gt; | resizing &gt;</span><br></pre></td></tr></table></figure>\n\n<p>是否打开 客户端 buffer 的内存清理能力。</p>\n"},{"title":"Redis的日志管理与复制","abbrlink":48988,"date":"2023-01-02T11:53:33.000Z","_content":"\n## 日志复制队列\n\n日志复制过程中，需要一个单独的队列来存储实际的日志信息。Redis中单独声明了replBacklog对象来保存：\n\n```\ntypedef struct replBacklog {\n    listNode *ref_repl_buf_node; /* Referenced node of replication buffer blocks,\n                                  * see the definition of replBufBlock. */\n    size_t unindexed_count;      /* The count from last creating index block. */\n    rax *blocks_index;           /* The index of recorded blocks of replication\n                                  * buffer for quickly searching replication\n                                  * offset on partial resynchronization. */\n    long long histlen;           /* Backlog actual data length */\n    long long offset;            /* Replication \"master offset\" of first\n                                  * byte in the replication backlog buffer.*/\n} replBacklog;\n```\n\nhistlen和offset分别代表当前的backlog长度以及相关的偏移量信息。\n\nref_repl_buf_node和blocks_index则专门指向backlog的数据。\n\n整个backLog对象是通过独立的Block来存储日志信息，其实的管理通过单独的list字段 *repl_buffer_blocks* 来管理，同时通过rax树来记录offset和block的关系，以提高遍历速度：\n\n```\ntypedef struct replBufBlock {\n    int refcount;           /* Number of replicas or repl backlog using. */\n    long long id;           /* The unique incremental number. */\n    long long repl_offset;  /* Start replication offset of the block. */\n    size_t size, used;\n    char buf[];\n} replBufBlock;\n```\n\n### 日志复制流程\n\nRedis中的日志是通过command来传播。最终会形成字节流并通过feedReplicationBuffer方法写入给各个replica的缓冲区。\n\n整个缓冲区是由多个black构成，整个block的大小取决于PROTO_REPLY_CHUNK_BYTES（16K）和实际写入的长度len：\n\n```\nsize_t size = (len < PROTO_REPLY_CHUNK_BYTES) ? PROTO_REPLY_CHUNK_BYTES : len;\ntail = zmalloc_usable(size + sizeof(replBufBlock), &usable_size);\n```\n\n若最后节点中的空闲空间足够，则不会单独申请空间。\n\n新block加入后，会写入到各个slave的ref_repl_buf_node字段中，以表示当前需要复制的日志节点，同时会自增refcount，表示有节点在使用当前的block，不可被清理。\n\n同时为了提高整个缓冲区的遍历速度，每64个block对象时，会写入一个index给replBacklog.blocks_index对象。同时，每次写入后，也会对整个backLog缓冲区进行清理，避免实际占有的空间过大。而一般的缓冲区大小限制值为1MB空间。\n\n### 日志定位流程\n\n在进行增量同步时，master会检查当前的offset是否满足增量同步。假定在满足条件的情况下，master就需要通过rax来快速定位实际的block对象，并写入给replica的缓冲区中。\n\n```\n\traxStart(&ri, server.repl_backlog->blocks_index);\n\traxSeek(&ri, \">\", (unsigned char*)&encoded_offset, sizeof(uint64_t));\n```\n\n主要是定位到大于offset的block node，并找到前置的node信息。而后，会从此node开始遍历，定位到实际的offset所在的node，设置为需要复制的数据。\n```\n\t/* Install a writer handler first.*/\n\tprepareClientToWrite(c);\n\t/* Setting output buffer of the replica. */\n\treplBufBlock *o = listNodeValue(node);\n\to->refcount++;\n\tc->ref_repl_buf_node = node;\n\tc->ref_block_pos = offset - o->repl_offset;\n```\n\n完成实际node的设置后，eventLoop将会调用writeToClient方法进行写入操作。\n\n1. 针对未写完的block对象 (o->used > c->ref_block_pos)，则会继续写入。\n2. 针对已写完的block对象就会直接找到下一个node，并重置写入的偏移量，以及尝试清理backLog空间。\n\n## 日志复制链\n\n说完单个节点上的缓冲区管理，整个副本维持的复制链模式还需要单独描述。由于主从关系存在级联的情况，在一整个复制链上，server需要拉齐整个offset的信息，以支持后续的HA操作。\n\n### Replica的偏移信息\n\n对于Master来说，在整个复制过程中，需要记录当前的Replica的复制情况。此时则需要多个字段来管理：\n\n```\n    long long read_reploff; /* Read replication offset if this is a master. */\n    long long reploff;      /* Applied replication offset if this is a master. */\n    long long repl_applied; /* Applied replication data count in querybuf, if this is a replica. */\n    long long repl_ack_off; /* Replication ack offset, if this is a slave. */\n    long long repl_ack_time;/* Replication ack time, if this is a slave. */\n    long long psync_initial_offset; /* FULLRESYNC reply offset other slaves\n                                       copying this slave output buffer\n                                       should use. */\n```\n\n字段解释如下：\n\n- read_reploff：当前已读的偏移量\n- reploff：当前已执行的偏移量\n- repl_applied：当前已写入的偏移量\n- repl_ack_off：slave同步过来的offset\n- repl_ack_time：slave同步的时间\n- psync_initial_offset：当前slave使用的offset，在全量同步时用于定位缓冲区\n\n前三者共同构建了replica在接收到master数据后的处理流程，以及决定当前的buffer是否已经失效。repl_applied是在Redis7后加入，具体原因参考：[optimize(remove) usage of client's pending\\_querybuf by soloestoy · Pull Request #10413 · redis/redis](https://github.com/redis/redis/pull/10413)\n\n而后三者主要是master中用于判断replica的信息，包括是否在线、数据是否同步成功、当前同步的数据信息等。\n\n### Master的偏移信息\n\n介绍完replica的偏移信息，还需要从master视角来确定偏移信息的表示。整个master侧的信息主要集中在 master_repl_offset 变量。\n\n在全量同步完成后，master会发送offset给replica：\n```\n+FULLRESYNC <replid> <offset>\n```\n\n此时，replica会将其写入master_initial_offset变量中，当前变量则会赋予 master->reploff 和 master->read_reploff，这样也保证了reploff、read_reploff、master_repl_offset三者长时间的一致性。\n\n同时，在数据加载阶段，master_repl_offset将从rdb文件中读取出来原有的repl_offset信息，并同时设置给backlog->offset。\n\n在日志复制过程中，会对master_repl_offset进行累加。所以，在master和replica之间，也是通过rdb+log的方式来保证offset的正确性。","source":"_posts/Redis的日志管理与复制.md","raw":"---\ntitle: Redis的日志管理与复制\nabbrlink: 48988\ndate: 2023-01-02 19:53:33\ntags:\n---\n\n## 日志复制队列\n\n日志复制过程中，需要一个单独的队列来存储实际的日志信息。Redis中单独声明了replBacklog对象来保存：\n\n```\ntypedef struct replBacklog {\n    listNode *ref_repl_buf_node; /* Referenced node of replication buffer blocks,\n                                  * see the definition of replBufBlock. */\n    size_t unindexed_count;      /* The count from last creating index block. */\n    rax *blocks_index;           /* The index of recorded blocks of replication\n                                  * buffer for quickly searching replication\n                                  * offset on partial resynchronization. */\n    long long histlen;           /* Backlog actual data length */\n    long long offset;            /* Replication \"master offset\" of first\n                                  * byte in the replication backlog buffer.*/\n} replBacklog;\n```\n\nhistlen和offset分别代表当前的backlog长度以及相关的偏移量信息。\n\nref_repl_buf_node和blocks_index则专门指向backlog的数据。\n\n整个backLog对象是通过独立的Block来存储日志信息，其实的管理通过单独的list字段 *repl_buffer_blocks* 来管理，同时通过rax树来记录offset和block的关系，以提高遍历速度：\n\n```\ntypedef struct replBufBlock {\n    int refcount;           /* Number of replicas or repl backlog using. */\n    long long id;           /* The unique incremental number. */\n    long long repl_offset;  /* Start replication offset of the block. */\n    size_t size, used;\n    char buf[];\n} replBufBlock;\n```\n\n### 日志复制流程\n\nRedis中的日志是通过command来传播。最终会形成字节流并通过feedReplicationBuffer方法写入给各个replica的缓冲区。\n\n整个缓冲区是由多个black构成，整个block的大小取决于PROTO_REPLY_CHUNK_BYTES（16K）和实际写入的长度len：\n\n```\nsize_t size = (len < PROTO_REPLY_CHUNK_BYTES) ? PROTO_REPLY_CHUNK_BYTES : len;\ntail = zmalloc_usable(size + sizeof(replBufBlock), &usable_size);\n```\n\n若最后节点中的空闲空间足够，则不会单独申请空间。\n\n新block加入后，会写入到各个slave的ref_repl_buf_node字段中，以表示当前需要复制的日志节点，同时会自增refcount，表示有节点在使用当前的block，不可被清理。\n\n同时为了提高整个缓冲区的遍历速度，每64个block对象时，会写入一个index给replBacklog.blocks_index对象。同时，每次写入后，也会对整个backLog缓冲区进行清理，避免实际占有的空间过大。而一般的缓冲区大小限制值为1MB空间。\n\n### 日志定位流程\n\n在进行增量同步时，master会检查当前的offset是否满足增量同步。假定在满足条件的情况下，master就需要通过rax来快速定位实际的block对象，并写入给replica的缓冲区中。\n\n```\n\traxStart(&ri, server.repl_backlog->blocks_index);\n\traxSeek(&ri, \">\", (unsigned char*)&encoded_offset, sizeof(uint64_t));\n```\n\n主要是定位到大于offset的block node，并找到前置的node信息。而后，会从此node开始遍历，定位到实际的offset所在的node，设置为需要复制的数据。\n```\n\t/* Install a writer handler first.*/\n\tprepareClientToWrite(c);\n\t/* Setting output buffer of the replica. */\n\treplBufBlock *o = listNodeValue(node);\n\to->refcount++;\n\tc->ref_repl_buf_node = node;\n\tc->ref_block_pos = offset - o->repl_offset;\n```\n\n完成实际node的设置后，eventLoop将会调用writeToClient方法进行写入操作。\n\n1. 针对未写完的block对象 (o->used > c->ref_block_pos)，则会继续写入。\n2. 针对已写完的block对象就会直接找到下一个node，并重置写入的偏移量，以及尝试清理backLog空间。\n\n## 日志复制链\n\n说完单个节点上的缓冲区管理，整个副本维持的复制链模式还需要单独描述。由于主从关系存在级联的情况，在一整个复制链上，server需要拉齐整个offset的信息，以支持后续的HA操作。\n\n### Replica的偏移信息\n\n对于Master来说，在整个复制过程中，需要记录当前的Replica的复制情况。此时则需要多个字段来管理：\n\n```\n    long long read_reploff; /* Read replication offset if this is a master. */\n    long long reploff;      /* Applied replication offset if this is a master. */\n    long long repl_applied; /* Applied replication data count in querybuf, if this is a replica. */\n    long long repl_ack_off; /* Replication ack offset, if this is a slave. */\n    long long repl_ack_time;/* Replication ack time, if this is a slave. */\n    long long psync_initial_offset; /* FULLRESYNC reply offset other slaves\n                                       copying this slave output buffer\n                                       should use. */\n```\n\n字段解释如下：\n\n- read_reploff：当前已读的偏移量\n- reploff：当前已执行的偏移量\n- repl_applied：当前已写入的偏移量\n- repl_ack_off：slave同步过来的offset\n- repl_ack_time：slave同步的时间\n- psync_initial_offset：当前slave使用的offset，在全量同步时用于定位缓冲区\n\n前三者共同构建了replica在接收到master数据后的处理流程，以及决定当前的buffer是否已经失效。repl_applied是在Redis7后加入，具体原因参考：[optimize(remove) usage of client's pending\\_querybuf by soloestoy · Pull Request #10413 · redis/redis](https://github.com/redis/redis/pull/10413)\n\n而后三者主要是master中用于判断replica的信息，包括是否在线、数据是否同步成功、当前同步的数据信息等。\n\n### Master的偏移信息\n\n介绍完replica的偏移信息，还需要从master视角来确定偏移信息的表示。整个master侧的信息主要集中在 master_repl_offset 变量。\n\n在全量同步完成后，master会发送offset给replica：\n```\n+FULLRESYNC <replid> <offset>\n```\n\n此时，replica会将其写入master_initial_offset变量中，当前变量则会赋予 master->reploff 和 master->read_reploff，这样也保证了reploff、read_reploff、master_repl_offset三者长时间的一致性。\n\n同时，在数据加载阶段，master_repl_offset将从rdb文件中读取出来原有的repl_offset信息，并同时设置给backlog->offset。\n\n在日志复制过程中，会对master_repl_offset进行累加。所以，在master和replica之间，也是通过rdb+log的方式来保证offset的正确性。","slug":"Redis的日志管理与复制","published":1,"updated":"2023-01-02T13:52:47.926Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clf3c2gcy000a4cuqcpic9kco","content":"<h2 id=\"日志复制队列\"><a href=\"#日志复制队列\" class=\"headerlink\" title=\"日志复制队列\"></a>日志复制队列</h2><p>日志复制过程中，需要一个单独的队列来存储实际的日志信息。Redis中单独声明了replBacklog对象来保存：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef struct replBacklog &#123;</span><br><span class=\"line\">    listNode *ref_repl_buf_node; /* Referenced node of replication buffer blocks,</span><br><span class=\"line\">                                  * see the definition of replBufBlock. */</span><br><span class=\"line\">    size_t unindexed_count;      /* The count from last creating index block. */</span><br><span class=\"line\">    rax *blocks_index;           /* The index of recorded blocks of replication</span><br><span class=\"line\">                                  * buffer for quickly searching replication</span><br><span class=\"line\">                                  * offset on partial resynchronization. */</span><br><span class=\"line\">    long long histlen;           /* Backlog actual data length */</span><br><span class=\"line\">    long long offset;            /* Replication &quot;master offset&quot; of first</span><br><span class=\"line\">                                  * byte in the replication backlog buffer.*/</span><br><span class=\"line\">&#125; replBacklog;</span><br></pre></td></tr></table></figure>\n\n<p>histlen和offset分别代表当前的backlog长度以及相关的偏移量信息。</p>\n<p>ref_repl_buf_node和blocks_index则专门指向backlog的数据。</p>\n<p>整个backLog对象是通过独立的Block来存储日志信息，其实的管理通过单独的list字段 <em>repl_buffer_blocks</em> 来管理，同时通过rax树来记录offset和block的关系，以提高遍历速度：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef struct replBufBlock &#123;</span><br><span class=\"line\">    int refcount;           /* Number of replicas or repl backlog using. */</span><br><span class=\"line\">    long long id;           /* The unique incremental number. */</span><br><span class=\"line\">    long long repl_offset;  /* Start replication offset of the block. */</span><br><span class=\"line\">    size_t size, used;</span><br><span class=\"line\">    char buf[];</span><br><span class=\"line\">&#125; replBufBlock;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"日志复制流程\"><a href=\"#日志复制流程\" class=\"headerlink\" title=\"日志复制流程\"></a>日志复制流程</h3><p>Redis中的日志是通过command来传播。最终会形成字节流并通过feedReplicationBuffer方法写入给各个replica的缓冲区。</p>\n<p>整个缓冲区是由多个black构成，整个block的大小取决于PROTO_REPLY_CHUNK_BYTES（16K）和实际写入的长度len：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">size_t size = (len &lt; PROTO_REPLY_CHUNK_BYTES) ? PROTO_REPLY_CHUNK_BYTES : len;</span><br><span class=\"line\">tail = zmalloc_usable(size + sizeof(replBufBlock), &amp;usable_size);</span><br></pre></td></tr></table></figure>\n\n<p>若最后节点中的空闲空间足够，则不会单独申请空间。</p>\n<p>新block加入后，会写入到各个slave的ref_repl_buf_node字段中，以表示当前需要复制的日志节点，同时会自增refcount，表示有节点在使用当前的block，不可被清理。</p>\n<p>同时为了提高整个缓冲区的遍历速度，每64个block对象时，会写入一个index给replBacklog.blocks_index对象。同时，每次写入后，也会对整个backLog缓冲区进行清理，避免实际占有的空间过大。而一般的缓冲区大小限制值为1MB空间。</p>\n<h3 id=\"日志定位流程\"><a href=\"#日志定位流程\" class=\"headerlink\" title=\"日志定位流程\"></a>日志定位流程</h3><p>在进行增量同步时，master会检查当前的offset是否满足增量同步。假定在满足条件的情况下，master就需要通过rax来快速定位实际的block对象，并写入给replica的缓冲区中。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">raxStart(&amp;ri, server.repl_backlog-&gt;blocks_index);</span><br><span class=\"line\">raxSeek(&amp;ri, &quot;&gt;&quot;, (unsigned char*)&amp;encoded_offset, sizeof(uint64_t));</span><br></pre></td></tr></table></figure>\n\n<p>主要是定位到大于offset的block node，并找到前置的node信息。而后，会从此node开始遍历，定位到实际的offset所在的node，设置为需要复制的数据。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* Install a writer handler first.*/</span><br><span class=\"line\">prepareClientToWrite(c);</span><br><span class=\"line\">/* Setting output buffer of the replica. */</span><br><span class=\"line\">replBufBlock *o = listNodeValue(node);</span><br><span class=\"line\">o-&gt;refcount++;</span><br><span class=\"line\">c-&gt;ref_repl_buf_node = node;</span><br><span class=\"line\">c-&gt;ref_block_pos = offset - o-&gt;repl_offset;</span><br></pre></td></tr></table></figure>\n\n<p>完成实际node的设置后，eventLoop将会调用writeToClient方法进行写入操作。</p>\n<ol>\n<li>针对未写完的block对象 (o-&gt;used &gt; c-&gt;ref_block_pos)，则会继续写入。</li>\n<li>针对已写完的block对象就会直接找到下一个node，并重置写入的偏移量，以及尝试清理backLog空间。</li>\n</ol>\n<h2 id=\"日志复制链\"><a href=\"#日志复制链\" class=\"headerlink\" title=\"日志复制链\"></a>日志复制链</h2><p>说完单个节点上的缓冲区管理，整个副本维持的复制链模式还需要单独描述。由于主从关系存在级联的情况，在一整个复制链上，server需要拉齐整个offset的信息，以支持后续的HA操作。</p>\n<h3 id=\"Replica的偏移信息\"><a href=\"#Replica的偏移信息\" class=\"headerlink\" title=\"Replica的偏移信息\"></a>Replica的偏移信息</h3><p>对于Master来说，在整个复制过程中，需要记录当前的Replica的复制情况。此时则需要多个字段来管理：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">long long read_reploff; /* Read replication offset if this is a master. */</span><br><span class=\"line\">long long reploff;      /* Applied replication offset if this is a master. */</span><br><span class=\"line\">long long repl_applied; /* Applied replication data count in querybuf, if this is a replica. */</span><br><span class=\"line\">long long repl_ack_off; /* Replication ack offset, if this is a slave. */</span><br><span class=\"line\">long long repl_ack_time;/* Replication ack time, if this is a slave. */</span><br><span class=\"line\">long long psync_initial_offset; /* FULLRESYNC reply offset other slaves</span><br><span class=\"line\">                                   copying this slave output buffer</span><br><span class=\"line\">                                   should use. */</span><br></pre></td></tr></table></figure>\n\n<p>字段解释如下：</p>\n<ul>\n<li>read_reploff：当前已读的偏移量</li>\n<li>reploff：当前已执行的偏移量</li>\n<li>repl_applied：当前已写入的偏移量</li>\n<li>repl_ack_off：slave同步过来的offset</li>\n<li>repl_ack_time：slave同步的时间</li>\n<li>psync_initial_offset：当前slave使用的offset，在全量同步时用于定位缓冲区</li>\n</ul>\n<p>前三者共同构建了replica在接收到master数据后的处理流程，以及决定当前的buffer是否已经失效。repl_applied是在Redis7后加入，具体原因参考：<a href=\"https://github.com/redis/redis/pull/10413\">optimize(remove) usage of client’s pending_querybuf by soloestoy · Pull Request #10413 · redis/redis</a></p>\n<p>而后三者主要是master中用于判断replica的信息，包括是否在线、数据是否同步成功、当前同步的数据信息等。</p>\n<h3 id=\"Master的偏移信息\"><a href=\"#Master的偏移信息\" class=\"headerlink\" title=\"Master的偏移信息\"></a>Master的偏移信息</h3><p>介绍完replica的偏移信息，还需要从master视角来确定偏移信息的表示。整个master侧的信息主要集中在 master_repl_offset 变量。</p>\n<p>在全量同步完成后，master会发送offset给replica：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+FULLRESYNC &lt;replid&gt; &lt;offset&gt;</span><br></pre></td></tr></table></figure>\n\n<p>此时，replica会将其写入master_initial_offset变量中，当前变量则会赋予 master-&gt;reploff 和 master-&gt;read_reploff，这样也保证了reploff、read_reploff、master_repl_offset三者长时间的一致性。</p>\n<p>同时，在数据加载阶段，master_repl_offset将从rdb文件中读取出来原有的repl_offset信息，并同时设置给backlog-&gt;offset。</p>\n<p>在日志复制过程中，会对master_repl_offset进行累加。所以，在master和replica之间，也是通过rdb+log的方式来保证offset的正确性。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"日志复制队列\"><a href=\"#日志复制队列\" class=\"headerlink\" title=\"日志复制队列\"></a>日志复制队列</h2><p>日志复制过程中，需要一个单独的队列来存储实际的日志信息。Redis中单独声明了replBacklog对象来保存：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef struct replBacklog &#123;</span><br><span class=\"line\">    listNode *ref_repl_buf_node; /* Referenced node of replication buffer blocks,</span><br><span class=\"line\">                                  * see the definition of replBufBlock. */</span><br><span class=\"line\">    size_t unindexed_count;      /* The count from last creating index block. */</span><br><span class=\"line\">    rax *blocks_index;           /* The index of recorded blocks of replication</span><br><span class=\"line\">                                  * buffer for quickly searching replication</span><br><span class=\"line\">                                  * offset on partial resynchronization. */</span><br><span class=\"line\">    long long histlen;           /* Backlog actual data length */</span><br><span class=\"line\">    long long offset;            /* Replication &quot;master offset&quot; of first</span><br><span class=\"line\">                                  * byte in the replication backlog buffer.*/</span><br><span class=\"line\">&#125; replBacklog;</span><br></pre></td></tr></table></figure>\n\n<p>histlen和offset分别代表当前的backlog长度以及相关的偏移量信息。</p>\n<p>ref_repl_buf_node和blocks_index则专门指向backlog的数据。</p>\n<p>整个backLog对象是通过独立的Block来存储日志信息，其实的管理通过单独的list字段 <em>repl_buffer_blocks</em> 来管理，同时通过rax树来记录offset和block的关系，以提高遍历速度：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef struct replBufBlock &#123;</span><br><span class=\"line\">    int refcount;           /* Number of replicas or repl backlog using. */</span><br><span class=\"line\">    long long id;           /* The unique incremental number. */</span><br><span class=\"line\">    long long repl_offset;  /* Start replication offset of the block. */</span><br><span class=\"line\">    size_t size, used;</span><br><span class=\"line\">    char buf[];</span><br><span class=\"line\">&#125; replBufBlock;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"日志复制流程\"><a href=\"#日志复制流程\" class=\"headerlink\" title=\"日志复制流程\"></a>日志复制流程</h3><p>Redis中的日志是通过command来传播。最终会形成字节流并通过feedReplicationBuffer方法写入给各个replica的缓冲区。</p>\n<p>整个缓冲区是由多个black构成，整个block的大小取决于PROTO_REPLY_CHUNK_BYTES（16K）和实际写入的长度len：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">size_t size = (len &lt; PROTO_REPLY_CHUNK_BYTES) ? PROTO_REPLY_CHUNK_BYTES : len;</span><br><span class=\"line\">tail = zmalloc_usable(size + sizeof(replBufBlock), &amp;usable_size);</span><br></pre></td></tr></table></figure>\n\n<p>若最后节点中的空闲空间足够，则不会单独申请空间。</p>\n<p>新block加入后，会写入到各个slave的ref_repl_buf_node字段中，以表示当前需要复制的日志节点，同时会自增refcount，表示有节点在使用当前的block，不可被清理。</p>\n<p>同时为了提高整个缓冲区的遍历速度，每64个block对象时，会写入一个index给replBacklog.blocks_index对象。同时，每次写入后，也会对整个backLog缓冲区进行清理，避免实际占有的空间过大。而一般的缓冲区大小限制值为1MB空间。</p>\n<h3 id=\"日志定位流程\"><a href=\"#日志定位流程\" class=\"headerlink\" title=\"日志定位流程\"></a>日志定位流程</h3><p>在进行增量同步时，master会检查当前的offset是否满足增量同步。假定在满足条件的情况下，master就需要通过rax来快速定位实际的block对象，并写入给replica的缓冲区中。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">raxStart(&amp;ri, server.repl_backlog-&gt;blocks_index);</span><br><span class=\"line\">raxSeek(&amp;ri, &quot;&gt;&quot;, (unsigned char*)&amp;encoded_offset, sizeof(uint64_t));</span><br></pre></td></tr></table></figure>\n\n<p>主要是定位到大于offset的block node，并找到前置的node信息。而后，会从此node开始遍历，定位到实际的offset所在的node，设置为需要复制的数据。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* Install a writer handler first.*/</span><br><span class=\"line\">prepareClientToWrite(c);</span><br><span class=\"line\">/* Setting output buffer of the replica. */</span><br><span class=\"line\">replBufBlock *o = listNodeValue(node);</span><br><span class=\"line\">o-&gt;refcount++;</span><br><span class=\"line\">c-&gt;ref_repl_buf_node = node;</span><br><span class=\"line\">c-&gt;ref_block_pos = offset - o-&gt;repl_offset;</span><br></pre></td></tr></table></figure>\n\n<p>完成实际node的设置后，eventLoop将会调用writeToClient方法进行写入操作。</p>\n<ol>\n<li>针对未写完的block对象 (o-&gt;used &gt; c-&gt;ref_block_pos)，则会继续写入。</li>\n<li>针对已写完的block对象就会直接找到下一个node，并重置写入的偏移量，以及尝试清理backLog空间。</li>\n</ol>\n<h2 id=\"日志复制链\"><a href=\"#日志复制链\" class=\"headerlink\" title=\"日志复制链\"></a>日志复制链</h2><p>说完单个节点上的缓冲区管理，整个副本维持的复制链模式还需要单独描述。由于主从关系存在级联的情况，在一整个复制链上，server需要拉齐整个offset的信息，以支持后续的HA操作。</p>\n<h3 id=\"Replica的偏移信息\"><a href=\"#Replica的偏移信息\" class=\"headerlink\" title=\"Replica的偏移信息\"></a>Replica的偏移信息</h3><p>对于Master来说，在整个复制过程中，需要记录当前的Replica的复制情况。此时则需要多个字段来管理：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">long long read_reploff; /* Read replication offset if this is a master. */</span><br><span class=\"line\">long long reploff;      /* Applied replication offset if this is a master. */</span><br><span class=\"line\">long long repl_applied; /* Applied replication data count in querybuf, if this is a replica. */</span><br><span class=\"line\">long long repl_ack_off; /* Replication ack offset, if this is a slave. */</span><br><span class=\"line\">long long repl_ack_time;/* Replication ack time, if this is a slave. */</span><br><span class=\"line\">long long psync_initial_offset; /* FULLRESYNC reply offset other slaves</span><br><span class=\"line\">                                   copying this slave output buffer</span><br><span class=\"line\">                                   should use. */</span><br></pre></td></tr></table></figure>\n\n<p>字段解释如下：</p>\n<ul>\n<li>read_reploff：当前已读的偏移量</li>\n<li>reploff：当前已执行的偏移量</li>\n<li>repl_applied：当前已写入的偏移量</li>\n<li>repl_ack_off：slave同步过来的offset</li>\n<li>repl_ack_time：slave同步的时间</li>\n<li>psync_initial_offset：当前slave使用的offset，在全量同步时用于定位缓冲区</li>\n</ul>\n<p>前三者共同构建了replica在接收到master数据后的处理流程，以及决定当前的buffer是否已经失效。repl_applied是在Redis7后加入，具体原因参考：<a href=\"https://github.com/redis/redis/pull/10413\">optimize(remove) usage of client’s pending_querybuf by soloestoy · Pull Request #10413 · redis/redis</a></p>\n<p>而后三者主要是master中用于判断replica的信息，包括是否在线、数据是否同步成功、当前同步的数据信息等。</p>\n<h3 id=\"Master的偏移信息\"><a href=\"#Master的偏移信息\" class=\"headerlink\" title=\"Master的偏移信息\"></a>Master的偏移信息</h3><p>介绍完replica的偏移信息，还需要从master视角来确定偏移信息的表示。整个master侧的信息主要集中在 master_repl_offset 变量。</p>\n<p>在全量同步完成后，master会发送offset给replica：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+FULLRESYNC &lt;replid&gt; &lt;offset&gt;</span><br></pre></td></tr></table></figure>\n\n<p>此时，replica会将其写入master_initial_offset变量中，当前变量则会赋予 master-&gt;reploff 和 master-&gt;read_reploff，这样也保证了reploff、read_reploff、master_repl_offset三者长时间的一致性。</p>\n<p>同时，在数据加载阶段，master_repl_offset将从rdb文件中读取出来原有的repl_offset信息，并同时设置给backlog-&gt;offset。</p>\n<p>在日志复制过程中，会对master_repl_offset进行累加。所以，在master和replica之间，也是通过rdb+log的方式来保证offset的正确性。</p>\n"},{"title":"关于syscheck，Redis需要什么样的服务器","abbrlink":37854,"date":"2023-01-04T14:56:45.000Z","_content":"在Redis7中，支持了对系统的check逻辑，其中就包含了4类检查操作：\n1. slow-clocksource\n2. xen-clocksource\n3. overcommit\n4. THP\n\n今天，我们来一一介绍一下各个检查的功效，一遍不时之需。\n\n## 如何检查\n\n检查的命令不算太麻烦：\n\n```\n./redis-server --check-system\n```\n\n这个命令没有更多的参数，它会一一的对所有的check进行遍历处理。\n\n## slow-clocksource\n\n验证clokcsource实现没有经过系统调用（使用vdso）。通过系统调用检查时间会降低Redis的性能。\n\n### 什么是clocksource\n\nclock source用于为linux内核提供一个时间基线，如果你用linux的date命令获取当前时间，内核会读取当前的clock source，转换并返回合适的时间单位给用户空间。在硬件层，它通常实现为一个由固定时钟频率驱动的计数器，计数器只能单调地增加，直到溢出为止。时钟源是内核计时的基础，系统启动时，内核通过硬件RTC获得当前时间，在这以后，在大多数情况下，内核通过选定的时钟源更新实时时间信息（墙上时间），而不再读取RTC的时间。\n\nclock source 本身也自带不同的类型，其中查看方式如下：\n```\n/sys/devices/system/clocksource/clocksource0/available_clocksource\n/sys/devices/system/clocksource/clocksource0/current_clocksource\n```\n\n前者代码可用的时钟源，而后者代码当前使用的时钟源。\n\n### 如何检查\n\n在 Redis 层面，RD 更关心的是时钟是否可靠。于是，检查逻辑会统计前后的时钟情况，并通过 busy loop 等待足够长的时间（50ms）\n\n```\nif (getrusage(RUSAGE_SELF, &ru_start) != 0)\n\treturn 0;\nif (clock_gettime(CLOCK_MONOTONIC, &ts) < 0) {\n\treturn 0;\n}\nstart_us = (ts.tv_sec * 1000000 + ts.tv_nsec / 1000);\n\t\ntest_time_us = 5 * 1000000 / system_hz;\nwhile (1) {\n\tunsigned long long d;\n\tif (clock_gettime(CLOCK_MONOTONIC, &ts) < 0)\n\t\treturn 0;\n\td = (ts.tv_sec * 1000000 + ts.tv_nsec / 1000) - start_us;\n\tif (d >= test_time_us) break;\n}\nif (getrusage(RUSAGE_SELF, &ru_end) != 0)\n\treturn 0;\n```\n\n\n> CLOCK_MONOTONIC 指的是 monotonic time，而 CLOCK_REALTIME 指的是 wall time。\n> Monotonic time 的字面意思是单调时间，实际上，指的是系统启动之后所流逝的时间，这是由变量 jiffies 来记录的，当系统每次启动时，jiffies 被初始化为 0，在每一个 timer interrupt 到来时，变量 jiffies 就加上 1，因此这个变量代表着系统启动后的流逝 tick 数。jiffies 一定是单调增加的，因为时间不可逆。\n\n如果超过10%的处理时间是在系统调用中，我们可能有低效的时钟源。故认为是存在移除。\n\n## xen-clocksource\n\n这个就比较简单，由于上述已经介绍过了什么是clocksource，所以，此次的测试就是为了避开xen的时钟源。\n\n主要原因是xen虚拟机监控程序的默认时钟源很慢，会影响Redis的性能。这是在基于ec2-xen的实例上测量的。ec2建议对这些实例使用非默认tsc时钟源。\n\n## overcommit\n\n当禁用过度使用内存时，Linux将杀死后台保存的进程。如果我们没有足够的空闲内存来满足当前内存使用量的两倍，即使子进程使用写时复制来减少其实际内存使用量\n\n### 什么是overcommit\n\n我们知道，由于MMU实现了虚拟地址到物理地址的转换，所以我们在申请虚拟地址时往往可以申请一大块内存，这实际上是对资源的有效利用，毕竟只有内存真正被投入使用时（如memset）才会实际分配物理内存，这种允许内存超额commit的机制就是overcommit_memory。\n\n虚拟内存需要物理内存作为支撑，当分配了太多虚拟内存，导致物理内存不够时，就发生了Out Of Memory。这种允许超额commit的机制就是overcommit。\n\nLinux根据参数vm.overcommit_memory设置overcommit：\n\n- 0 ——默认值，启发式overcommit，它允许overcommit，但太明显的overcommit会被拒绝，比如malloc一次性申请的内存大小就超过了系统总内存。\n- 1 ——Always overcommit. 允许overcommit，对内存申请来者不拒。\n- 2 ——不允许overcommit，提交给系统的总地址空间大小不允许超过。\n\n### 检查方式\n\n检查手段这是确定overcommit是否打开：\n```\n/proc/sys/vm/overcommit_memory\n```\n\nRedis是一个吃内存大户，故建议服务能打开 overcommit。\n\n## THP\n\n### 关于 THP\n\n在 Linux 中大页分为两种： Huge pages ( 标准大页 ) 和  Transparent Huge pages( 透明大页 ) 。\n\nHuge pages  是从 Linux Kernel 2.6 后被引入的，目的是通过使用大页内存来取代传统的 4kb 内存页面， 以适应越来越大的系统内存，让操作系统可以支持现代硬件架构的大页面容量功能。\n\nTransparent Huge Pages  缩写  THP ，这个是 RHEL 6 开始引入的一个功能，在 Linux6 上透明大页是默认启用的。\n\n由于 Huge pages 很难手动管理，而且通常需要对代码进行重大的更改才能有效的使用，因此 RHEL 6 开始引入了 Transparent Huge Pages （ THP ）， THP 是一个抽象层，能够自动创建、管理和使用传统大页。\n\n这两者最大的区别在于 :  标准大页管理是预分配的方式，而透明大页管理则是动态分配的方式。\n\n### 检查方式\n\n服务需要确保不总是启用透明的大页面。如果是这样，则会导致写时复制逻辑消耗更多的内存，并降低 fork 期间的性能。\n\n```\ncat /sys/kernel/mm/transparent_hugepage/enabled\n```\n\n其中需要确保配置不为 always。故可以将其修改为 madvise ，表示可以通过madvise 来申请大页面，而非长期打开。\n\n### 关于madvise\n\nmadvise() 函数建议内核，在从 addr 指定的地址开始，长度等于 len 参数值的范围内，该区域的用户虚拟内存应遵循特定的使用模式。内核使用这些信息优化与指定范围关联的资源的处理和维护过程。如果使用 madvise() 函数的程序明确了解其内存访问模式，则使用此函数可以提高系统性能。\n\nmadvise() 函数提供了以下标志，这些标志影响 lgroup 之间线程内存的分配方式：\n\n- MADV_ACCESS_DEFAULT\n此标志将指定范围的内核预期访问模式重置为缺省设置。\n\n- MADV_ACCESS_LWP\n此标志通知内核，移近指定地址范围的下一个 LWP 就是将要访问此范围次数最多的 LWP。内核将相应地为此范围和 LWP 分配内存和其他资源。\n\n- MADV_ACCESS_MANY\n此标志建议内核，许多进程或 LWP 将在系统内随机访问指定的地址范围。内核将相应地为此范围分配内存和其他资源。\n\n## 相关文献\n\n[Linux时间管理之hardware-Bean\\_lee-ChinaUnix博客](http://blog.chinaunix.net/uid-24774106-id-3902906.html)\n[Huge pages (标准大页)和 Transparent Huge pages(透明大页)](https://blog.csdn.net/lihuarongaini/article/details/101298358)","source":"_posts/关于syscheck，Redis需要什么样的服务器.md","raw":"---\ntitle: 关于syscheck，Redis需要什么样的服务器\nabbrlink: 37854\ndate: 2023-01-04 22:56:45\ntags:\n---\n在Redis7中，支持了对系统的check逻辑，其中就包含了4类检查操作：\n1. slow-clocksource\n2. xen-clocksource\n3. overcommit\n4. THP\n\n今天，我们来一一介绍一下各个检查的功效，一遍不时之需。\n\n## 如何检查\n\n检查的命令不算太麻烦：\n\n```\n./redis-server --check-system\n```\n\n这个命令没有更多的参数，它会一一的对所有的check进行遍历处理。\n\n## slow-clocksource\n\n验证clokcsource实现没有经过系统调用（使用vdso）。通过系统调用检查时间会降低Redis的性能。\n\n### 什么是clocksource\n\nclock source用于为linux内核提供一个时间基线，如果你用linux的date命令获取当前时间，内核会读取当前的clock source，转换并返回合适的时间单位给用户空间。在硬件层，它通常实现为一个由固定时钟频率驱动的计数器，计数器只能单调地增加，直到溢出为止。时钟源是内核计时的基础，系统启动时，内核通过硬件RTC获得当前时间，在这以后，在大多数情况下，内核通过选定的时钟源更新实时时间信息（墙上时间），而不再读取RTC的时间。\n\nclock source 本身也自带不同的类型，其中查看方式如下：\n```\n/sys/devices/system/clocksource/clocksource0/available_clocksource\n/sys/devices/system/clocksource/clocksource0/current_clocksource\n```\n\n前者代码可用的时钟源，而后者代码当前使用的时钟源。\n\n### 如何检查\n\n在 Redis 层面，RD 更关心的是时钟是否可靠。于是，检查逻辑会统计前后的时钟情况，并通过 busy loop 等待足够长的时间（50ms）\n\n```\nif (getrusage(RUSAGE_SELF, &ru_start) != 0)\n\treturn 0;\nif (clock_gettime(CLOCK_MONOTONIC, &ts) < 0) {\n\treturn 0;\n}\nstart_us = (ts.tv_sec * 1000000 + ts.tv_nsec / 1000);\n\t\ntest_time_us = 5 * 1000000 / system_hz;\nwhile (1) {\n\tunsigned long long d;\n\tif (clock_gettime(CLOCK_MONOTONIC, &ts) < 0)\n\t\treturn 0;\n\td = (ts.tv_sec * 1000000 + ts.tv_nsec / 1000) - start_us;\n\tif (d >= test_time_us) break;\n}\nif (getrusage(RUSAGE_SELF, &ru_end) != 0)\n\treturn 0;\n```\n\n\n> CLOCK_MONOTONIC 指的是 monotonic time，而 CLOCK_REALTIME 指的是 wall time。\n> Monotonic time 的字面意思是单调时间，实际上，指的是系统启动之后所流逝的时间，这是由变量 jiffies 来记录的，当系统每次启动时，jiffies 被初始化为 0，在每一个 timer interrupt 到来时，变量 jiffies 就加上 1，因此这个变量代表着系统启动后的流逝 tick 数。jiffies 一定是单调增加的，因为时间不可逆。\n\n如果超过10%的处理时间是在系统调用中，我们可能有低效的时钟源。故认为是存在移除。\n\n## xen-clocksource\n\n这个就比较简单，由于上述已经介绍过了什么是clocksource，所以，此次的测试就是为了避开xen的时钟源。\n\n主要原因是xen虚拟机监控程序的默认时钟源很慢，会影响Redis的性能。这是在基于ec2-xen的实例上测量的。ec2建议对这些实例使用非默认tsc时钟源。\n\n## overcommit\n\n当禁用过度使用内存时，Linux将杀死后台保存的进程。如果我们没有足够的空闲内存来满足当前内存使用量的两倍，即使子进程使用写时复制来减少其实际内存使用量\n\n### 什么是overcommit\n\n我们知道，由于MMU实现了虚拟地址到物理地址的转换，所以我们在申请虚拟地址时往往可以申请一大块内存，这实际上是对资源的有效利用，毕竟只有内存真正被投入使用时（如memset）才会实际分配物理内存，这种允许内存超额commit的机制就是overcommit_memory。\n\n虚拟内存需要物理内存作为支撑，当分配了太多虚拟内存，导致物理内存不够时，就发生了Out Of Memory。这种允许超额commit的机制就是overcommit。\n\nLinux根据参数vm.overcommit_memory设置overcommit：\n\n- 0 ——默认值，启发式overcommit，它允许overcommit，但太明显的overcommit会被拒绝，比如malloc一次性申请的内存大小就超过了系统总内存。\n- 1 ——Always overcommit. 允许overcommit，对内存申请来者不拒。\n- 2 ——不允许overcommit，提交给系统的总地址空间大小不允许超过。\n\n### 检查方式\n\n检查手段这是确定overcommit是否打开：\n```\n/proc/sys/vm/overcommit_memory\n```\n\nRedis是一个吃内存大户，故建议服务能打开 overcommit。\n\n## THP\n\n### 关于 THP\n\n在 Linux 中大页分为两种： Huge pages ( 标准大页 ) 和  Transparent Huge pages( 透明大页 ) 。\n\nHuge pages  是从 Linux Kernel 2.6 后被引入的，目的是通过使用大页内存来取代传统的 4kb 内存页面， 以适应越来越大的系统内存，让操作系统可以支持现代硬件架构的大页面容量功能。\n\nTransparent Huge Pages  缩写  THP ，这个是 RHEL 6 开始引入的一个功能，在 Linux6 上透明大页是默认启用的。\n\n由于 Huge pages 很难手动管理，而且通常需要对代码进行重大的更改才能有效的使用，因此 RHEL 6 开始引入了 Transparent Huge Pages （ THP ）， THP 是一个抽象层，能够自动创建、管理和使用传统大页。\n\n这两者最大的区别在于 :  标准大页管理是预分配的方式，而透明大页管理则是动态分配的方式。\n\n### 检查方式\n\n服务需要确保不总是启用透明的大页面。如果是这样，则会导致写时复制逻辑消耗更多的内存，并降低 fork 期间的性能。\n\n```\ncat /sys/kernel/mm/transparent_hugepage/enabled\n```\n\n其中需要确保配置不为 always。故可以将其修改为 madvise ，表示可以通过madvise 来申请大页面，而非长期打开。\n\n### 关于madvise\n\nmadvise() 函数建议内核，在从 addr 指定的地址开始，长度等于 len 参数值的范围内，该区域的用户虚拟内存应遵循特定的使用模式。内核使用这些信息优化与指定范围关联的资源的处理和维护过程。如果使用 madvise() 函数的程序明确了解其内存访问模式，则使用此函数可以提高系统性能。\n\nmadvise() 函数提供了以下标志，这些标志影响 lgroup 之间线程内存的分配方式：\n\n- MADV_ACCESS_DEFAULT\n此标志将指定范围的内核预期访问模式重置为缺省设置。\n\n- MADV_ACCESS_LWP\n此标志通知内核，移近指定地址范围的下一个 LWP 就是将要访问此范围次数最多的 LWP。内核将相应地为此范围和 LWP 分配内存和其他资源。\n\n- MADV_ACCESS_MANY\n此标志建议内核，许多进程或 LWP 将在系统内随机访问指定的地址范围。内核将相应地为此范围分配内存和其他资源。\n\n## 相关文献\n\n[Linux时间管理之hardware-Bean\\_lee-ChinaUnix博客](http://blog.chinaunix.net/uid-24774106-id-3902906.html)\n[Huge pages (标准大页)和 Transparent Huge pages(透明大页)](https://blog.csdn.net/lihuarongaini/article/details/101298358)","slug":"关于syscheck，Redis需要什么样的服务器","published":1,"updated":"2023-01-04T14:58:10.421Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clf3c2gcz000b4cuq83ybe7vf","content":"<p>在Redis7中，支持了对系统的check逻辑，其中就包含了4类检查操作：</p>\n<ol>\n<li>slow-clocksource</li>\n<li>xen-clocksource</li>\n<li>overcommit</li>\n<li>THP</li>\n</ol>\n<p>今天，我们来一一介绍一下各个检查的功效，一遍不时之需。</p>\n<h2 id=\"如何检查\"><a href=\"#如何检查\" class=\"headerlink\" title=\"如何检查\"></a>如何检查</h2><p>检查的命令不算太麻烦：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./redis-server --check-system</span><br></pre></td></tr></table></figure>\n\n<p>这个命令没有更多的参数，它会一一的对所有的check进行遍历处理。</p>\n<h2 id=\"slow-clocksource\"><a href=\"#slow-clocksource\" class=\"headerlink\" title=\"slow-clocksource\"></a>slow-clocksource</h2><p>验证clokcsource实现没有经过系统调用（使用vdso）。通过系统调用检查时间会降低Redis的性能。</p>\n<h3 id=\"什么是clocksource\"><a href=\"#什么是clocksource\" class=\"headerlink\" title=\"什么是clocksource\"></a>什么是clocksource</h3><p>clock source用于为linux内核提供一个时间基线，如果你用linux的date命令获取当前时间，内核会读取当前的clock source，转换并返回合适的时间单位给用户空间。在硬件层，它通常实现为一个由固定时钟频率驱动的计数器，计数器只能单调地增加，直到溢出为止。时钟源是内核计时的基础，系统启动时，内核通过硬件RTC获得当前时间，在这以后，在大多数情况下，内核通过选定的时钟源更新实时时间信息（墙上时间），而不再读取RTC的时间。</p>\n<p>clock source 本身也自带不同的类型，其中查看方式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/sys/devices/system/clocksource/clocksource0/available_clocksource</span><br><span class=\"line\">/sys/devices/system/clocksource/clocksource0/current_clocksource</span><br></pre></td></tr></table></figure>\n\n<p>前者代码可用的时钟源，而后者代码当前使用的时钟源。</p>\n<h3 id=\"如何检查-1\"><a href=\"#如何检查-1\" class=\"headerlink\" title=\"如何检查\"></a>如何检查</h3><p>在 Redis 层面，RD 更关心的是时钟是否可靠。于是，检查逻辑会统计前后的时钟情况，并通过 busy loop 等待足够长的时间（50ms）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (getrusage(RUSAGE_SELF, &amp;ru_start) != 0)</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">if (clock_gettime(CLOCK_MONOTONIC, &amp;ts) &lt; 0) &#123;</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">start_us = (ts.tv_sec * 1000000 + ts.tv_nsec / 1000);</span><br><span class=\"line\">\t</span><br><span class=\"line\">test_time_us = 5 * 1000000 / system_hz;</span><br><span class=\"line\">while (1) &#123;</span><br><span class=\"line\">\tunsigned long long d;</span><br><span class=\"line\">\tif (clock_gettime(CLOCK_MONOTONIC, &amp;ts) &lt; 0)</span><br><span class=\"line\">\t\treturn 0;</span><br><span class=\"line\">\td = (ts.tv_sec * 1000000 + ts.tv_nsec / 1000) - start_us;</span><br><span class=\"line\">\tif (d &gt;= test_time_us) break;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">if (getrusage(RUSAGE_SELF, &amp;ru_end) != 0)</span><br><span class=\"line\">\treturn 0;</span><br></pre></td></tr></table></figure>\n\n\n<blockquote>\n<p>CLOCK_MONOTONIC 指的是 monotonic time，而 CLOCK_REALTIME 指的是 wall time。<br>Monotonic time 的字面意思是单调时间，实际上，指的是系统启动之后所流逝的时间，这是由变量 jiffies 来记录的，当系统每次启动时，jiffies 被初始化为 0，在每一个 timer interrupt 到来时，变量 jiffies 就加上 1，因此这个变量代表着系统启动后的流逝 tick 数。jiffies 一定是单调增加的，因为时间不可逆。</p>\n</blockquote>\n<p>如果超过10%的处理时间是在系统调用中，我们可能有低效的时钟源。故认为是存在移除。</p>\n<h2 id=\"xen-clocksource\"><a href=\"#xen-clocksource\" class=\"headerlink\" title=\"xen-clocksource\"></a>xen-clocksource</h2><p>这个就比较简单，由于上述已经介绍过了什么是clocksource，所以，此次的测试就是为了避开xen的时钟源。</p>\n<p>主要原因是xen虚拟机监控程序的默认时钟源很慢，会影响Redis的性能。这是在基于ec2-xen的实例上测量的。ec2建议对这些实例使用非默认tsc时钟源。</p>\n<h2 id=\"overcommit\"><a href=\"#overcommit\" class=\"headerlink\" title=\"overcommit\"></a>overcommit</h2><p>当禁用过度使用内存时，Linux将杀死后台保存的进程。如果我们没有足够的空闲内存来满足当前内存使用量的两倍，即使子进程使用写时复制来减少其实际内存使用量</p>\n<h3 id=\"什么是overcommit\"><a href=\"#什么是overcommit\" class=\"headerlink\" title=\"什么是overcommit\"></a>什么是overcommit</h3><p>我们知道，由于MMU实现了虚拟地址到物理地址的转换，所以我们在申请虚拟地址时往往可以申请一大块内存，这实际上是对资源的有效利用，毕竟只有内存真正被投入使用时（如memset）才会实际分配物理内存，这种允许内存超额commit的机制就是overcommit_memory。</p>\n<p>虚拟内存需要物理内存作为支撑，当分配了太多虚拟内存，导致物理内存不够时，就发生了Out Of Memory。这种允许超额commit的机制就是overcommit。</p>\n<p>Linux根据参数vm.overcommit_memory设置overcommit：</p>\n<ul>\n<li>0 ——默认值，启发式overcommit，它允许overcommit，但太明显的overcommit会被拒绝，比如malloc一次性申请的内存大小就超过了系统总内存。</li>\n<li>1 ——Always overcommit. 允许overcommit，对内存申请来者不拒。</li>\n<li>2 ——不允许overcommit，提交给系统的总地址空间大小不允许超过。</li>\n</ul>\n<h3 id=\"检查方式\"><a href=\"#检查方式\" class=\"headerlink\" title=\"检查方式\"></a>检查方式</h3><p>检查手段这是确定overcommit是否打开：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/proc/sys/vm/overcommit_memory</span><br></pre></td></tr></table></figure>\n\n<p>Redis是一个吃内存大户，故建议服务能打开 overcommit。</p>\n<h2 id=\"THP\"><a href=\"#THP\" class=\"headerlink\" title=\"THP\"></a>THP</h2><h3 id=\"关于-THP\"><a href=\"#关于-THP\" class=\"headerlink\" title=\"关于 THP\"></a>关于 THP</h3><p>在 Linux 中大页分为两种： Huge pages ( 标准大页 ) 和  Transparent Huge pages( 透明大页 ) 。</p>\n<p>Huge pages  是从 Linux Kernel 2.6 后被引入的，目的是通过使用大页内存来取代传统的 4kb 内存页面， 以适应越来越大的系统内存，让操作系统可以支持现代硬件架构的大页面容量功能。</p>\n<p>Transparent Huge Pages  缩写  THP ，这个是 RHEL 6 开始引入的一个功能，在 Linux6 上透明大页是默认启用的。</p>\n<p>由于 Huge pages 很难手动管理，而且通常需要对代码进行重大的更改才能有效的使用，因此 RHEL 6 开始引入了 Transparent Huge Pages （ THP ）， THP 是一个抽象层，能够自动创建、管理和使用传统大页。</p>\n<p>这两者最大的区别在于 :  标准大页管理是预分配的方式，而透明大页管理则是动态分配的方式。</p>\n<h3 id=\"检查方式-1\"><a href=\"#检查方式-1\" class=\"headerlink\" title=\"检查方式\"></a>检查方式</h3><p>服务需要确保不总是启用透明的大页面。如果是这样，则会导致写时复制逻辑消耗更多的内存，并降低 fork 期间的性能。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat /sys/kernel/mm/transparent_hugepage/enabled</span><br></pre></td></tr></table></figure>\n\n<p>其中需要确保配置不为 always。故可以将其修改为 madvise ，表示可以通过madvise 来申请大页面，而非长期打开。</p>\n<h3 id=\"关于madvise\"><a href=\"#关于madvise\" class=\"headerlink\" title=\"关于madvise\"></a>关于madvise</h3><p>madvise() 函数建议内核，在从 addr 指定的地址开始，长度等于 len 参数值的范围内，该区域的用户虚拟内存应遵循特定的使用模式。内核使用这些信息优化与指定范围关联的资源的处理和维护过程。如果使用 madvise() 函数的程序明确了解其内存访问模式，则使用此函数可以提高系统性能。</p>\n<p>madvise() 函数提供了以下标志，这些标志影响 lgroup 之间线程内存的分配方式：</p>\n<ul>\n<li><p>MADV_ACCESS_DEFAULT<br>此标志将指定范围的内核预期访问模式重置为缺省设置。</p>\n</li>\n<li><p>MADV_ACCESS_LWP<br>此标志通知内核，移近指定地址范围的下一个 LWP 就是将要访问此范围次数最多的 LWP。内核将相应地为此范围和 LWP 分配内存和其他资源。</p>\n</li>\n<li><p>MADV_ACCESS_MANY<br>此标志建议内核，许多进程或 LWP 将在系统内随机访问指定的地址范围。内核将相应地为此范围分配内存和其他资源。</p>\n</li>\n</ul>\n<h2 id=\"相关文献\"><a href=\"#相关文献\" class=\"headerlink\" title=\"相关文献\"></a>相关文献</h2><p><a href=\"http://blog.chinaunix.net/uid-24774106-id-3902906.html\">Linux时间管理之hardware-Bean_lee-ChinaUnix博客</a><br><a href=\"https://blog.csdn.net/lihuarongaini/article/details/101298358\">Huge pages (标准大页)和 Transparent Huge pages(透明大页)</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在Redis7中，支持了对系统的check逻辑，其中就包含了4类检查操作：</p>\n<ol>\n<li>slow-clocksource</li>\n<li>xen-clocksource</li>\n<li>overcommit</li>\n<li>THP</li>\n</ol>\n<p>今天，我们来一一介绍一下各个检查的功效，一遍不时之需。</p>\n<h2 id=\"如何检查\"><a href=\"#如何检查\" class=\"headerlink\" title=\"如何检查\"></a>如何检查</h2><p>检查的命令不算太麻烦：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./redis-server --check-system</span><br></pre></td></tr></table></figure>\n\n<p>这个命令没有更多的参数，它会一一的对所有的check进行遍历处理。</p>\n<h2 id=\"slow-clocksource\"><a href=\"#slow-clocksource\" class=\"headerlink\" title=\"slow-clocksource\"></a>slow-clocksource</h2><p>验证clokcsource实现没有经过系统调用（使用vdso）。通过系统调用检查时间会降低Redis的性能。</p>\n<h3 id=\"什么是clocksource\"><a href=\"#什么是clocksource\" class=\"headerlink\" title=\"什么是clocksource\"></a>什么是clocksource</h3><p>clock source用于为linux内核提供一个时间基线，如果你用linux的date命令获取当前时间，内核会读取当前的clock source，转换并返回合适的时间单位给用户空间。在硬件层，它通常实现为一个由固定时钟频率驱动的计数器，计数器只能单调地增加，直到溢出为止。时钟源是内核计时的基础，系统启动时，内核通过硬件RTC获得当前时间，在这以后，在大多数情况下，内核通过选定的时钟源更新实时时间信息（墙上时间），而不再读取RTC的时间。</p>\n<p>clock source 本身也自带不同的类型，其中查看方式如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/sys/devices/system/clocksource/clocksource0/available_clocksource</span><br><span class=\"line\">/sys/devices/system/clocksource/clocksource0/current_clocksource</span><br></pre></td></tr></table></figure>\n\n<p>前者代码可用的时钟源，而后者代码当前使用的时钟源。</p>\n<h3 id=\"如何检查-1\"><a href=\"#如何检查-1\" class=\"headerlink\" title=\"如何检查\"></a>如何检查</h3><p>在 Redis 层面，RD 更关心的是时钟是否可靠。于是，检查逻辑会统计前后的时钟情况，并通过 busy loop 等待足够长的时间（50ms）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (getrusage(RUSAGE_SELF, &amp;ru_start) != 0)</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">if (clock_gettime(CLOCK_MONOTONIC, &amp;ts) &lt; 0) &#123;</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">start_us = (ts.tv_sec * 1000000 + ts.tv_nsec / 1000);</span><br><span class=\"line\">\t</span><br><span class=\"line\">test_time_us = 5 * 1000000 / system_hz;</span><br><span class=\"line\">while (1) &#123;</span><br><span class=\"line\">\tunsigned long long d;</span><br><span class=\"line\">\tif (clock_gettime(CLOCK_MONOTONIC, &amp;ts) &lt; 0)</span><br><span class=\"line\">\t\treturn 0;</span><br><span class=\"line\">\td = (ts.tv_sec * 1000000 + ts.tv_nsec / 1000) - start_us;</span><br><span class=\"line\">\tif (d &gt;= test_time_us) break;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">if (getrusage(RUSAGE_SELF, &amp;ru_end) != 0)</span><br><span class=\"line\">\treturn 0;</span><br></pre></td></tr></table></figure>\n\n\n<blockquote>\n<p>CLOCK_MONOTONIC 指的是 monotonic time，而 CLOCK_REALTIME 指的是 wall time。<br>Monotonic time 的字面意思是单调时间，实际上，指的是系统启动之后所流逝的时间，这是由变量 jiffies 来记录的，当系统每次启动时，jiffies 被初始化为 0，在每一个 timer interrupt 到来时，变量 jiffies 就加上 1，因此这个变量代表着系统启动后的流逝 tick 数。jiffies 一定是单调增加的，因为时间不可逆。</p>\n</blockquote>\n<p>如果超过10%的处理时间是在系统调用中，我们可能有低效的时钟源。故认为是存在移除。</p>\n<h2 id=\"xen-clocksource\"><a href=\"#xen-clocksource\" class=\"headerlink\" title=\"xen-clocksource\"></a>xen-clocksource</h2><p>这个就比较简单，由于上述已经介绍过了什么是clocksource，所以，此次的测试就是为了避开xen的时钟源。</p>\n<p>主要原因是xen虚拟机监控程序的默认时钟源很慢，会影响Redis的性能。这是在基于ec2-xen的实例上测量的。ec2建议对这些实例使用非默认tsc时钟源。</p>\n<h2 id=\"overcommit\"><a href=\"#overcommit\" class=\"headerlink\" title=\"overcommit\"></a>overcommit</h2><p>当禁用过度使用内存时，Linux将杀死后台保存的进程。如果我们没有足够的空闲内存来满足当前内存使用量的两倍，即使子进程使用写时复制来减少其实际内存使用量</p>\n<h3 id=\"什么是overcommit\"><a href=\"#什么是overcommit\" class=\"headerlink\" title=\"什么是overcommit\"></a>什么是overcommit</h3><p>我们知道，由于MMU实现了虚拟地址到物理地址的转换，所以我们在申请虚拟地址时往往可以申请一大块内存，这实际上是对资源的有效利用，毕竟只有内存真正被投入使用时（如memset）才会实际分配物理内存，这种允许内存超额commit的机制就是overcommit_memory。</p>\n<p>虚拟内存需要物理内存作为支撑，当分配了太多虚拟内存，导致物理内存不够时，就发生了Out Of Memory。这种允许超额commit的机制就是overcommit。</p>\n<p>Linux根据参数vm.overcommit_memory设置overcommit：</p>\n<ul>\n<li>0 ——默认值，启发式overcommit，它允许overcommit，但太明显的overcommit会被拒绝，比如malloc一次性申请的内存大小就超过了系统总内存。</li>\n<li>1 ——Always overcommit. 允许overcommit，对内存申请来者不拒。</li>\n<li>2 ——不允许overcommit，提交给系统的总地址空间大小不允许超过。</li>\n</ul>\n<h3 id=\"检查方式\"><a href=\"#检查方式\" class=\"headerlink\" title=\"检查方式\"></a>检查方式</h3><p>检查手段这是确定overcommit是否打开：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/proc/sys/vm/overcommit_memory</span><br></pre></td></tr></table></figure>\n\n<p>Redis是一个吃内存大户，故建议服务能打开 overcommit。</p>\n<h2 id=\"THP\"><a href=\"#THP\" class=\"headerlink\" title=\"THP\"></a>THP</h2><h3 id=\"关于-THP\"><a href=\"#关于-THP\" class=\"headerlink\" title=\"关于 THP\"></a>关于 THP</h3><p>在 Linux 中大页分为两种： Huge pages ( 标准大页 ) 和  Transparent Huge pages( 透明大页 ) 。</p>\n<p>Huge pages  是从 Linux Kernel 2.6 后被引入的，目的是通过使用大页内存来取代传统的 4kb 内存页面， 以适应越来越大的系统内存，让操作系统可以支持现代硬件架构的大页面容量功能。</p>\n<p>Transparent Huge Pages  缩写  THP ，这个是 RHEL 6 开始引入的一个功能，在 Linux6 上透明大页是默认启用的。</p>\n<p>由于 Huge pages 很难手动管理，而且通常需要对代码进行重大的更改才能有效的使用，因此 RHEL 6 开始引入了 Transparent Huge Pages （ THP ）， THP 是一个抽象层，能够自动创建、管理和使用传统大页。</p>\n<p>这两者最大的区别在于 :  标准大页管理是预分配的方式，而透明大页管理则是动态分配的方式。</p>\n<h3 id=\"检查方式-1\"><a href=\"#检查方式-1\" class=\"headerlink\" title=\"检查方式\"></a>检查方式</h3><p>服务需要确保不总是启用透明的大页面。如果是这样，则会导致写时复制逻辑消耗更多的内存，并降低 fork 期间的性能。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat /sys/kernel/mm/transparent_hugepage/enabled</span><br></pre></td></tr></table></figure>\n\n<p>其中需要确保配置不为 always。故可以将其修改为 madvise ，表示可以通过madvise 来申请大页面，而非长期打开。</p>\n<h3 id=\"关于madvise\"><a href=\"#关于madvise\" class=\"headerlink\" title=\"关于madvise\"></a>关于madvise</h3><p>madvise() 函数建议内核，在从 addr 指定的地址开始，长度等于 len 参数值的范围内，该区域的用户虚拟内存应遵循特定的使用模式。内核使用这些信息优化与指定范围关联的资源的处理和维护过程。如果使用 madvise() 函数的程序明确了解其内存访问模式，则使用此函数可以提高系统性能。</p>\n<p>madvise() 函数提供了以下标志，这些标志影响 lgroup 之间线程内存的分配方式：</p>\n<ul>\n<li><p>MADV_ACCESS_DEFAULT<br>此标志将指定范围的内核预期访问模式重置为缺省设置。</p>\n</li>\n<li><p>MADV_ACCESS_LWP<br>此标志通知内核，移近指定地址范围的下一个 LWP 就是将要访问此范围次数最多的 LWP。内核将相应地为此范围和 LWP 分配内存和其他资源。</p>\n</li>\n<li><p>MADV_ACCESS_MANY<br>此标志建议内核，许多进程或 LWP 将在系统内随机访问指定的地址范围。内核将相应地为此范围分配内存和其他资源。</p>\n</li>\n</ul>\n<h2 id=\"相关文献\"><a href=\"#相关文献\" class=\"headerlink\" title=\"相关文献\"></a>相关文献</h2><p><a href=\"http://blog.chinaunix.net/uid-24774106-id-3902906.html\">Linux时间管理之hardware-Bean_lee-ChinaUnix博客</a><br><a href=\"https://blog.csdn.net/lihuarongaini/article/details/101298358\">Huge pages (标准大页)和 Transparent Huge pages(透明大页)</a></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}