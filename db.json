{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"themes/crisp/source/fonts/BreeSerif-Regular.otf","path":"fonts/BreeSerif-Regular.otf","modified":1,"renderable":1},{"_id":"themes/crisp/source/fonts/BreeSerif-Regular.ttf","path":"fonts/BreeSerif-Regular.ttf","modified":1,"renderable":1},{"_id":"themes/crisp/source/fonts/BreeSerif-Regular.woff2","path":"fonts/BreeSerif-Regular.woff2","modified":1,"renderable":1},{"_id":"themes/crisp/source/fonts/opensans-regular-webfont.eot","path":"fonts/opensans-regular-webfont.eot","modified":1,"renderable":1},{"_id":"themes/crisp/source/fonts/opensans-regular-webfont.svg","path":"fonts/opensans-regular-webfont.svg","modified":1,"renderable":1},{"_id":"themes/crisp/source/fonts/opensans-regular-webfont.woff","path":"fonts/opensans-regular-webfont.woff","modified":1,"renderable":1},{"_id":"themes/crisp/source/js/ga.js","path":"js/ga.js","modified":1,"renderable":1},{"_id":"themes/crisp/source/styles/crisp.css","path":"styles/crisp.css","modified":1,"renderable":1},{"_id":"themes/crisp/source/fonts/opensans-regular-webfont.ttf","path":"fonts/opensans-regular-webfont.ttf","modified":1,"renderable":1}],"Cache":[{"_id":"themes/crisp/.gitignore","hash":"854da42f35444ed19a8164cb7c213f66ae0e178c","modified":1631514916992},{"_id":"themes/crisp/LICENSE","hash":"7bc66e9632b475079619f585722930b551c3c081","modified":1631514916992},{"_id":"themes/crisp/README.md","hash":"5df65fb6d4c854289509f5389e7380ce4b23ce09","modified":1631514916992},{"_id":"themes/crisp/_config.yml","hash":"679e9c83a37ad20b91e53ad8f1bfc71d582a149e","modified":1631514916992},{"_id":"source/_posts/chaos_engineering.md","hash":"a23fe467cd7e8bb50f52eee01c74350963f108af","modified":1628875667496},{"_id":"source/_posts/golang-dispatch.md","hash":"949a260d6a53fd0a1f7e4e96d133e52277e60057","modified":1628875667498},{"_id":"source/_posts/golang-lockg.md","hash":"4c6f1421729d06c7dd2ccb25f0142ff79561815f","modified":1628875667498},{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1628875667498},{"_id":"source/_posts/java-gc-1.md","hash":"5ebf9ab3e1f8f92c386278bd721ce0a82ef269f9","modified":1628875667498},{"_id":"source/_posts/golang-gmp.md","hash":"a4769f920a2c473558173b8957161f808c902cac","modified":1628875667498},{"_id":"source/_posts/java-gc-2.md","hash":"08c60a6aa338c75eb6b029332b0c94fee376c281","modified":1628875667498},{"_id":"source/_posts/level-db-file.md","hash":"9a3957899c9c6aea8d0adf4c91266f6c5f338a06","modified":1628875667498},{"_id":"source/_posts/level-db-read.md","hash":"936b2f2fefecc8429cb14e4f10d2f1bb464e1deb","modified":1628875667499},{"_id":"source/_posts/level-db-chan.md","hash":"c2667bba46b7ace755db8af18e5c10646533bc36","modified":1628875667498},{"_id":"source/_posts/level-db-demo.md","hash":"76827c8461d63ed1fcceec290491713c664e3211","modified":1628875667498},{"_id":"themes/crisp/layout/archive.ejs","hash":"36e89b37f520533bef85fb32b714214257fad1d0","modified":1631514916992},{"_id":"themes/crisp/layout/category.ejs","hash":"36e89b37f520533bef85fb32b714214257fad1d0","modified":1631514916992},{"_id":"themes/crisp/layout/index.ejs","hash":"36e89b37f520533bef85fb32b714214257fad1d0","modified":1631514916993},{"_id":"themes/crisp/layout/layout.ejs","hash":"46ca3eff9492e1dc6830bf5485c21dd0a113b9f8","modified":1631514916993},{"_id":"themes/crisp/layout/page.ejs","hash":"e1c5903079fc342915025cfad9cf9e70a5cd83cc","modified":1631514916993},{"_id":"themes/crisp/layout/post.ejs","hash":"ae761feddc98f4d3260e7591ed9fc91d9a49d0ab","modified":1631514916993},{"_id":"themes/crisp/layout/tag.ejs","hash":"5d8f22da9d3662c647599faaf21f02477432d556","modified":1631514916993},{"_id":"source/_posts/level-db-write.md","hash":"d8adf79a6f761d064832be37a17b42dc7709fada","modified":1628875667499},{"_id":"source/_posts/level-db-start.md","hash":"8e01adfa36ec306aefbcccd6de3b853eb2a72e70","modified":1628875667499},{"_id":"source/_posts/rpc-monitor.md","hash":"966a4410d837c5c1cd6cb113803a6ff125b7a096","modified":1628875667499},{"_id":"source/_posts/golang-gmp/1767848-9c4b06362907280d.webp","hash":"a2d94ed54535836041705f8ca5dc646e8f6fb794","modified":1628875667498},{"_id":"source/_posts/golang-gmp/567399-d400f4b192f3dc48.webp","hash":"174a3c0d3aae5476bdba0db5ea0c918fd462e5e1","modified":1628875667498},{"_id":"themes/crisp/layout/_partial/follow.ejs","hash":"21d54afed53c579fc823382af7f746136d4cf1e8","modified":1631514916992},{"_id":"source/_posts/golang-gmp/3184f3.jpg","hash":"b2c90a1b47cc0bf045ec6b94212ab7c6d9ef4f2d","modified":1628875667498},{"_id":"themes/crisp/layout/_partial/index.ejs","hash":"0cc9becdde690a8b66ae5e1809f0c8bf660840ab","modified":1631514916992},{"_id":"themes/crisp/layout/_partial/page.ejs","hash":"3c4a7f68dcf7c205512069c9da99c9ff9d6ac3ef","modified":1631514916992},{"_id":"themes/crisp/layout/_partial/post.ejs","hash":"6f7a6730c11300af14b9caf451c3ceb8dc810ea3","modified":1631514916992},{"_id":"themes/crisp/source/fonts/BreeSerif-Regular.otf","hash":"f982b73492d5d6c82aa684f6bce894c63f6b2c79","modified":1631514916995},{"_id":"themes/crisp/source/fonts/BreeSerif-Regular.ttf","hash":"9e42f8b3aa1e670934ecaab1a4060a00f17fa2ed","modified":1631514916996},{"_id":"themes/crisp/source/fonts/BreeSerif-Regular.woff2","hash":"9407e77734344a53e33ef703dc40024d941f6280","modified":1631514916996},{"_id":"themes/crisp/source/fonts/opensans-regular-webfont.eot","hash":"606c985eaaef071488c12e5ea0a985d5b545eae7","modified":1631514916996},{"_id":"themes/crisp/source/fonts/opensans-regular-webfont.svg","hash":"dce2b68dd6b6c28b773994e35e4fc3e0e539ffdf","modified":1631514916996},{"_id":"themes/crisp/source/fonts/opensans-regular-webfont.woff","hash":"d6f86451bee7c843a0c23e61995e25927abb176a","modified":1631514916997},{"_id":"themes/crisp/source/js/ga.js","hash":"a96d26c095fac491b4d48a32d60e4ee46a208a19","modified":1631514916997},{"_id":"themes/crisp/source/styles/crisp.css","hash":"5dfff8b3964c633c65f7ba60d2246a3aeab57183","modified":1631514916997},{"_id":"themes/crisp/source/fonts/opensans-regular-webfont.ttf","hash":"6d72a9e751414873228dd1c43ec7b16da1c2a285","modified":1631514916996},{"_id":"themes/crisp/screenshot.png","hash":"d0ea355c7da51f97ae0781f0ccaa7cea3ca6268e","modified":1631514916995},{"_id":"public/2021/08/14/rpc-monitor/index.html","hash":"135582d2edc1c95fe9c3cb0efe1c1d4a7f758dca","modified":1631514947215},{"_id":"public/2021/08/14/level-db-start/index.html","hash":"ceefe191ab0b7af45ad4ac89941b53d207c8b2ac","modified":1631514947215},{"_id":"public/2021/08/14/level-db-write/index.html","hash":"b9971c663025941623c6f7286707aea205850f46","modified":1631514947215},{"_id":"public/2021/08/14/level-db-read/index.html","hash":"0bd64515581ffa839fbd45ae3d0bda9d9c129e9a","modified":1631514947215},{"_id":"public/2021/08/14/java-gc-1/index.html","hash":"c93a0f93f691a45af3ddc8698e306043acf2b26f","modified":1631514947215},{"_id":"public/2021/08/14/level-db-file/index.html","hash":"396c828cfba90e29d3ad0c5d34753ccf0e17c8f3","modified":1631514947215},{"_id":"public/2021/08/14/java-gc-2/index.html","hash":"8d44d6c21ebb817d737cac3dd956b88b1cfa9659","modified":1631514947215},{"_id":"public/2021/08/14/level-db-demo/index.html","hash":"b861093addcaf988da31a7a8d955496f6d9496ae","modified":1631514947215},{"_id":"public/2021/08/14/hello-world/index.html","hash":"5b0319a6e8cdacbf62f37cba9423821c498c3a36","modified":1631514947215},{"_id":"public/2021/08/14/level-db-chan/index.html","hash":"0ac0392f72814f5b685d157cb675833bb98028aa","modified":1631514947215},{"_id":"public/2021/08/14/chaos_engineering/index.html","hash":"2a78873e76a2859fa535408e1c4945ea87f7bd45","modified":1631514947215},{"_id":"public/2020/07/12/golang-lockg/index.html","hash":"b2f4d9322dc3ecb47cfc6615fefccaed780f1f56","modified":1631514947215},{"_id":"public/archives/index.html","hash":"ce9276e0912f6dde315853dc2879c7414d9885ea","modified":1631514947215},{"_id":"public/archives/page/2/index.html","hash":"e1fe8a2eadb26fd92d4452dbb2ce3aee55d415e6","modified":1631514947215},{"_id":"public/archives/2020/index.html","hash":"238f169e4452f693035bebcbb400f8634576ddfa","modified":1631514947215},{"_id":"public/archives/2020/07/index.html","hash":"d08086bca160dc1cd3ca0dd38b24f2da9e146587","modified":1631514947215},{"_id":"public/archives/2021/index.html","hash":"9759e11c5ade72f537cdf74fa1e45216d1ee0171","modified":1631514947215},{"_id":"public/archives/2021/page/2/index.html","hash":"6e2c9f706cdf22ffda59533a2b3d8da3d752b8b1","modified":1631514947215},{"_id":"public/archives/2021/08/index.html","hash":"ae747eb59502d8a8ebecc4a52ee63ad284c8f2e1","modified":1631514947215},{"_id":"public/archives/2021/08/page/2/index.html","hash":"2f59b83fd4701560cb25024608146e74732dcdfd","modified":1631514947215},{"_id":"public/index.html","hash":"ec54f05e8c0b94b39094c427159f7be4e718b12c","modified":1631514947215},{"_id":"public/page/2/index.html","hash":"ba4a6d2d39386967d620c1d686fd912befdedeef","modified":1631514947215},{"_id":"public/2020/07/19/golang-gmp/index.html","hash":"6e8d458dbef36f381b4750872fe8a0199e9331ef","modified":1631514947215},{"_id":"public/2020/07/08/golang-dispatch/index.html","hash":"2c4099cfc3da529fb4888b644933dcf9fe17f5c6","modified":1631514947215},{"_id":"public/fonts/BreeSerif-Regular.otf","hash":"f982b73492d5d6c82aa684f6bce894c63f6b2c79","modified":1631514947215},{"_id":"public/fonts/BreeSerif-Regular.ttf","hash":"9e42f8b3aa1e670934ecaab1a4060a00f17fa2ed","modified":1631514947215},{"_id":"public/fonts/BreeSerif-Regular.woff2","hash":"9407e77734344a53e33ef703dc40024d941f6280","modified":1631514947215},{"_id":"public/fonts/opensans-regular-webfont.eot","hash":"606c985eaaef071488c12e5ea0a985d5b545eae7","modified":1631514947215},{"_id":"public/fonts/opensans-regular-webfont.svg","hash":"dce2b68dd6b6c28b773994e35e4fc3e0e539ffdf","modified":1631514947215},{"_id":"public/fonts/opensans-regular-webfont.woff","hash":"d6f86451bee7c843a0c23e61995e25927abb176a","modified":1631514947215},{"_id":"public/fonts/opensans-regular-webfont.ttf","hash":"6d72a9e751414873228dd1c43ec7b16da1c2a285","modified":1631514947215},{"_id":"public/2020/07/19/golang-gmp/1767848-9c4b06362907280d.webp","hash":"a2d94ed54535836041705f8ca5dc646e8f6fb794","modified":1631514947215},{"_id":"public/2020/07/19/golang-gmp/3184f3.jpg","hash":"b2c90a1b47cc0bf045ec6b94212ab7c6d9ef4f2d","modified":1631514947215},{"_id":"public/2020/07/19/golang-gmp/567399-d400f4b192f3dc48.webp","hash":"174a3c0d3aae5476bdba0db5ea0c918fd462e5e1","modified":1631514947215},{"_id":"public/styles/crisp.css","hash":"5dfff8b3964c633c65f7ba60d2246a3aeab57183","modified":1631514947215},{"_id":"public/js/ga.js","hash":"a96d26c095fac491b4d48a32d60e4ee46a208a19","modified":1631514947215}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"关于混沌工程的理解","_content":"\n## 前言\n\n混沌工程一直在我心中是一个模糊的概念，摘要百度百科的解释：通过一系列可控的实验和执行实验的原则，混沌工程将揭 示出分布式系统中随时发生的各类事件是如何逐步导致系统整体不可用的。\n\n在滴滴内部对应的便是放火系统，其中便有了如何放火、防火、监控等各类方法，以在执行混沌操作时，对线上业务影响最少。\n\n## 概要\n\n混沌工程是一个主动发现系统中脆弱点的整套方法论，所谓方法论，就是关于人们认识世界、改造世界的方法的理论。其目标是提高系统对不确定事件的抵御能力。\n\n但这并非易事，首先所有系统都是足够复杂，这就会导致工程未来演练故障时也需要足够复杂，而在本来复杂的系统中进行改动，这本书就是一个风险极高的事情。\n\n## 背景\n\n时代背景的主要原因是系统架构在逐步演进，从服务集群到分布式系统，开始微服务化、容器化、上云。服务之间开始逐步隔离，而用户需求变更的更加频繁，复杂化、多样性、快速化，促使了版本迭代不断增速：CICD、敏捷开发、devops、ABtest。\n\n所有的变更最终肯定会反映在系统复杂度上的增加，频繁的变更最大的挑战便是稳定性，如何使系统在频繁变更的过程中，继续保持自身的扩展性、稳定性、弹性能力、容错灾备能力，便是当今各公司需要解决的问题。\n\n混沌工程中，最好的手段，便是演练，通过故障注入的方式模拟线上异常，提前预警，避免大规模事故的发现。\n\n## 实施\n\n### 因素\n\n既然是复杂系统的稳定性工具，那还是需要考虑用户在使用稳定性工具时的感受，保证工具拥有可靠性、安全性、可扩展性、可定制化、可伸缩性、可维护性、用户体验等。\n\n### 维度\n\n用故障注入作为手段来实施工程，那我们就需要从系统稳定性开始考虑如何保证影响可控的情况下如何正常开展演练。\n\n1）建立稳定状态的假设（清晰可衡量的指标）\n\n2）用多样的生产事件做验证（多样性降低误差）\n\n3）在生产环境做验证（真实场景）\n\n4）自动化开展实验（持续运行）\n\n5）控制最小化爆炸半径（影响范围）\n\n而，做到这么几点才能保证混沌工程能够正常的推广下去。\n\n### 经验\n\n混沌工程的考虑维度我们已经列出来了。但是如何推广工程又是另外一套方法论，因为如何把事做好本身就是很难的事情。\n\n所以，在做事之前，考虑好影响，提前建立预期，对于混沌工程而言，总会不断的和故障打交道，于是就需要建立面向失败设计和拥抱失败的技术文化，让大家能够接受失败。同时先从简单的场景开始尝试，逐渐增加组织对系统的信心\n\n其实，工程需要一个实施目标，评估整体工程推进的情况，\n\n在前期：需要对历史故障的复现率以及解决率，确保故障改进的有效性；**中期**：提高监控发现率，验证故障发现能力的全面性和监控的完备程度；**后期**：故障的“发现-定位-恢复”市场这种综合性指标；\n\n最终希望是能达到在控制风险的前提下不断提升混沌工程效率https://zhuanlan.zhihu.com/p/354401594)","source":"_posts/chaos_engineering.md","raw":"---\ntitle: 关于混沌工程的理解\n---\n\n## 前言\n\n混沌工程一直在我心中是一个模糊的概念，摘要百度百科的解释：通过一系列可控的实验和执行实验的原则，混沌工程将揭 示出分布式系统中随时发生的各类事件是如何逐步导致系统整体不可用的。\n\n在滴滴内部对应的便是放火系统，其中便有了如何放火、防火、监控等各类方法，以在执行混沌操作时，对线上业务影响最少。\n\n## 概要\n\n混沌工程是一个主动发现系统中脆弱点的整套方法论，所谓方法论，就是关于人们认识世界、改造世界的方法的理论。其目标是提高系统对不确定事件的抵御能力。\n\n但这并非易事，首先所有系统都是足够复杂，这就会导致工程未来演练故障时也需要足够复杂，而在本来复杂的系统中进行改动，这本书就是一个风险极高的事情。\n\n## 背景\n\n时代背景的主要原因是系统架构在逐步演进，从服务集群到分布式系统，开始微服务化、容器化、上云。服务之间开始逐步隔离，而用户需求变更的更加频繁，复杂化、多样性、快速化，促使了版本迭代不断增速：CICD、敏捷开发、devops、ABtest。\n\n所有的变更最终肯定会反映在系统复杂度上的增加，频繁的变更最大的挑战便是稳定性，如何使系统在频繁变更的过程中，继续保持自身的扩展性、稳定性、弹性能力、容错灾备能力，便是当今各公司需要解决的问题。\n\n混沌工程中，最好的手段，便是演练，通过故障注入的方式模拟线上异常，提前预警，避免大规模事故的发现。\n\n## 实施\n\n### 因素\n\n既然是复杂系统的稳定性工具，那还是需要考虑用户在使用稳定性工具时的感受，保证工具拥有可靠性、安全性、可扩展性、可定制化、可伸缩性、可维护性、用户体验等。\n\n### 维度\n\n用故障注入作为手段来实施工程，那我们就需要从系统稳定性开始考虑如何保证影响可控的情况下如何正常开展演练。\n\n1）建立稳定状态的假设（清晰可衡量的指标）\n\n2）用多样的生产事件做验证（多样性降低误差）\n\n3）在生产环境做验证（真实场景）\n\n4）自动化开展实验（持续运行）\n\n5）控制最小化爆炸半径（影响范围）\n\n而，做到这么几点才能保证混沌工程能够正常的推广下去。\n\n### 经验\n\n混沌工程的考虑维度我们已经列出来了。但是如何推广工程又是另外一套方法论，因为如何把事做好本身就是很难的事情。\n\n所以，在做事之前，考虑好影响，提前建立预期，对于混沌工程而言，总会不断的和故障打交道，于是就需要建立面向失败设计和拥抱失败的技术文化，让大家能够接受失败。同时先从简单的场景开始尝试，逐渐增加组织对系统的信心\n\n其实，工程需要一个实施目标，评估整体工程推进的情况，\n\n在前期：需要对历史故障的复现率以及解决率，确保故障改进的有效性；**中期**：提高监控发现率，验证故障发现能力的全面性和监控的完备程度；**后期**：故障的“发现-定位-恢复”市场这种综合性指标；\n\n最终希望是能达到在控制风险的前提下不断提升混沌工程效率https://zhuanlan.zhihu.com/p/354401594)","slug":"chaos_engineering","published":1,"date":"2021-08-13T17:27:47.496Z","updated":"2021-08-13T17:27:47.496Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckti9vicg00009gtj5sjggafd","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>混沌工程一直在我心中是一个模糊的概念，摘要百度百科的解释：通过一系列可控的实验和执行实验的原则，混沌工程将揭 示出分布式系统中随时发生的各类事件是如何逐步导致系统整体不可用的。</p>\n<p>在滴滴内部对应的便是放火系统，其中便有了如何放火、防火、监控等各类方法，以在执行混沌操作时，对线上业务影响最少。</p>\n<h2 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h2><p>混沌工程是一个主动发现系统中脆弱点的整套方法论，所谓方法论，就是关于人们认识世界、改造世界的方法的理论。其目标是提高系统对不确定事件的抵御能力。</p>\n<p>但这并非易事，首先所有系统都是足够复杂，这就会导致工程未来演练故障时也需要足够复杂，而在本来复杂的系统中进行改动，这本书就是一个风险极高的事情。</p>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>时代背景的主要原因是系统架构在逐步演进，从服务集群到分布式系统，开始微服务化、容器化、上云。服务之间开始逐步隔离，而用户需求变更的更加频繁，复杂化、多样性、快速化，促使了版本迭代不断增速：CICD、敏捷开发、devops、ABtest。</p>\n<p>所有的变更最终肯定会反映在系统复杂度上的增加，频繁的变更最大的挑战便是稳定性，如何使系统在频繁变更的过程中，继续保持自身的扩展性、稳定性、弹性能力、容错灾备能力，便是当今各公司需要解决的问题。</p>\n<p>混沌工程中，最好的手段，便是演练，通过故障注入的方式模拟线上异常，提前预警，避免大规模事故的发现。</p>\n<h2 id=\"实施\"><a href=\"#实施\" class=\"headerlink\" title=\"实施\"></a>实施</h2><h3 id=\"因素\"><a href=\"#因素\" class=\"headerlink\" title=\"因素\"></a>因素</h3><p>既然是复杂系统的稳定性工具，那还是需要考虑用户在使用稳定性工具时的感受，保证工具拥有可靠性、安全性、可扩展性、可定制化、可伸缩性、可维护性、用户体验等。</p>\n<h3 id=\"维度\"><a href=\"#维度\" class=\"headerlink\" title=\"维度\"></a>维度</h3><p>用故障注入作为手段来实施工程，那我们就需要从系统稳定性开始考虑如何保证影响可控的情况下如何正常开展演练。</p>\n<p>1）建立稳定状态的假设（清晰可衡量的指标）</p>\n<p>2）用多样的生产事件做验证（多样性降低误差）</p>\n<p>3）在生产环境做验证（真实场景）</p>\n<p>4）自动化开展实验（持续运行）</p>\n<p>5）控制最小化爆炸半径（影响范围）</p>\n<p>而，做到这么几点才能保证混沌工程能够正常的推广下去。</p>\n<h3 id=\"经验\"><a href=\"#经验\" class=\"headerlink\" title=\"经验\"></a>经验</h3><p>混沌工程的考虑维度我们已经列出来了。但是如何推广工程又是另外一套方法论，因为如何把事做好本身就是很难的事情。</p>\n<p>所以，在做事之前，考虑好影响，提前建立预期，对于混沌工程而言，总会不断的和故障打交道，于是就需要建立面向失败设计和拥抱失败的技术文化，让大家能够接受失败。同时先从简单的场景开始尝试，逐渐增加组织对系统的信心</p>\n<p>其实，工程需要一个实施目标，评估整体工程推进的情况，</p>\n<p>在前期：需要对历史故障的复现率以及解决率，确保故障改进的有效性；<strong>中期</strong>：提高监控发现率，验证故障发现能力的全面性和监控的完备程度；<strong>后期</strong>：故障的“发现-定位-恢复”市场这种综合性指标；</p>\n<p>最终希望是能达到在控制风险的前提下不断提升混沌工程效率<a href=\"https://zhuanlan.zhihu.com/p/354401594\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/354401594</a>)</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>混沌工程一直在我心中是一个模糊的概念，摘要百度百科的解释：通过一系列可控的实验和执行实验的原则，混沌工程将揭 示出分布式系统中随时发生的各类事件是如何逐步导致系统整体不可用的。</p>\n<p>在滴滴内部对应的便是放火系统，其中便有了如何放火、防火、监控等各类方法，以在执行混沌操作时，对线上业务影响最少。</p>\n<h2 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h2><p>混沌工程是一个主动发现系统中脆弱点的整套方法论，所谓方法论，就是关于人们认识世界、改造世界的方法的理论。其目标是提高系统对不确定事件的抵御能力。</p>\n<p>但这并非易事，首先所有系统都是足够复杂，这就会导致工程未来演练故障时也需要足够复杂，而在本来复杂的系统中进行改动，这本书就是一个风险极高的事情。</p>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>时代背景的主要原因是系统架构在逐步演进，从服务集群到分布式系统，开始微服务化、容器化、上云。服务之间开始逐步隔离，而用户需求变更的更加频繁，复杂化、多样性、快速化，促使了版本迭代不断增速：CICD、敏捷开发、devops、ABtest。</p>\n<p>所有的变更最终肯定会反映在系统复杂度上的增加，频繁的变更最大的挑战便是稳定性，如何使系统在频繁变更的过程中，继续保持自身的扩展性、稳定性、弹性能力、容错灾备能力，便是当今各公司需要解决的问题。</p>\n<p>混沌工程中，最好的手段，便是演练，通过故障注入的方式模拟线上异常，提前预警，避免大规模事故的发现。</p>\n<h2 id=\"实施\"><a href=\"#实施\" class=\"headerlink\" title=\"实施\"></a>实施</h2><h3 id=\"因素\"><a href=\"#因素\" class=\"headerlink\" title=\"因素\"></a>因素</h3><p>既然是复杂系统的稳定性工具，那还是需要考虑用户在使用稳定性工具时的感受，保证工具拥有可靠性、安全性、可扩展性、可定制化、可伸缩性、可维护性、用户体验等。</p>\n<h3 id=\"维度\"><a href=\"#维度\" class=\"headerlink\" title=\"维度\"></a>维度</h3><p>用故障注入作为手段来实施工程，那我们就需要从系统稳定性开始考虑如何保证影响可控的情况下如何正常开展演练。</p>\n<p>1）建立稳定状态的假设（清晰可衡量的指标）</p>\n<p>2）用多样的生产事件做验证（多样性降低误差）</p>\n<p>3）在生产环境做验证（真实场景）</p>\n<p>4）自动化开展实验（持续运行）</p>\n<p>5）控制最小化爆炸半径（影响范围）</p>\n<p>而，做到这么几点才能保证混沌工程能够正常的推广下去。</p>\n<h3 id=\"经验\"><a href=\"#经验\" class=\"headerlink\" title=\"经验\"></a>经验</h3><p>混沌工程的考虑维度我们已经列出来了。但是如何推广工程又是另外一套方法论，因为如何把事做好本身就是很难的事情。</p>\n<p>所以，在做事之前，考虑好影响，提前建立预期，对于混沌工程而言，总会不断的和故障打交道，于是就需要建立面向失败设计和拥抱失败的技术文化，让大家能够接受失败。同时先从简单的场景开始尝试，逐渐增加组织对系统的信心</p>\n<p>其实，工程需要一个实施目标，评估整体工程推进的情况，</p>\n<p>在前期：需要对历史故障的复现率以及解决率，确保故障改进的有效性；<strong>中期</strong>：提高监控发现率，验证故障发现能力的全面性和监控的完备程度；<strong>后期</strong>：故障的“发现-定位-恢复”市场这种综合性指标；</p>\n<p>最终希望是能达到在控制风险的前提下不断提升混沌工程效率<a href=\"https://zhuanlan.zhihu.com/p/354401594\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/354401594</a>)</p>\n"},{"title":"Golang调度讲解","date":"2020-07-08T07:38:21.000Z","_content":"\nGolang调度是runtime中的核心部分，要说涉及到的东西，从基本的线程协程切换、GC的STW，到锁的暂停，都有相关涉猎。今天请个假休息一下，有空整理整理最近看的调度知识。\n\n## 调度基本知识\n\n### 进程、线程和协程\n\n进程和线程的区别都不用说了，简单来说就是，最初，大佬们觉得，每个任务肯定都有独立的内存空间、句柄等等等。只要保证程序直接能够不互相干扰就行。\n\n当机器性能不断的提升，程序员们发现，我任务太多了，需要执行很久，但是并不需要那么多的空间。如果照原来的方法每个任务都分配空间就特别耗时和耗资源，于是决定在进程的基础上拆分出线程，你只负责执行任务就行了。\n\n按道理，线程已经足够轻量，大数据时代又来了。现在需要大量的碎片计算，就像请求一个hello world，执行的任务不耗时，但是频繁。这时候的线程切换就是一个问题，主要原因是，线程的切换需要切换至操作系统的内核态，不断地做内存的复制，页表的cache很容易就失效，耗时因此增加。\n\n程序员再次想起，只要尽可能的不做内核态的切换，就可以减少这样的风险。于是出现了用户态的线程，也就是协程。\n\n\n### 并发模型\n\n大家在学习Golang源码中可以顺便思考一下，为什么是GMP模型？这就引出《七周七并发模型》书中的其他的并发模型：\n\n- 通过无变量的函数式编程实现并发，是无锁并发的一种模型；\n- Clojure对于状态和标识的分离，可以轻松实现内存事务模型；\n- Erlang的Actor模型是容错性非常高的分布式并发模型；\n- CSP模型是另一种分布式并发模型，被Go和Clojure采用；\n- GPU的并行计算主要针对数据密集型计算的并行，搞游戏的一定要看；\n- Hadoop和Storm分别适合超大数据量的批处理和流式处理。\n\nCSP（Communicating Sequential Processes）是由Tony Hoare在1978的论文上首次提出的。 它是处理并发编程的一种设计模式或者模型，指导并发程序的设计，提供了一种并发程序可实践的组织方法或者设计范式。通过此方法，可以减少并发程序引入的其它缺点，减少和规避并发程序的常见缺点和bug，并且可以被数学理论所论证。\n\n> 经典名言：Do not communicate by sharing memory; instead, share memory by communicating\n\n该模型主要的最终实现在于golang中的channel和goroutine。\n\n### GMP模型\n\n在golang实现之前，其实解决线程切换开销大的问题可能有各种各样的方式。nginx中通过epollo来进行事件管理，还有python中的yield进行用户态的手动切换。这些都属于非抢占式的，核心问题就是如果中间出现过量的超时操作，很容易就会导致进程阻塞。\n\n而golang的GMP模型中参考操作系统中的线程切换制作了sysmon线程用于做协程的抢占操作。\n\n在GMP模型特殊之处也是在于中间P层的存在，在1.1之前，是不存在P层。这就导致了，G其实是挂载在全局的链表中。每次切换协程都会抢占一个全局锁，于是给GM中增加了一个P层。\n\n### 特殊的线程、协程\n\n在golang中，存在2个特殊的线程：sysmon、templateThread。前者主要用于实现golang的抢占式调度，后者则是作为fork线程时使用的模板线程。\n\n同时还存在一个特殊的协程：signalG，功能也就是用于接收进程的信号。\n\n这3者可以单独讲解。本文主要讲解整体的正常线程调度流程。\n\n## 进程启动\n\n### 最初的入口和空间\n\n首先，golang的启动入口rt0_go（asm_arm64.s文件）。\n\n```\n\tMOVW\tR0, 8(RSP) // argc\n\tMOVD\tR1, 16(RSP) // argv\n\n\t// create istack out of the given (operating system) stack.\n\t// _cgo_init may update stackguard.\n\tMOVD\t$runtime·g0(SB), g\n\tMOVD\tRSP, R7\n\tMOVD\t$(-64*1024)(R7), R0\n\tMOVD\tR0, g_stackguard0(g)\n\tMOVD\tR0, g_stackguard1(g)\n\tMOVD\tR0, (g_stack+stack_lo)(g)\n\tMOVD\tR7, (g_stack+stack_hi)(g)\n\n    ... ...\nnocgo:\n\tBL\truntime·save_g(SB)\n\t// update stackguard after _cgo_init\n\tMOVD\t(g_stack+stack_lo)(g), R0\n\tADD\t$const__StackGuard, R0\n\tMOVD\tR0, g_stackguard0(g)\n\tMOVD\tR0, g_stackguard1(g)\n\n\t// set the per-goroutine and per-mach \"registers\"\n\tMOVD\t$runtime·m0(SB), R0\n\n\t// save m->g0 = g0\n\tMOVD\tg, m_g0(R0)\n\t// save m0 to g0->m\n\tMOVD\tR0, g_m(g)\n\n\tMOVW\t8(RSP), R0\t// copy argc\n\tMOVW\tR0, -8(RSP)\n\tMOVD\t16(RSP), R0\t\t// copy argv\n\tMOVD\tR0, 0(RSP)\n```\n\n这段汇编其实不用特别讨论，主要做的就是初始化的一个流程：  \n1. 赋值stack.lo和stack.hi属性\n2. 保存g0对象\n3. 设置m对象，包括m->g0、g0->m，做一个m0和g0的绑定\n4. 复制argc和argv\n\n以上基本上就是一些属性的赋值，后续就是执行了一系列的初始化函数。\n\n```\n\tBL\truntime·args(SB)\n\tBL\truntime·osinit(SB)\n\tBL\truntime·schedinit(SB)\n```\n\n这3个函数，不是特别影响调度流程，具体功能主要是对一些功能进行初始化，例如内存管理、信号、mp链表、GC等功能的初始化。\n\n在以上部分，现在基本上只存在一个m0代表主线程，一个g0代表主线程中的g0空间，还要一个signalG空间（并不在执行链表中），同时初始化了maxprocs个p，且在m0上面挂载了一个p对象。这时候，需要开始执行main函数，则需要一个新的g来执行方法。\n\n```\n\tMOVD\t$runtime·mainPC(SB), R0\t\t// entry\n\tMOVD\tRSP, R7\n\tMOVD.W\t$0, -8(R7)\n\tMOVD.W\tR0, -8(R7)\n\tMOVD.W\t$0, -8(R7)\n\tMOVD.W\t$0, -8(R7)\n\tMOVD\tR7, RSP\n\tBL\truntime·newproc(SB)\n```\n\n`newproc`方法会将`runtime.main`函数作为入参传入，功能等同于`go runtime.main()`。而`newproc`方法具体功能主要就是创建一个g并插入当前的p中。\n\n到这一步为止，整个进程还是只存在一个线程，但是存在3个g：g0、signalG、mainG。之后，就开始执行一个调度流程。\n\n```\n    BL\truntime·mstart(SB)\n```\n\n### 调度启动流程\n\n这是每个线程进入循环的入口。为什么这么说，代码如下：\n```\nfunc newosproc(mp *m) {\n\t... ...\n\tret := clone(cloneFlags, stk, unsafe.Pointer(mp), unsafe.Pointer(mp.g0), unsafe.Pointer(funcPC(mstart)))\n```\n这就是创建一个线程的代码，印象中的线程创建是`thread_create`方法，底层最后还是调用的`clone`方法[参考](https://linux.die.net/man/2/clone)，所有golang自行封装了一个方法。而这个调用的最后一个方法就是`mstart`方法。\n\n\n进入`mstart`方法后，核心功能具体可以分为4部分：  \n1. osStack的判断\n2. stackguard的赋值\n3. mstart1的调用\n4. mexit方法，m的退出函数\n\n首先，先确定stackguard的功能，通过汇编指令，我们可以看到每个函数中都能有一段代码：\n```\nTEXT runtime.main(SB) /opt/go/src/runtime/proc.go\n        proc.go:113             0x430690        64488b0c25f8ffffff      mov rcx, qword ptr fs:[0xfffffff8]\n        proc.go:113             0x430699        483b6110                cmp rsp, qword ptr [rcx+0x10]\n        proc.go:113             0x43069d        0f86f9020000            jbe 0x43099c\n=>      proc.go:113             0x4306a3*       4883ec50                sub rsp, 0x50\n        ... ...\n        proc.go:113             0x43099c        e86f8b0200              call $runtime.morestack_noctxt\n        <autogenerated>:1       0x4309a1        e9eafcffff              jmp $runtime.main\n```\n第一行和第二行的具体功能分别是从TLS中获取当前的g对象、得到stackguard属性值。\n这一整段的代码也就是表示如果当前的rsp比stackguard小的话，就认为是需要进行栈扩展。具体的值，也就是stack.lo+_StackGuard(896)。这一段就不具体叙述。\n\n第二个问题是为什么要判断osStack？这就是要知道什么情况下会出现osStack，也就是系统栈空间。核心代码如下：\n```\nfunc allocm(_p_ *p, fn func()) *m {\n    ... ...\n\tif iscgo || GOOS == \"solaris\" || GOOS == \"illumos\" || GOOS == \"windows\" || GOOS == \"plan9\" || GOOS == \"darwin\" {\n\t\tmp.g0 = malg(-1)\n\t} else {\n\t\tmp.g0 = malg(8192 * sys.StackGuardMultiplier)\n\t}\n```\n主要是当创建m的时候，m里面的g0的栈根据不同的系统或者cgo会创建系统的栈空间，否则就会使用heap中的空间。而在`mstart`方法中，判断是否为osStack，主要是需要判断，当前的栈是否可复用，如果是操作系统自动分配的栈是不在heap中的，无法回收管理，所以直接释放，若是在heap中，则需要进行回收操作。\n\n而`mexit`函数，功能主要也是做一系列的变量释放、回收操作。后续会引出相关功能。\n\n之后，方法会进入`mstart1`函数中\n```\nfunc mstart1() {\n\t_g_ := getg()\n\n\tif _g_ != _g_.m.g0 {\n\t\tthrow(\"bad runtime·mstart\")\n\t}\n\n\tsave(getcallerpc(), getcallersp())\n\tasminit()\n\tminit()\n\n\tif _g_.m == &m0 {\n\t\tmstartm0()\n\t}\n\n\tif fn := _g_.m.mstartfn; fn != nil {\n\t\tfn()\n\t}\n\n\tif _g_.m != &m0 {\n\t\tacquirep(_g_.m.nextp.ptr())\n\t\t_g_.m.nextp = 0\n\t}\n\tschedule()\n}\n```\n\n首先，当前方法保存了上一个函数的pc和sp地址，功能也就是为了调用mexit方法，这里不做叙述。再之后就是2个初始化方法，`asminit`方法，在大部分操作系统中是没有函数体的，而`minit`函数中，具体做的事情是信号的初始化，也就是每个m都有自己的一个信号栈。这一部分不在此次学习范围内。\n\n而后续的`mstartm0`函数，功能具体描述大致有2部分：创建扩展的线程、初始化信号回调方法。俩者也就是只会在m0上面执行一次，不在调度功能内，暂时不做过多介绍。\n\n> 问：扩展线程的功能是干嘛的？\n\n再之后就会有`mstartfn`函数的执行，这一个函数具体会存在3种情况：sysmon抢占线程、templateThread模板线程、mspinning自旋方法。前2者在前面也提到过是2个特殊的线程，进入后便会不断的轮询等待。后者的自旋只是对当前的m做了一个自旋的标记。\n\n而后，针对非m0的m要进行一个p的绑定，m0为啥不需要呢？当然是因为m0在之前就已经绑定好了。\n\n### 开始调度循环\n\n题目是调度循环，而代码中其实是没有一个for循环，最后的逻辑是进入了一个execute方法，那具体是如何实现循环？\n\n循环具体涉及到了几个函数的循环：`schedule->execute->goexit->goexit1->goexit0->schedule`\n\n#### Schedule函数\n\n函数的第一段逻辑，主要会判断当前m是否存在绑定的g，如果存在，则暂停当前m，而后执行`lockedg`。Why？这一段不是主流程，稍后再看。\n\n> 什么情况下会从暂停m？\n\n```\n\tif _g_.m.lockedg != 0 {\n\t\tstoplockedm()\n\t\texecute(_g_.m.lockedg.ptr(), false) // Never returns.\n\t}\n```\n\n之后就是`gcwaiting`变量的判断，该变量不为0的情况主要是在GC的STW阶段。如果是STW阶段，则会暂停当前的m，等到startTheWorld时，会将所有的p唤醒。\n```\n\tif sched.gcwaiting != 0 {\n\t\tgcstopm()\n\t\tgoto top\n\t}\n```\n\n下面就是`runSafePointFn`这个名字，主要功能就是在GC前，需要打开所有的p读写屏障。而这个逻辑，就是简单的需要保证每个P都需要执行一遍。\n\n```\n\tif pp.runSafePointFn != 0 {\n\t\trunSafePointFn()\n\t}\n```\n\n再之后就是执行当前p上挂载的定时器\n\n```\ncheckTimers(pp, 0)\n```\n\n上述都是一些m特殊的处理流程，等处理完后，就需要开始寻找g来进行执行。\n\n```\n\tif gp == nil && gcBlackenEnabled != 0 {\n\t\tgp = gcController.findRunnableGCWorker(_g_.m.p.ptr())\n\t\ttryWakeP = tryWakeP || gp != nil\n\t}\n\tif gp == nil {\n\t\tif _g_.m.p.ptr().schedtick%61 == 0 && sched.runqsize > 0 {\n\t\t\tlock(&sched.lock)\n\t\t\tgp = globrunqget(_g_.m.p.ptr(), 1)\n\t\t\tunlock(&sched.lock)\n\t\t}\n\t}\n\tif gp == nil {\n\t\tgp, inheritTime = runqget(_g_.m.p.ptr())\n\t}\n```\n\n上述代码，基本上也就是3块逻辑：优先执行gc的g、其次查看是否需要获取全局列表、最后查看当前p的列表。\n\n```\n\tif gp.lockedm != 0 {\n\t\t// Hands off own p to the locked m,\n\t\t// then blocks waiting for a new p.\n\t\tstartlockedm(gp)\n\t\tgoto top\n\t}\n\n\texecute(gp, inheritTime)\n```\n\n最后针对绑定的g进行特殊处理。否则就执行`execute`方法\n\n> 会从哪些地方去获取g？优先级是什么？\n\n#### Execute函数\n\n该函数主要功能切换当前上下文至指定的g中，具体源码如下，没有特别的逻辑，都是将g属性初始化一遍。\n\n```\nfunc execute(gp *g, inheritTime bool) {\n\t_g_ := getg()\n\n\t_g_.m.curg = gp\n\tgp.m = _g_.m\n\tcasgstatus(gp, _Grunnable, _Grunning)\n\tgp.waitsince = 0\n\tgp.preempt = false\n\tgp.stackguard0 = gp.stack.lo + _StackGuard\n\tif !inheritTime {\n\t\t_g_.m.p.ptr().schedtick++\n\t}\n\n\tgogo(&gp.sched)\n}\n```\n\n而`gogo`方法是真正在汇编层切换寄存器的逻辑，传入的sched就是这个g的上下文信息，包含4个寄存器信息，代码如下：\n```\nTEXT runtime·gogo(SB), NOSPLIT, $16-8\n\tMOVQ\tbuf+0(FP), BX\t\t// gobuf\n\tMOVQ\tgobuf_g(BX), DX\n\tMOVQ\t0(DX), CX\t\t// make sure g != nil\n\tget_tls(CX)\n\tMOVQ\tDX, g(CX)\t\t// 保存g至tls中\n\t// 恢复sp，ax，dx，bp寄存器\n\tMOVQ\tgobuf_sp(BX), SP\t// restore SP\n\tMOVQ\tgobuf_ret(BX), AX\n\tMOVQ\tgobuf_ctxt(BX), DX\n\tMOVQ\tgobuf_bp(BX), BP\n\t// 清空gobuf\n\tMOVQ\t$0, gobuf_sp(BX)\t// clear to help garbage collector\n\tMOVQ\t$0, gobuf_ret(BX)\n\tMOVQ\t$0, gobuf_ctxt(BX)\n\tMOVQ\t$0, gobuf_bp(BX)\n\tMOVQ\tgobuf_pc(BX), BX\n\tJMP\tBX\n```\n\n#### Goexit函数\n\ngoexit方法是当当前线程执行完毕后执行的析构方法，设置的方法为：\n```\nfunc gostartcallfn(gobuf *gobuf, fv *funcval) {\n    var fn unsafe.Pointer\n    if fv != nil {\n        fn = unsafe.Pointer(fv.fn)\n    } else {\n        fn = unsafe.Pointer(funcPC(nilfunc))\n    }\n    gostartcall(gobuf, fn, unsafe.Pointer(fv))\n}\n\n// adjust Gobuf as if it executed a call to fn with context ctxt\n// and then did an immediate gosave.\nfunc gostartcall(buf *gobuf, fn, ctxt unsafe.Pointer) {\n    sp := buf.sp\n    if sys.RegSize > sys.PtrSize {\n        sp -= sys.PtrSize\n        *(*uintptr)(unsafe.Pointer(sp)) = 0\n    }\n    sp -= sys.PtrSize\n    *(*uintptr)(unsafe.Pointer(sp)) = buf.pc // 注意这里，这个，这里的 buf.pc 实际上是 goexit 的 pc\n    buf.sp = sp\n    buf.pc = uintptr(fn)\n    buf.ctxt = ctxt\n}\n```\n\n在 gostartcall 中把 newproc1 时设置到 buf.pc 中的 goexit 的函数地址放到了 goroutine 的栈顶，然后重新设置 buf.pc 为 goroutine 函数的位置。这样做的目的是为了在执行完任何 goroutine 的函数时，通过 RET 指令，都能从栈顶把 sp 保存的 goexit 的指令 pop 到 pc 寄存器，效果相当于任何 goroutine 执行函数执行完之后，都会去执行 runtime.goexit，完成一些清理工作后再进入 schedule。\n\n\n当前流程只剩下`goexit->goexit1->goexit0`，代码还算可读，直接上代码：\n```\nTEXT runtime·goexit(SB),NOSPLIT,$0-0\n\tBYTE\t$0x90\t// NOP\n\tCALL\truntime·goexit1(SB)\t// does not return\n\t// traceback from goexit1 must hit code range of goexit\n\tBYTE\t$0x90\t// NOP\n\n\t... ... \n\n// Finishes execution of the current goroutine.\nfunc goexit1() {\n\tif raceenabled {\n\t\tracegoend()\n\t}\n\tif trace.enabled {\n\t\ttraceGoEnd()\n\t}\n\tmcall(goexit0)\n}\n```\n在代码来看，goexit和goexit1目标只是切换到g0协程中并执行`goexit0`中，第一部分，大部分都是变量清空，并清空当前的g状态置为_Gdead。\n\n```\nfunc goexit0(gp *g) {\n\t_g_ := getg()\n\n\tcasgstatus(gp, _Grunning, _Gdead)\n\tif isSystemGoroutine(gp, false) {\n\t\tatomic.Xadd(&sched.ngsys, -1)\n\t}\n\tgp.m = nil\n\tlocked := gp.lockedm != 0\n\tgp.lockedm = 0\n\t_g_.m.lockedg = 0\n\tgp.preemptStop = false\n\tgp.paniconfault = false\n\tgp._defer = nil // should be true already but just in case.\n\tgp._panic = nil // non-nil for Goexit during panic. points at stack-allocated data.\n\tgp.writebuf = nil\n\tgp.waitreason = 0\n\tgp.param = nil\n\tgp.labels = nil\n\tgp.timer = nil\n\tif gcBlackenEnabled != 0 && gp.gcAssistBytes > 0 {\n\t\tscanCredit := int64(gcController.assistWorkPerByte * float64(gp.gcAssistBytes))\n\t\tatomic.Xaddint64(&gcController.bgScanCredit, scanCredit)\n\t\tgp.gcAssistBytes = 0\n\t}\n\tdropg()\n```\n\n清空完自身的g后，主要就剩下清理其他的信息，例如：写入g的队列中，清空m，进入调度。\n\n```\nfunc goexit0(gp *g) {\n\t... ...\n\tgfput(_g_.m.p.ptr(), gp)\n\tif locked {\n\t\tif GOOS != \"plan9\" { // See golang.org/issue/22227.\n\t\t\tgogo(&_g_.m.g0.sched)\n\t\t} else {\n\t\t\t_g_.m.lockedExt = 0\n\t\t}\n\t}\n\tschedule()\n```\n\n## 待办事项\n- 定时执行逻辑\n- 锁定线程逻辑\n- tryWakeP逻辑\n- findrunnable逻辑\n- mcall、notesleep逻辑\n- inheritTime功能","source":"_posts/golang-dispatch.md","raw":"---\ntitle: Golang调度讲解\ndate: 2020-07-08 15:38:21\ntags:\n---\n\nGolang调度是runtime中的核心部分，要说涉及到的东西，从基本的线程协程切换、GC的STW，到锁的暂停，都有相关涉猎。今天请个假休息一下，有空整理整理最近看的调度知识。\n\n## 调度基本知识\n\n### 进程、线程和协程\n\n进程和线程的区别都不用说了，简单来说就是，最初，大佬们觉得，每个任务肯定都有独立的内存空间、句柄等等等。只要保证程序直接能够不互相干扰就行。\n\n当机器性能不断的提升，程序员们发现，我任务太多了，需要执行很久，但是并不需要那么多的空间。如果照原来的方法每个任务都分配空间就特别耗时和耗资源，于是决定在进程的基础上拆分出线程，你只负责执行任务就行了。\n\n按道理，线程已经足够轻量，大数据时代又来了。现在需要大量的碎片计算，就像请求一个hello world，执行的任务不耗时，但是频繁。这时候的线程切换就是一个问题，主要原因是，线程的切换需要切换至操作系统的内核态，不断地做内存的复制，页表的cache很容易就失效，耗时因此增加。\n\n程序员再次想起，只要尽可能的不做内核态的切换，就可以减少这样的风险。于是出现了用户态的线程，也就是协程。\n\n\n### 并发模型\n\n大家在学习Golang源码中可以顺便思考一下，为什么是GMP模型？这就引出《七周七并发模型》书中的其他的并发模型：\n\n- 通过无变量的函数式编程实现并发，是无锁并发的一种模型；\n- Clojure对于状态和标识的分离，可以轻松实现内存事务模型；\n- Erlang的Actor模型是容错性非常高的分布式并发模型；\n- CSP模型是另一种分布式并发模型，被Go和Clojure采用；\n- GPU的并行计算主要针对数据密集型计算的并行，搞游戏的一定要看；\n- Hadoop和Storm分别适合超大数据量的批处理和流式处理。\n\nCSP（Communicating Sequential Processes）是由Tony Hoare在1978的论文上首次提出的。 它是处理并发编程的一种设计模式或者模型，指导并发程序的设计，提供了一种并发程序可实践的组织方法或者设计范式。通过此方法，可以减少并发程序引入的其它缺点，减少和规避并发程序的常见缺点和bug，并且可以被数学理论所论证。\n\n> 经典名言：Do not communicate by sharing memory; instead, share memory by communicating\n\n该模型主要的最终实现在于golang中的channel和goroutine。\n\n### GMP模型\n\n在golang实现之前，其实解决线程切换开销大的问题可能有各种各样的方式。nginx中通过epollo来进行事件管理，还有python中的yield进行用户态的手动切换。这些都属于非抢占式的，核心问题就是如果中间出现过量的超时操作，很容易就会导致进程阻塞。\n\n而golang的GMP模型中参考操作系统中的线程切换制作了sysmon线程用于做协程的抢占操作。\n\n在GMP模型特殊之处也是在于中间P层的存在，在1.1之前，是不存在P层。这就导致了，G其实是挂载在全局的链表中。每次切换协程都会抢占一个全局锁，于是给GM中增加了一个P层。\n\n### 特殊的线程、协程\n\n在golang中，存在2个特殊的线程：sysmon、templateThread。前者主要用于实现golang的抢占式调度，后者则是作为fork线程时使用的模板线程。\n\n同时还存在一个特殊的协程：signalG，功能也就是用于接收进程的信号。\n\n这3者可以单独讲解。本文主要讲解整体的正常线程调度流程。\n\n## 进程启动\n\n### 最初的入口和空间\n\n首先，golang的启动入口rt0_go（asm_arm64.s文件）。\n\n```\n\tMOVW\tR0, 8(RSP) // argc\n\tMOVD\tR1, 16(RSP) // argv\n\n\t// create istack out of the given (operating system) stack.\n\t// _cgo_init may update stackguard.\n\tMOVD\t$runtime·g0(SB), g\n\tMOVD\tRSP, R7\n\tMOVD\t$(-64*1024)(R7), R0\n\tMOVD\tR0, g_stackguard0(g)\n\tMOVD\tR0, g_stackguard1(g)\n\tMOVD\tR0, (g_stack+stack_lo)(g)\n\tMOVD\tR7, (g_stack+stack_hi)(g)\n\n    ... ...\nnocgo:\n\tBL\truntime·save_g(SB)\n\t// update stackguard after _cgo_init\n\tMOVD\t(g_stack+stack_lo)(g), R0\n\tADD\t$const__StackGuard, R0\n\tMOVD\tR0, g_stackguard0(g)\n\tMOVD\tR0, g_stackguard1(g)\n\n\t// set the per-goroutine and per-mach \"registers\"\n\tMOVD\t$runtime·m0(SB), R0\n\n\t// save m->g0 = g0\n\tMOVD\tg, m_g0(R0)\n\t// save m0 to g0->m\n\tMOVD\tR0, g_m(g)\n\n\tMOVW\t8(RSP), R0\t// copy argc\n\tMOVW\tR0, -8(RSP)\n\tMOVD\t16(RSP), R0\t\t// copy argv\n\tMOVD\tR0, 0(RSP)\n```\n\n这段汇编其实不用特别讨论，主要做的就是初始化的一个流程：  \n1. 赋值stack.lo和stack.hi属性\n2. 保存g0对象\n3. 设置m对象，包括m->g0、g0->m，做一个m0和g0的绑定\n4. 复制argc和argv\n\n以上基本上就是一些属性的赋值，后续就是执行了一系列的初始化函数。\n\n```\n\tBL\truntime·args(SB)\n\tBL\truntime·osinit(SB)\n\tBL\truntime·schedinit(SB)\n```\n\n这3个函数，不是特别影响调度流程，具体功能主要是对一些功能进行初始化，例如内存管理、信号、mp链表、GC等功能的初始化。\n\n在以上部分，现在基本上只存在一个m0代表主线程，一个g0代表主线程中的g0空间，还要一个signalG空间（并不在执行链表中），同时初始化了maxprocs个p，且在m0上面挂载了一个p对象。这时候，需要开始执行main函数，则需要一个新的g来执行方法。\n\n```\n\tMOVD\t$runtime·mainPC(SB), R0\t\t// entry\n\tMOVD\tRSP, R7\n\tMOVD.W\t$0, -8(R7)\n\tMOVD.W\tR0, -8(R7)\n\tMOVD.W\t$0, -8(R7)\n\tMOVD.W\t$0, -8(R7)\n\tMOVD\tR7, RSP\n\tBL\truntime·newproc(SB)\n```\n\n`newproc`方法会将`runtime.main`函数作为入参传入，功能等同于`go runtime.main()`。而`newproc`方法具体功能主要就是创建一个g并插入当前的p中。\n\n到这一步为止，整个进程还是只存在一个线程，但是存在3个g：g0、signalG、mainG。之后，就开始执行一个调度流程。\n\n```\n    BL\truntime·mstart(SB)\n```\n\n### 调度启动流程\n\n这是每个线程进入循环的入口。为什么这么说，代码如下：\n```\nfunc newosproc(mp *m) {\n\t... ...\n\tret := clone(cloneFlags, stk, unsafe.Pointer(mp), unsafe.Pointer(mp.g0), unsafe.Pointer(funcPC(mstart)))\n```\n这就是创建一个线程的代码，印象中的线程创建是`thread_create`方法，底层最后还是调用的`clone`方法[参考](https://linux.die.net/man/2/clone)，所有golang自行封装了一个方法。而这个调用的最后一个方法就是`mstart`方法。\n\n\n进入`mstart`方法后，核心功能具体可以分为4部分：  \n1. osStack的判断\n2. stackguard的赋值\n3. mstart1的调用\n4. mexit方法，m的退出函数\n\n首先，先确定stackguard的功能，通过汇编指令，我们可以看到每个函数中都能有一段代码：\n```\nTEXT runtime.main(SB) /opt/go/src/runtime/proc.go\n        proc.go:113             0x430690        64488b0c25f8ffffff      mov rcx, qword ptr fs:[0xfffffff8]\n        proc.go:113             0x430699        483b6110                cmp rsp, qword ptr [rcx+0x10]\n        proc.go:113             0x43069d        0f86f9020000            jbe 0x43099c\n=>      proc.go:113             0x4306a3*       4883ec50                sub rsp, 0x50\n        ... ...\n        proc.go:113             0x43099c        e86f8b0200              call $runtime.morestack_noctxt\n        <autogenerated>:1       0x4309a1        e9eafcffff              jmp $runtime.main\n```\n第一行和第二行的具体功能分别是从TLS中获取当前的g对象、得到stackguard属性值。\n这一整段的代码也就是表示如果当前的rsp比stackguard小的话，就认为是需要进行栈扩展。具体的值，也就是stack.lo+_StackGuard(896)。这一段就不具体叙述。\n\n第二个问题是为什么要判断osStack？这就是要知道什么情况下会出现osStack，也就是系统栈空间。核心代码如下：\n```\nfunc allocm(_p_ *p, fn func()) *m {\n    ... ...\n\tif iscgo || GOOS == \"solaris\" || GOOS == \"illumos\" || GOOS == \"windows\" || GOOS == \"plan9\" || GOOS == \"darwin\" {\n\t\tmp.g0 = malg(-1)\n\t} else {\n\t\tmp.g0 = malg(8192 * sys.StackGuardMultiplier)\n\t}\n```\n主要是当创建m的时候，m里面的g0的栈根据不同的系统或者cgo会创建系统的栈空间，否则就会使用heap中的空间。而在`mstart`方法中，判断是否为osStack，主要是需要判断，当前的栈是否可复用，如果是操作系统自动分配的栈是不在heap中的，无法回收管理，所以直接释放，若是在heap中，则需要进行回收操作。\n\n而`mexit`函数，功能主要也是做一系列的变量释放、回收操作。后续会引出相关功能。\n\n之后，方法会进入`mstart1`函数中\n```\nfunc mstart1() {\n\t_g_ := getg()\n\n\tif _g_ != _g_.m.g0 {\n\t\tthrow(\"bad runtime·mstart\")\n\t}\n\n\tsave(getcallerpc(), getcallersp())\n\tasminit()\n\tminit()\n\n\tif _g_.m == &m0 {\n\t\tmstartm0()\n\t}\n\n\tif fn := _g_.m.mstartfn; fn != nil {\n\t\tfn()\n\t}\n\n\tif _g_.m != &m0 {\n\t\tacquirep(_g_.m.nextp.ptr())\n\t\t_g_.m.nextp = 0\n\t}\n\tschedule()\n}\n```\n\n首先，当前方法保存了上一个函数的pc和sp地址，功能也就是为了调用mexit方法，这里不做叙述。再之后就是2个初始化方法，`asminit`方法，在大部分操作系统中是没有函数体的，而`minit`函数中，具体做的事情是信号的初始化，也就是每个m都有自己的一个信号栈。这一部分不在此次学习范围内。\n\n而后续的`mstartm0`函数，功能具体描述大致有2部分：创建扩展的线程、初始化信号回调方法。俩者也就是只会在m0上面执行一次，不在调度功能内，暂时不做过多介绍。\n\n> 问：扩展线程的功能是干嘛的？\n\n再之后就会有`mstartfn`函数的执行，这一个函数具体会存在3种情况：sysmon抢占线程、templateThread模板线程、mspinning自旋方法。前2者在前面也提到过是2个特殊的线程，进入后便会不断的轮询等待。后者的自旋只是对当前的m做了一个自旋的标记。\n\n而后，针对非m0的m要进行一个p的绑定，m0为啥不需要呢？当然是因为m0在之前就已经绑定好了。\n\n### 开始调度循环\n\n题目是调度循环，而代码中其实是没有一个for循环，最后的逻辑是进入了一个execute方法，那具体是如何实现循环？\n\n循环具体涉及到了几个函数的循环：`schedule->execute->goexit->goexit1->goexit0->schedule`\n\n#### Schedule函数\n\n函数的第一段逻辑，主要会判断当前m是否存在绑定的g，如果存在，则暂停当前m，而后执行`lockedg`。Why？这一段不是主流程，稍后再看。\n\n> 什么情况下会从暂停m？\n\n```\n\tif _g_.m.lockedg != 0 {\n\t\tstoplockedm()\n\t\texecute(_g_.m.lockedg.ptr(), false) // Never returns.\n\t}\n```\n\n之后就是`gcwaiting`变量的判断，该变量不为0的情况主要是在GC的STW阶段。如果是STW阶段，则会暂停当前的m，等到startTheWorld时，会将所有的p唤醒。\n```\n\tif sched.gcwaiting != 0 {\n\t\tgcstopm()\n\t\tgoto top\n\t}\n```\n\n下面就是`runSafePointFn`这个名字，主要功能就是在GC前，需要打开所有的p读写屏障。而这个逻辑，就是简单的需要保证每个P都需要执行一遍。\n\n```\n\tif pp.runSafePointFn != 0 {\n\t\trunSafePointFn()\n\t}\n```\n\n再之后就是执行当前p上挂载的定时器\n\n```\ncheckTimers(pp, 0)\n```\n\n上述都是一些m特殊的处理流程，等处理完后，就需要开始寻找g来进行执行。\n\n```\n\tif gp == nil && gcBlackenEnabled != 0 {\n\t\tgp = gcController.findRunnableGCWorker(_g_.m.p.ptr())\n\t\ttryWakeP = tryWakeP || gp != nil\n\t}\n\tif gp == nil {\n\t\tif _g_.m.p.ptr().schedtick%61 == 0 && sched.runqsize > 0 {\n\t\t\tlock(&sched.lock)\n\t\t\tgp = globrunqget(_g_.m.p.ptr(), 1)\n\t\t\tunlock(&sched.lock)\n\t\t}\n\t}\n\tif gp == nil {\n\t\tgp, inheritTime = runqget(_g_.m.p.ptr())\n\t}\n```\n\n上述代码，基本上也就是3块逻辑：优先执行gc的g、其次查看是否需要获取全局列表、最后查看当前p的列表。\n\n```\n\tif gp.lockedm != 0 {\n\t\t// Hands off own p to the locked m,\n\t\t// then blocks waiting for a new p.\n\t\tstartlockedm(gp)\n\t\tgoto top\n\t}\n\n\texecute(gp, inheritTime)\n```\n\n最后针对绑定的g进行特殊处理。否则就执行`execute`方法\n\n> 会从哪些地方去获取g？优先级是什么？\n\n#### Execute函数\n\n该函数主要功能切换当前上下文至指定的g中，具体源码如下，没有特别的逻辑，都是将g属性初始化一遍。\n\n```\nfunc execute(gp *g, inheritTime bool) {\n\t_g_ := getg()\n\n\t_g_.m.curg = gp\n\tgp.m = _g_.m\n\tcasgstatus(gp, _Grunnable, _Grunning)\n\tgp.waitsince = 0\n\tgp.preempt = false\n\tgp.stackguard0 = gp.stack.lo + _StackGuard\n\tif !inheritTime {\n\t\t_g_.m.p.ptr().schedtick++\n\t}\n\n\tgogo(&gp.sched)\n}\n```\n\n而`gogo`方法是真正在汇编层切换寄存器的逻辑，传入的sched就是这个g的上下文信息，包含4个寄存器信息，代码如下：\n```\nTEXT runtime·gogo(SB), NOSPLIT, $16-8\n\tMOVQ\tbuf+0(FP), BX\t\t// gobuf\n\tMOVQ\tgobuf_g(BX), DX\n\tMOVQ\t0(DX), CX\t\t// make sure g != nil\n\tget_tls(CX)\n\tMOVQ\tDX, g(CX)\t\t// 保存g至tls中\n\t// 恢复sp，ax，dx，bp寄存器\n\tMOVQ\tgobuf_sp(BX), SP\t// restore SP\n\tMOVQ\tgobuf_ret(BX), AX\n\tMOVQ\tgobuf_ctxt(BX), DX\n\tMOVQ\tgobuf_bp(BX), BP\n\t// 清空gobuf\n\tMOVQ\t$0, gobuf_sp(BX)\t// clear to help garbage collector\n\tMOVQ\t$0, gobuf_ret(BX)\n\tMOVQ\t$0, gobuf_ctxt(BX)\n\tMOVQ\t$0, gobuf_bp(BX)\n\tMOVQ\tgobuf_pc(BX), BX\n\tJMP\tBX\n```\n\n#### Goexit函数\n\ngoexit方法是当当前线程执行完毕后执行的析构方法，设置的方法为：\n```\nfunc gostartcallfn(gobuf *gobuf, fv *funcval) {\n    var fn unsafe.Pointer\n    if fv != nil {\n        fn = unsafe.Pointer(fv.fn)\n    } else {\n        fn = unsafe.Pointer(funcPC(nilfunc))\n    }\n    gostartcall(gobuf, fn, unsafe.Pointer(fv))\n}\n\n// adjust Gobuf as if it executed a call to fn with context ctxt\n// and then did an immediate gosave.\nfunc gostartcall(buf *gobuf, fn, ctxt unsafe.Pointer) {\n    sp := buf.sp\n    if sys.RegSize > sys.PtrSize {\n        sp -= sys.PtrSize\n        *(*uintptr)(unsafe.Pointer(sp)) = 0\n    }\n    sp -= sys.PtrSize\n    *(*uintptr)(unsafe.Pointer(sp)) = buf.pc // 注意这里，这个，这里的 buf.pc 实际上是 goexit 的 pc\n    buf.sp = sp\n    buf.pc = uintptr(fn)\n    buf.ctxt = ctxt\n}\n```\n\n在 gostartcall 中把 newproc1 时设置到 buf.pc 中的 goexit 的函数地址放到了 goroutine 的栈顶，然后重新设置 buf.pc 为 goroutine 函数的位置。这样做的目的是为了在执行完任何 goroutine 的函数时，通过 RET 指令，都能从栈顶把 sp 保存的 goexit 的指令 pop 到 pc 寄存器，效果相当于任何 goroutine 执行函数执行完之后，都会去执行 runtime.goexit，完成一些清理工作后再进入 schedule。\n\n\n当前流程只剩下`goexit->goexit1->goexit0`，代码还算可读，直接上代码：\n```\nTEXT runtime·goexit(SB),NOSPLIT,$0-0\n\tBYTE\t$0x90\t// NOP\n\tCALL\truntime·goexit1(SB)\t// does not return\n\t// traceback from goexit1 must hit code range of goexit\n\tBYTE\t$0x90\t// NOP\n\n\t... ... \n\n// Finishes execution of the current goroutine.\nfunc goexit1() {\n\tif raceenabled {\n\t\tracegoend()\n\t}\n\tif trace.enabled {\n\t\ttraceGoEnd()\n\t}\n\tmcall(goexit0)\n}\n```\n在代码来看，goexit和goexit1目标只是切换到g0协程中并执行`goexit0`中，第一部分，大部分都是变量清空，并清空当前的g状态置为_Gdead。\n\n```\nfunc goexit0(gp *g) {\n\t_g_ := getg()\n\n\tcasgstatus(gp, _Grunning, _Gdead)\n\tif isSystemGoroutine(gp, false) {\n\t\tatomic.Xadd(&sched.ngsys, -1)\n\t}\n\tgp.m = nil\n\tlocked := gp.lockedm != 0\n\tgp.lockedm = 0\n\t_g_.m.lockedg = 0\n\tgp.preemptStop = false\n\tgp.paniconfault = false\n\tgp._defer = nil // should be true already but just in case.\n\tgp._panic = nil // non-nil for Goexit during panic. points at stack-allocated data.\n\tgp.writebuf = nil\n\tgp.waitreason = 0\n\tgp.param = nil\n\tgp.labels = nil\n\tgp.timer = nil\n\tif gcBlackenEnabled != 0 && gp.gcAssistBytes > 0 {\n\t\tscanCredit := int64(gcController.assistWorkPerByte * float64(gp.gcAssistBytes))\n\t\tatomic.Xaddint64(&gcController.bgScanCredit, scanCredit)\n\t\tgp.gcAssistBytes = 0\n\t}\n\tdropg()\n```\n\n清空完自身的g后，主要就剩下清理其他的信息，例如：写入g的队列中，清空m，进入调度。\n\n```\nfunc goexit0(gp *g) {\n\t... ...\n\tgfput(_g_.m.p.ptr(), gp)\n\tif locked {\n\t\tif GOOS != \"plan9\" { // See golang.org/issue/22227.\n\t\t\tgogo(&_g_.m.g0.sched)\n\t\t} else {\n\t\t\t_g_.m.lockedExt = 0\n\t\t}\n\t}\n\tschedule()\n```\n\n## 待办事项\n- 定时执行逻辑\n- 锁定线程逻辑\n- tryWakeP逻辑\n- findrunnable逻辑\n- mcall、notesleep逻辑\n- inheritTime功能","slug":"golang-dispatch","published":1,"updated":"2021-08-13T17:27:47.498Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckti9vicm00019gtjdtf6h07t","content":"<p>Golang调度是runtime中的核心部分，要说涉及到的东西，从基本的线程协程切换、GC的STW，到锁的暂停，都有相关涉猎。今天请个假休息一下，有空整理整理最近看的调度知识。</p>\n<h2 id=\"调度基本知识\"><a href=\"#调度基本知识\" class=\"headerlink\" title=\"调度基本知识\"></a>调度基本知识</h2><h3 id=\"进程、线程和协程\"><a href=\"#进程、线程和协程\" class=\"headerlink\" title=\"进程、线程和协程\"></a>进程、线程和协程</h3><p>进程和线程的区别都不用说了，简单来说就是，最初，大佬们觉得，每个任务肯定都有独立的内存空间、句柄等等等。只要保证程序直接能够不互相干扰就行。</p>\n<p>当机器性能不断的提升，程序员们发现，我任务太多了，需要执行很久，但是并不需要那么多的空间。如果照原来的方法每个任务都分配空间就特别耗时和耗资源，于是决定在进程的基础上拆分出线程，你只负责执行任务就行了。</p>\n<p>按道理，线程已经足够轻量，大数据时代又来了。现在需要大量的碎片计算，就像请求一个hello world，执行的任务不耗时，但是频繁。这时候的线程切换就是一个问题，主要原因是，线程的切换需要切换至操作系统的内核态，不断地做内存的复制，页表的cache很容易就失效，耗时因此增加。</p>\n<p>程序员再次想起，只要尽可能的不做内核态的切换，就可以减少这样的风险。于是出现了用户态的线程，也就是协程。</p>\n<h3 id=\"并发模型\"><a href=\"#并发模型\" class=\"headerlink\" title=\"并发模型\"></a>并发模型</h3><p>大家在学习Golang源码中可以顺便思考一下，为什么是GMP模型？这就引出《七周七并发模型》书中的其他的并发模型：</p>\n<ul>\n<li>通过无变量的函数式编程实现并发，是无锁并发的一种模型；</li>\n<li>Clojure对于状态和标识的分离，可以轻松实现内存事务模型；</li>\n<li>Erlang的Actor模型是容错性非常高的分布式并发模型；</li>\n<li>CSP模型是另一种分布式并发模型，被Go和Clojure采用；</li>\n<li>GPU的并行计算主要针对数据密集型计算的并行，搞游戏的一定要看；</li>\n<li>Hadoop和Storm分别适合超大数据量的批处理和流式处理。</li>\n</ul>\n<p>CSP（Communicating Sequential Processes）是由Tony Hoare在1978的论文上首次提出的。 它是处理并发编程的一种设计模式或者模型，指导并发程序的设计，提供了一种并发程序可实践的组织方法或者设计范式。通过此方法，可以减少并发程序引入的其它缺点，减少和规避并发程序的常见缺点和bug，并且可以被数学理论所论证。</p>\n<blockquote>\n<p>经典名言：Do not communicate by sharing memory; instead, share memory by communicating</p>\n</blockquote>\n<p>该模型主要的最终实现在于golang中的channel和goroutine。</p>\n<h3 id=\"GMP模型\"><a href=\"#GMP模型\" class=\"headerlink\" title=\"GMP模型\"></a>GMP模型</h3><p>在golang实现之前，其实解决线程切换开销大的问题可能有各种各样的方式。nginx中通过epollo来进行事件管理，还有python中的yield进行用户态的手动切换。这些都属于非抢占式的，核心问题就是如果中间出现过量的超时操作，很容易就会导致进程阻塞。</p>\n<p>而golang的GMP模型中参考操作系统中的线程切换制作了sysmon线程用于做协程的抢占操作。</p>\n<p>在GMP模型特殊之处也是在于中间P层的存在，在1.1之前，是不存在P层。这就导致了，G其实是挂载在全局的链表中。每次切换协程都会抢占一个全局锁，于是给GM中增加了一个P层。</p>\n<h3 id=\"特殊的线程、协程\"><a href=\"#特殊的线程、协程\" class=\"headerlink\" title=\"特殊的线程、协程\"></a>特殊的线程、协程</h3><p>在golang中，存在2个特殊的线程：sysmon、templateThread。前者主要用于实现golang的抢占式调度，后者则是作为fork线程时使用的模板线程。</p>\n<p>同时还存在一个特殊的协程：signalG，功能也就是用于接收进程的信号。</p>\n<p>这3者可以单独讲解。本文主要讲解整体的正常线程调度流程。</p>\n<h2 id=\"进程启动\"><a href=\"#进程启动\" class=\"headerlink\" title=\"进程启动\"></a>进程启动</h2><h3 id=\"最初的入口和空间\"><a href=\"#最初的入口和空间\" class=\"headerlink\" title=\"最初的入口和空间\"></a>最初的入口和空间</h3><p>首先，golang的启动入口rt0_go（asm_arm64.s文件）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\tMOVW\tR0, 8(RSP) &#x2F;&#x2F; argc</span><br><span class=\"line\">\tMOVD\tR1, 16(RSP) &#x2F;&#x2F; argv</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; create istack out of the given (operating system) stack.</span><br><span class=\"line\">\t&#x2F;&#x2F; _cgo_init may update stackguard.</span><br><span class=\"line\">\tMOVD\t$runtime·g0(SB), g</span><br><span class=\"line\">\tMOVD\tRSP, R7</span><br><span class=\"line\">\tMOVD\t$(-64*1024)(R7), R0</span><br><span class=\"line\">\tMOVD\tR0, g_stackguard0(g)</span><br><span class=\"line\">\tMOVD\tR0, g_stackguard1(g)</span><br><span class=\"line\">\tMOVD\tR0, (g_stack+stack_lo)(g)</span><br><span class=\"line\">\tMOVD\tR7, (g_stack+stack_hi)(g)</span><br><span class=\"line\"></span><br><span class=\"line\">    ... ...</span><br><span class=\"line\">nocgo:</span><br><span class=\"line\">\tBL\truntime·save_g(SB)</span><br><span class=\"line\">\t&#x2F;&#x2F; update stackguard after _cgo_init</span><br><span class=\"line\">\tMOVD\t(g_stack+stack_lo)(g), R0</span><br><span class=\"line\">\tADD\t$const__StackGuard, R0</span><br><span class=\"line\">\tMOVD\tR0, g_stackguard0(g)</span><br><span class=\"line\">\tMOVD\tR0, g_stackguard1(g)</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; set the per-goroutine and per-mach &quot;registers&quot;</span><br><span class=\"line\">\tMOVD\t$runtime·m0(SB), R0</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; save m-&gt;g0 &#x3D; g0</span><br><span class=\"line\">\tMOVD\tg, m_g0(R0)</span><br><span class=\"line\">\t&#x2F;&#x2F; save m0 to g0-&gt;m</span><br><span class=\"line\">\tMOVD\tR0, g_m(g)</span><br><span class=\"line\"></span><br><span class=\"line\">\tMOVW\t8(RSP), R0\t&#x2F;&#x2F; copy argc</span><br><span class=\"line\">\tMOVW\tR0, -8(RSP)</span><br><span class=\"line\">\tMOVD\t16(RSP), R0\t\t&#x2F;&#x2F; copy argv</span><br><span class=\"line\">\tMOVD\tR0, 0(RSP)</span><br></pre></td></tr></table></figure>\n\n<p>这段汇编其实不用特别讨论，主要做的就是初始化的一个流程：  </p>\n<ol>\n<li>赋值stack.lo和stack.hi属性</li>\n<li>保存g0对象</li>\n<li>设置m对象，包括m-&gt;g0、g0-&gt;m，做一个m0和g0的绑定</li>\n<li>复制argc和argv</li>\n</ol>\n<p>以上基本上就是一些属性的赋值，后续就是执行了一系列的初始化函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BL\truntime·args(SB)</span><br><span class=\"line\">BL\truntime·osinit(SB)</span><br><span class=\"line\">BL\truntime·schedinit(SB)</span><br></pre></td></tr></table></figure>\n\n<p>这3个函数，不是特别影响调度流程，具体功能主要是对一些功能进行初始化，例如内存管理、信号、mp链表、GC等功能的初始化。</p>\n<p>在以上部分，现在基本上只存在一个m0代表主线程，一个g0代表主线程中的g0空间，还要一个signalG空间（并不在执行链表中），同时初始化了maxprocs个p，且在m0上面挂载了一个p对象。这时候，需要开始执行main函数，则需要一个新的g来执行方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MOVD\t$runtime·mainPC(SB), R0\t\t&#x2F;&#x2F; entry</span><br><span class=\"line\">MOVD\tRSP, R7</span><br><span class=\"line\">MOVD.W\t$0, -8(R7)</span><br><span class=\"line\">MOVD.W\tR0, -8(R7)</span><br><span class=\"line\">MOVD.W\t$0, -8(R7)</span><br><span class=\"line\">MOVD.W\t$0, -8(R7)</span><br><span class=\"line\">MOVD\tR7, RSP</span><br><span class=\"line\">BL\truntime·newproc(SB)</span><br></pre></td></tr></table></figure>\n\n<p><code>newproc</code>方法会将<code>runtime.main</code>函数作为入参传入，功能等同于<code>go runtime.main()</code>。而<code>newproc</code>方法具体功能主要就是创建一个g并插入当前的p中。</p>\n<p>到这一步为止，整个进程还是只存在一个线程，但是存在3个g：g0、signalG、mainG。之后，就开始执行一个调度流程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BL\truntime·mstart(SB)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"调度启动流程\"><a href=\"#调度启动流程\" class=\"headerlink\" title=\"调度启动流程\"></a>调度启动流程</h3><p>这是每个线程进入循环的入口。为什么这么说，代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func newosproc(mp *m) &#123;</span><br><span class=\"line\">\t... ...</span><br><span class=\"line\">\tret :&#x3D; clone(cloneFlags, stk, unsafe.Pointer(mp), unsafe.Pointer(mp.g0), unsafe.Pointer(funcPC(mstart)))</span><br></pre></td></tr></table></figure>\n<p>这就是创建一个线程的代码，印象中的线程创建是<code>thread_create</code>方法，底层最后还是调用的<code>clone</code>方法<a href=\"https://linux.die.net/man/2/clone\" target=\"_blank\" rel=\"noopener\">参考</a>，所有golang自行封装了一个方法。而这个调用的最后一个方法就是<code>mstart</code>方法。</p>\n<p>进入<code>mstart</code>方法后，核心功能具体可以分为4部分：  </p>\n<ol>\n<li>osStack的判断</li>\n<li>stackguard的赋值</li>\n<li>mstart1的调用</li>\n<li>mexit方法，m的退出函数</li>\n</ol>\n<p>首先，先确定stackguard的功能，通过汇编指令，我们可以看到每个函数中都能有一段代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TEXT runtime.main(SB) &#x2F;opt&#x2F;go&#x2F;src&#x2F;runtime&#x2F;proc.go</span><br><span class=\"line\">        proc.go:113             0x430690        64488b0c25f8ffffff      mov rcx, qword ptr fs:[0xfffffff8]</span><br><span class=\"line\">        proc.go:113             0x430699        483b6110                cmp rsp, qword ptr [rcx+0x10]</span><br><span class=\"line\">        proc.go:113             0x43069d        0f86f9020000            jbe 0x43099c</span><br><span class=\"line\">&#x3D;&gt;      proc.go:113             0x4306a3*       4883ec50                sub rsp, 0x50</span><br><span class=\"line\">        ... ...</span><br><span class=\"line\">        proc.go:113             0x43099c        e86f8b0200              call $runtime.morestack_noctxt</span><br><span class=\"line\">        &lt;autogenerated&gt;:1       0x4309a1        e9eafcffff              jmp $runtime.main</span><br></pre></td></tr></table></figure>\n<p>第一行和第二行的具体功能分别是从TLS中获取当前的g对象、得到stackguard属性值。<br>这一整段的代码也就是表示如果当前的rsp比stackguard小的话，就认为是需要进行栈扩展。具体的值，也就是stack.lo+_StackGuard(896)。这一段就不具体叙述。</p>\n<p>第二个问题是为什么要判断osStack？这就是要知道什么情况下会出现osStack，也就是系统栈空间。核心代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func allocm(_p_ *p, fn func()) *m &#123;</span><br><span class=\"line\">    ... ...</span><br><span class=\"line\">\tif iscgo || GOOS &#x3D;&#x3D; &quot;solaris&quot; || GOOS &#x3D;&#x3D; &quot;illumos&quot; || GOOS &#x3D;&#x3D; &quot;windows&quot; || GOOS &#x3D;&#x3D; &quot;plan9&quot; || GOOS &#x3D;&#x3D; &quot;darwin&quot; &#123;</span><br><span class=\"line\">\t\tmp.g0 &#x3D; malg(-1)</span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t\tmp.g0 &#x3D; malg(8192 * sys.StackGuardMultiplier)</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<p>主要是当创建m的时候，m里面的g0的栈根据不同的系统或者cgo会创建系统的栈空间，否则就会使用heap中的空间。而在<code>mstart</code>方法中，判断是否为osStack，主要是需要判断，当前的栈是否可复用，如果是操作系统自动分配的栈是不在heap中的，无法回收管理，所以直接释放，若是在heap中，则需要进行回收操作。</p>\n<p>而<code>mexit</code>函数，功能主要也是做一系列的变量释放、回收操作。后续会引出相关功能。</p>\n<p>之后，方法会进入<code>mstart1</code>函数中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func mstart1() &#123;</span><br><span class=\"line\">\t_g_ :&#x3D; getg()</span><br><span class=\"line\"></span><br><span class=\"line\">\tif _g_ !&#x3D; _g_.m.g0 &#123;</span><br><span class=\"line\">\t\tthrow(&quot;bad runtime·mstart&quot;)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tsave(getcallerpc(), getcallersp())</span><br><span class=\"line\">\tasminit()</span><br><span class=\"line\">\tminit()</span><br><span class=\"line\"></span><br><span class=\"line\">\tif _g_.m &#x3D;&#x3D; &amp;m0 &#123;</span><br><span class=\"line\">\t\tmstartm0()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tif fn :&#x3D; _g_.m.mstartfn; fn !&#x3D; nil &#123;</span><br><span class=\"line\">\t\tfn()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tif _g_.m !&#x3D; &amp;m0 &#123;</span><br><span class=\"line\">\t\tacquirep(_g_.m.nextp.ptr())</span><br><span class=\"line\">\t\t_g_.m.nextp &#x3D; 0</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tschedule()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>首先，当前方法保存了上一个函数的pc和sp地址，功能也就是为了调用mexit方法，这里不做叙述。再之后就是2个初始化方法，<code>asminit</code>方法，在大部分操作系统中是没有函数体的，而<code>minit</code>函数中，具体做的事情是信号的初始化，也就是每个m都有自己的一个信号栈。这一部分不在此次学习范围内。</p>\n<p>而后续的<code>mstartm0</code>函数，功能具体描述大致有2部分：创建扩展的线程、初始化信号回调方法。俩者也就是只会在m0上面执行一次，不在调度功能内，暂时不做过多介绍。</p>\n<blockquote>\n<p>问：扩展线程的功能是干嘛的？</p>\n</blockquote>\n<p>再之后就会有<code>mstartfn</code>函数的执行，这一个函数具体会存在3种情况：sysmon抢占线程、templateThread模板线程、mspinning自旋方法。前2者在前面也提到过是2个特殊的线程，进入后便会不断的轮询等待。后者的自旋只是对当前的m做了一个自旋的标记。</p>\n<p>而后，针对非m0的m要进行一个p的绑定，m0为啥不需要呢？当然是因为m0在之前就已经绑定好了。</p>\n<h3 id=\"开始调度循环\"><a href=\"#开始调度循环\" class=\"headerlink\" title=\"开始调度循环\"></a>开始调度循环</h3><p>题目是调度循环，而代码中其实是没有一个for循环，最后的逻辑是进入了一个execute方法，那具体是如何实现循环？</p>\n<p>循环具体涉及到了几个函数的循环：<code>schedule-&gt;execute-&gt;goexit-&gt;goexit1-&gt;goexit0-&gt;schedule</code></p>\n<h4 id=\"Schedule函数\"><a href=\"#Schedule函数\" class=\"headerlink\" title=\"Schedule函数\"></a>Schedule函数</h4><p>函数的第一段逻辑，主要会判断当前m是否存在绑定的g，如果存在，则暂停当前m，而后执行<code>lockedg</code>。Why？这一段不是主流程，稍后再看。</p>\n<blockquote>\n<p>什么情况下会从暂停m？</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if _g_.m.lockedg !&#x3D; 0 &#123;</span><br><span class=\"line\">\tstoplockedm()</span><br><span class=\"line\">\texecute(_g_.m.lockedg.ptr(), false) &#x2F;&#x2F; Never returns.</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>之后就是<code>gcwaiting</code>变量的判断，该变量不为0的情况主要是在GC的STW阶段。如果是STW阶段，则会暂停当前的m，等到startTheWorld时，会将所有的p唤醒。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if sched.gcwaiting !&#x3D; 0 &#123;</span><br><span class=\"line\">\tgcstopm()</span><br><span class=\"line\">\tgoto top</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面就是<code>runSafePointFn</code>这个名字，主要功能就是在GC前，需要打开所有的p读写屏障。而这个逻辑，就是简单的需要保证每个P都需要执行一遍。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if pp.runSafePointFn !&#x3D; 0 &#123;</span><br><span class=\"line\">\trunSafePointFn()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再之后就是执行当前p上挂载的定时器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">checkTimers(pp, 0)</span><br></pre></td></tr></table></figure>\n\n<p>上述都是一些m特殊的处理流程，等处理完后，就需要开始寻找g来进行执行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if gp &#x3D;&#x3D; nil &amp;&amp; gcBlackenEnabled !&#x3D; 0 &#123;</span><br><span class=\"line\">\tgp &#x3D; gcController.findRunnableGCWorker(_g_.m.p.ptr())</span><br><span class=\"line\">\ttryWakeP &#x3D; tryWakeP || gp !&#x3D; nil</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">if gp &#x3D;&#x3D; nil &#123;</span><br><span class=\"line\">\tif _g_.m.p.ptr().schedtick%61 &#x3D;&#x3D; 0 &amp;&amp; sched.runqsize &gt; 0 &#123;</span><br><span class=\"line\">\t\tlock(&amp;sched.lock)</span><br><span class=\"line\">\t\tgp &#x3D; globrunqget(_g_.m.p.ptr(), 1)</span><br><span class=\"line\">\t\tunlock(&amp;sched.lock)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">if gp &#x3D;&#x3D; nil &#123;</span><br><span class=\"line\">\tgp, inheritTime &#x3D; runqget(_g_.m.p.ptr())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码，基本上也就是3块逻辑：优先执行gc的g、其次查看是否需要获取全局列表、最后查看当前p的列表。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if gp.lockedm !&#x3D; 0 &#123;</span><br><span class=\"line\">\t&#x2F;&#x2F; Hands off own p to the locked m,</span><br><span class=\"line\">\t&#x2F;&#x2F; then blocks waiting for a new p.</span><br><span class=\"line\">\tstartlockedm(gp)</span><br><span class=\"line\">\tgoto top</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">execute(gp, inheritTime)</span><br></pre></td></tr></table></figure>\n\n<p>最后针对绑定的g进行特殊处理。否则就执行<code>execute</code>方法</p>\n<blockquote>\n<p>会从哪些地方去获取g？优先级是什么？</p>\n</blockquote>\n<h4 id=\"Execute函数\"><a href=\"#Execute函数\" class=\"headerlink\" title=\"Execute函数\"></a>Execute函数</h4><p>该函数主要功能切换当前上下文至指定的g中，具体源码如下，没有特别的逻辑，都是将g属性初始化一遍。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func execute(gp *g, inheritTime bool) &#123;</span><br><span class=\"line\">\t_g_ :&#x3D; getg()</span><br><span class=\"line\"></span><br><span class=\"line\">\t_g_.m.curg &#x3D; gp</span><br><span class=\"line\">\tgp.m &#x3D; _g_.m</span><br><span class=\"line\">\tcasgstatus(gp, _Grunnable, _Grunning)</span><br><span class=\"line\">\tgp.waitsince &#x3D; 0</span><br><span class=\"line\">\tgp.preempt &#x3D; false</span><br><span class=\"line\">\tgp.stackguard0 &#x3D; gp.stack.lo + _StackGuard</span><br><span class=\"line\">\tif !inheritTime &#123;</span><br><span class=\"line\">\t\t_g_.m.p.ptr().schedtick++</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tgogo(&amp;gp.sched)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而<code>gogo</code>方法是真正在汇编层切换寄存器的逻辑，传入的sched就是这个g的上下文信息，包含4个寄存器信息，代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TEXT runtime·gogo(SB), NOSPLIT, $16-8</span><br><span class=\"line\">\tMOVQ\tbuf+0(FP), BX\t\t&#x2F;&#x2F; gobuf</span><br><span class=\"line\">\tMOVQ\tgobuf_g(BX), DX</span><br><span class=\"line\">\tMOVQ\t0(DX), CX\t\t&#x2F;&#x2F; make sure g !&#x3D; nil</span><br><span class=\"line\">\tget_tls(CX)</span><br><span class=\"line\">\tMOVQ\tDX, g(CX)\t\t&#x2F;&#x2F; 保存g至tls中</span><br><span class=\"line\">\t&#x2F;&#x2F; 恢复sp，ax，dx，bp寄存器</span><br><span class=\"line\">\tMOVQ\tgobuf_sp(BX), SP\t&#x2F;&#x2F; restore SP</span><br><span class=\"line\">\tMOVQ\tgobuf_ret(BX), AX</span><br><span class=\"line\">\tMOVQ\tgobuf_ctxt(BX), DX</span><br><span class=\"line\">\tMOVQ\tgobuf_bp(BX), BP</span><br><span class=\"line\">\t&#x2F;&#x2F; 清空gobuf</span><br><span class=\"line\">\tMOVQ\t$0, gobuf_sp(BX)\t&#x2F;&#x2F; clear to help garbage collector</span><br><span class=\"line\">\tMOVQ\t$0, gobuf_ret(BX)</span><br><span class=\"line\">\tMOVQ\t$0, gobuf_ctxt(BX)</span><br><span class=\"line\">\tMOVQ\t$0, gobuf_bp(BX)</span><br><span class=\"line\">\tMOVQ\tgobuf_pc(BX), BX</span><br><span class=\"line\">\tJMP\tBX</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Goexit函数\"><a href=\"#Goexit函数\" class=\"headerlink\" title=\"Goexit函数\"></a>Goexit函数</h4><p>goexit方法是当当前线程执行完毕后执行的析构方法，设置的方法为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func gostartcallfn(gobuf *gobuf, fv *funcval) &#123;</span><br><span class=\"line\">    var fn unsafe.Pointer</span><br><span class=\"line\">    if fv !&#x3D; nil &#123;</span><br><span class=\"line\">        fn &#x3D; unsafe.Pointer(fv.fn)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        fn &#x3D; unsafe.Pointer(funcPC(nilfunc))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    gostartcall(gobuf, fn, unsafe.Pointer(fv))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; adjust Gobuf as if it executed a call to fn with context ctxt</span><br><span class=\"line\">&#x2F;&#x2F; and then did an immediate gosave.</span><br><span class=\"line\">func gostartcall(buf *gobuf, fn, ctxt unsafe.Pointer) &#123;</span><br><span class=\"line\">    sp :&#x3D; buf.sp</span><br><span class=\"line\">    if sys.RegSize &gt; sys.PtrSize &#123;</span><br><span class=\"line\">        sp -&#x3D; sys.PtrSize</span><br><span class=\"line\">        *(*uintptr)(unsafe.Pointer(sp)) &#x3D; 0</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sp -&#x3D; sys.PtrSize</span><br><span class=\"line\">    *(*uintptr)(unsafe.Pointer(sp)) &#x3D; buf.pc &#x2F;&#x2F; 注意这里，这个，这里的 buf.pc 实际上是 goexit 的 pc</span><br><span class=\"line\">    buf.sp &#x3D; sp</span><br><span class=\"line\">    buf.pc &#x3D; uintptr(fn)</span><br><span class=\"line\">    buf.ctxt &#x3D; ctxt</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 gostartcall 中把 newproc1 时设置到 buf.pc 中的 goexit 的函数地址放到了 goroutine 的栈顶，然后重新设置 buf.pc 为 goroutine 函数的位置。这样做的目的是为了在执行完任何 goroutine 的函数时，通过 RET 指令，都能从栈顶把 sp 保存的 goexit 的指令 pop 到 pc 寄存器，效果相当于任何 goroutine 执行函数执行完之后，都会去执行 runtime.goexit，完成一些清理工作后再进入 schedule。</p>\n<p>当前流程只剩下<code>goexit-&gt;goexit1-&gt;goexit0</code>，代码还算可读，直接上代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TEXT runtime·goexit(SB),NOSPLIT,$0-0</span><br><span class=\"line\">\tBYTE\t$0x90\t&#x2F;&#x2F; NOP</span><br><span class=\"line\">\tCALL\truntime·goexit1(SB)\t&#x2F;&#x2F; does not return</span><br><span class=\"line\">\t&#x2F;&#x2F; traceback from goexit1 must hit code range of goexit</span><br><span class=\"line\">\tBYTE\t$0x90\t&#x2F;&#x2F; NOP</span><br><span class=\"line\"></span><br><span class=\"line\">\t... ... </span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Finishes execution of the current goroutine.</span><br><span class=\"line\">func goexit1() &#123;</span><br><span class=\"line\">\tif raceenabled &#123;</span><br><span class=\"line\">\t\tracegoend()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif trace.enabled &#123;</span><br><span class=\"line\">\t\ttraceGoEnd()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tmcall(goexit0)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在代码来看，goexit和goexit1目标只是切换到g0协程中并执行<code>goexit0</code>中，第一部分，大部分都是变量清空，并清空当前的g状态置为_Gdead。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func goexit0(gp *g) &#123;</span><br><span class=\"line\">\t_g_ :&#x3D; getg()</span><br><span class=\"line\"></span><br><span class=\"line\">\tcasgstatus(gp, _Grunning, _Gdead)</span><br><span class=\"line\">\tif isSystemGoroutine(gp, false) &#123;</span><br><span class=\"line\">\t\tatomic.Xadd(&amp;sched.ngsys, -1)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tgp.m &#x3D; nil</span><br><span class=\"line\">\tlocked :&#x3D; gp.lockedm !&#x3D; 0</span><br><span class=\"line\">\tgp.lockedm &#x3D; 0</span><br><span class=\"line\">\t_g_.m.lockedg &#x3D; 0</span><br><span class=\"line\">\tgp.preemptStop &#x3D; false</span><br><span class=\"line\">\tgp.paniconfault &#x3D; false</span><br><span class=\"line\">\tgp._defer &#x3D; nil &#x2F;&#x2F; should be true already but just in case.</span><br><span class=\"line\">\tgp._panic &#x3D; nil &#x2F;&#x2F; non-nil for Goexit during panic. points at stack-allocated data.</span><br><span class=\"line\">\tgp.writebuf &#x3D; nil</span><br><span class=\"line\">\tgp.waitreason &#x3D; 0</span><br><span class=\"line\">\tgp.param &#x3D; nil</span><br><span class=\"line\">\tgp.labels &#x3D; nil</span><br><span class=\"line\">\tgp.timer &#x3D; nil</span><br><span class=\"line\">\tif gcBlackenEnabled !&#x3D; 0 &amp;&amp; gp.gcAssistBytes &gt; 0 &#123;</span><br><span class=\"line\">\t\tscanCredit :&#x3D; int64(gcController.assistWorkPerByte * float64(gp.gcAssistBytes))</span><br><span class=\"line\">\t\tatomic.Xaddint64(&amp;gcController.bgScanCredit, scanCredit)</span><br><span class=\"line\">\t\tgp.gcAssistBytes &#x3D; 0</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tdropg()</span><br></pre></td></tr></table></figure>\n\n<p>清空完自身的g后，主要就剩下清理其他的信息，例如：写入g的队列中，清空m，进入调度。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func goexit0(gp *g) &#123;</span><br><span class=\"line\">\t... ...</span><br><span class=\"line\">\tgfput(_g_.m.p.ptr(), gp)</span><br><span class=\"line\">\tif locked &#123;</span><br><span class=\"line\">\t\tif GOOS !&#x3D; &quot;plan9&quot; &#123; &#x2F;&#x2F; See golang.org&#x2F;issue&#x2F;22227.</span><br><span class=\"line\">\t\t\tgogo(&amp;_g_.m.g0.sched)</span><br><span class=\"line\">\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t_g_.m.lockedExt &#x3D; 0</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tschedule()</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"待办事项\"><a href=\"#待办事项\" class=\"headerlink\" title=\"待办事项\"></a>待办事项</h2><ul>\n<li>定时执行逻辑</li>\n<li>锁定线程逻辑</li>\n<li>tryWakeP逻辑</li>\n<li>findrunnable逻辑</li>\n<li>mcall、notesleep逻辑</li>\n<li>inheritTime功能</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>Golang调度是runtime中的核心部分，要说涉及到的东西，从基本的线程协程切换、GC的STW，到锁的暂停，都有相关涉猎。今天请个假休息一下，有空整理整理最近看的调度知识。</p>\n<h2 id=\"调度基本知识\"><a href=\"#调度基本知识\" class=\"headerlink\" title=\"调度基本知识\"></a>调度基本知识</h2><h3 id=\"进程、线程和协程\"><a href=\"#进程、线程和协程\" class=\"headerlink\" title=\"进程、线程和协程\"></a>进程、线程和协程</h3><p>进程和线程的区别都不用说了，简单来说就是，最初，大佬们觉得，每个任务肯定都有独立的内存空间、句柄等等等。只要保证程序直接能够不互相干扰就行。</p>\n<p>当机器性能不断的提升，程序员们发现，我任务太多了，需要执行很久，但是并不需要那么多的空间。如果照原来的方法每个任务都分配空间就特别耗时和耗资源，于是决定在进程的基础上拆分出线程，你只负责执行任务就行了。</p>\n<p>按道理，线程已经足够轻量，大数据时代又来了。现在需要大量的碎片计算，就像请求一个hello world，执行的任务不耗时，但是频繁。这时候的线程切换就是一个问题，主要原因是，线程的切换需要切换至操作系统的内核态，不断地做内存的复制，页表的cache很容易就失效，耗时因此增加。</p>\n<p>程序员再次想起，只要尽可能的不做内核态的切换，就可以减少这样的风险。于是出现了用户态的线程，也就是协程。</p>\n<h3 id=\"并发模型\"><a href=\"#并发模型\" class=\"headerlink\" title=\"并发模型\"></a>并发模型</h3><p>大家在学习Golang源码中可以顺便思考一下，为什么是GMP模型？这就引出《七周七并发模型》书中的其他的并发模型：</p>\n<ul>\n<li>通过无变量的函数式编程实现并发，是无锁并发的一种模型；</li>\n<li>Clojure对于状态和标识的分离，可以轻松实现内存事务模型；</li>\n<li>Erlang的Actor模型是容错性非常高的分布式并发模型；</li>\n<li>CSP模型是另一种分布式并发模型，被Go和Clojure采用；</li>\n<li>GPU的并行计算主要针对数据密集型计算的并行，搞游戏的一定要看；</li>\n<li>Hadoop和Storm分别适合超大数据量的批处理和流式处理。</li>\n</ul>\n<p>CSP（Communicating Sequential Processes）是由Tony Hoare在1978的论文上首次提出的。 它是处理并发编程的一种设计模式或者模型，指导并发程序的设计，提供了一种并发程序可实践的组织方法或者设计范式。通过此方法，可以减少并发程序引入的其它缺点，减少和规避并发程序的常见缺点和bug，并且可以被数学理论所论证。</p>\n<blockquote>\n<p>经典名言：Do not communicate by sharing memory; instead, share memory by communicating</p>\n</blockquote>\n<p>该模型主要的最终实现在于golang中的channel和goroutine。</p>\n<h3 id=\"GMP模型\"><a href=\"#GMP模型\" class=\"headerlink\" title=\"GMP模型\"></a>GMP模型</h3><p>在golang实现之前，其实解决线程切换开销大的问题可能有各种各样的方式。nginx中通过epollo来进行事件管理，还有python中的yield进行用户态的手动切换。这些都属于非抢占式的，核心问题就是如果中间出现过量的超时操作，很容易就会导致进程阻塞。</p>\n<p>而golang的GMP模型中参考操作系统中的线程切换制作了sysmon线程用于做协程的抢占操作。</p>\n<p>在GMP模型特殊之处也是在于中间P层的存在，在1.1之前，是不存在P层。这就导致了，G其实是挂载在全局的链表中。每次切换协程都会抢占一个全局锁，于是给GM中增加了一个P层。</p>\n<h3 id=\"特殊的线程、协程\"><a href=\"#特殊的线程、协程\" class=\"headerlink\" title=\"特殊的线程、协程\"></a>特殊的线程、协程</h3><p>在golang中，存在2个特殊的线程：sysmon、templateThread。前者主要用于实现golang的抢占式调度，后者则是作为fork线程时使用的模板线程。</p>\n<p>同时还存在一个特殊的协程：signalG，功能也就是用于接收进程的信号。</p>\n<p>这3者可以单独讲解。本文主要讲解整体的正常线程调度流程。</p>\n<h2 id=\"进程启动\"><a href=\"#进程启动\" class=\"headerlink\" title=\"进程启动\"></a>进程启动</h2><h3 id=\"最初的入口和空间\"><a href=\"#最初的入口和空间\" class=\"headerlink\" title=\"最初的入口和空间\"></a>最初的入口和空间</h3><p>首先，golang的启动入口rt0_go（asm_arm64.s文件）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\tMOVW\tR0, 8(RSP) &#x2F;&#x2F; argc</span><br><span class=\"line\">\tMOVD\tR1, 16(RSP) &#x2F;&#x2F; argv</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; create istack out of the given (operating system) stack.</span><br><span class=\"line\">\t&#x2F;&#x2F; _cgo_init may update stackguard.</span><br><span class=\"line\">\tMOVD\t$runtime·g0(SB), g</span><br><span class=\"line\">\tMOVD\tRSP, R7</span><br><span class=\"line\">\tMOVD\t$(-64*1024)(R7), R0</span><br><span class=\"line\">\tMOVD\tR0, g_stackguard0(g)</span><br><span class=\"line\">\tMOVD\tR0, g_stackguard1(g)</span><br><span class=\"line\">\tMOVD\tR0, (g_stack+stack_lo)(g)</span><br><span class=\"line\">\tMOVD\tR7, (g_stack+stack_hi)(g)</span><br><span class=\"line\"></span><br><span class=\"line\">    ... ...</span><br><span class=\"line\">nocgo:</span><br><span class=\"line\">\tBL\truntime·save_g(SB)</span><br><span class=\"line\">\t&#x2F;&#x2F; update stackguard after _cgo_init</span><br><span class=\"line\">\tMOVD\t(g_stack+stack_lo)(g), R0</span><br><span class=\"line\">\tADD\t$const__StackGuard, R0</span><br><span class=\"line\">\tMOVD\tR0, g_stackguard0(g)</span><br><span class=\"line\">\tMOVD\tR0, g_stackguard1(g)</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; set the per-goroutine and per-mach &quot;registers&quot;</span><br><span class=\"line\">\tMOVD\t$runtime·m0(SB), R0</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#x2F;&#x2F; save m-&gt;g0 &#x3D; g0</span><br><span class=\"line\">\tMOVD\tg, m_g0(R0)</span><br><span class=\"line\">\t&#x2F;&#x2F; save m0 to g0-&gt;m</span><br><span class=\"line\">\tMOVD\tR0, g_m(g)</span><br><span class=\"line\"></span><br><span class=\"line\">\tMOVW\t8(RSP), R0\t&#x2F;&#x2F; copy argc</span><br><span class=\"line\">\tMOVW\tR0, -8(RSP)</span><br><span class=\"line\">\tMOVD\t16(RSP), R0\t\t&#x2F;&#x2F; copy argv</span><br><span class=\"line\">\tMOVD\tR0, 0(RSP)</span><br></pre></td></tr></table></figure>\n\n<p>这段汇编其实不用特别讨论，主要做的就是初始化的一个流程：  </p>\n<ol>\n<li>赋值stack.lo和stack.hi属性</li>\n<li>保存g0对象</li>\n<li>设置m对象，包括m-&gt;g0、g0-&gt;m，做一个m0和g0的绑定</li>\n<li>复制argc和argv</li>\n</ol>\n<p>以上基本上就是一些属性的赋值，后续就是执行了一系列的初始化函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BL\truntime·args(SB)</span><br><span class=\"line\">BL\truntime·osinit(SB)</span><br><span class=\"line\">BL\truntime·schedinit(SB)</span><br></pre></td></tr></table></figure>\n\n<p>这3个函数，不是特别影响调度流程，具体功能主要是对一些功能进行初始化，例如内存管理、信号、mp链表、GC等功能的初始化。</p>\n<p>在以上部分，现在基本上只存在一个m0代表主线程，一个g0代表主线程中的g0空间，还要一个signalG空间（并不在执行链表中），同时初始化了maxprocs个p，且在m0上面挂载了一个p对象。这时候，需要开始执行main函数，则需要一个新的g来执行方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MOVD\t$runtime·mainPC(SB), R0\t\t&#x2F;&#x2F; entry</span><br><span class=\"line\">MOVD\tRSP, R7</span><br><span class=\"line\">MOVD.W\t$0, -8(R7)</span><br><span class=\"line\">MOVD.W\tR0, -8(R7)</span><br><span class=\"line\">MOVD.W\t$0, -8(R7)</span><br><span class=\"line\">MOVD.W\t$0, -8(R7)</span><br><span class=\"line\">MOVD\tR7, RSP</span><br><span class=\"line\">BL\truntime·newproc(SB)</span><br></pre></td></tr></table></figure>\n\n<p><code>newproc</code>方法会将<code>runtime.main</code>函数作为入参传入，功能等同于<code>go runtime.main()</code>。而<code>newproc</code>方法具体功能主要就是创建一个g并插入当前的p中。</p>\n<p>到这一步为止，整个进程还是只存在一个线程，但是存在3个g：g0、signalG、mainG。之后，就开始执行一个调度流程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BL\truntime·mstart(SB)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"调度启动流程\"><a href=\"#调度启动流程\" class=\"headerlink\" title=\"调度启动流程\"></a>调度启动流程</h3><p>这是每个线程进入循环的入口。为什么这么说，代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func newosproc(mp *m) &#123;</span><br><span class=\"line\">\t... ...</span><br><span class=\"line\">\tret :&#x3D; clone(cloneFlags, stk, unsafe.Pointer(mp), unsafe.Pointer(mp.g0), unsafe.Pointer(funcPC(mstart)))</span><br></pre></td></tr></table></figure>\n<p>这就是创建一个线程的代码，印象中的线程创建是<code>thread_create</code>方法，底层最后还是调用的<code>clone</code>方法<a href=\"https://linux.die.net/man/2/clone\" target=\"_blank\" rel=\"noopener\">参考</a>，所有golang自行封装了一个方法。而这个调用的最后一个方法就是<code>mstart</code>方法。</p>\n<p>进入<code>mstart</code>方法后，核心功能具体可以分为4部分：  </p>\n<ol>\n<li>osStack的判断</li>\n<li>stackguard的赋值</li>\n<li>mstart1的调用</li>\n<li>mexit方法，m的退出函数</li>\n</ol>\n<p>首先，先确定stackguard的功能，通过汇编指令，我们可以看到每个函数中都能有一段代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TEXT runtime.main(SB) &#x2F;opt&#x2F;go&#x2F;src&#x2F;runtime&#x2F;proc.go</span><br><span class=\"line\">        proc.go:113             0x430690        64488b0c25f8ffffff      mov rcx, qword ptr fs:[0xfffffff8]</span><br><span class=\"line\">        proc.go:113             0x430699        483b6110                cmp rsp, qword ptr [rcx+0x10]</span><br><span class=\"line\">        proc.go:113             0x43069d        0f86f9020000            jbe 0x43099c</span><br><span class=\"line\">&#x3D;&gt;      proc.go:113             0x4306a3*       4883ec50                sub rsp, 0x50</span><br><span class=\"line\">        ... ...</span><br><span class=\"line\">        proc.go:113             0x43099c        e86f8b0200              call $runtime.morestack_noctxt</span><br><span class=\"line\">        &lt;autogenerated&gt;:1       0x4309a1        e9eafcffff              jmp $runtime.main</span><br></pre></td></tr></table></figure>\n<p>第一行和第二行的具体功能分别是从TLS中获取当前的g对象、得到stackguard属性值。<br>这一整段的代码也就是表示如果当前的rsp比stackguard小的话，就认为是需要进行栈扩展。具体的值，也就是stack.lo+_StackGuard(896)。这一段就不具体叙述。</p>\n<p>第二个问题是为什么要判断osStack？这就是要知道什么情况下会出现osStack，也就是系统栈空间。核心代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func allocm(_p_ *p, fn func()) *m &#123;</span><br><span class=\"line\">    ... ...</span><br><span class=\"line\">\tif iscgo || GOOS &#x3D;&#x3D; &quot;solaris&quot; || GOOS &#x3D;&#x3D; &quot;illumos&quot; || GOOS &#x3D;&#x3D; &quot;windows&quot; || GOOS &#x3D;&#x3D; &quot;plan9&quot; || GOOS &#x3D;&#x3D; &quot;darwin&quot; &#123;</span><br><span class=\"line\">\t\tmp.g0 &#x3D; malg(-1)</span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t\tmp.g0 &#x3D; malg(8192 * sys.StackGuardMultiplier)</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<p>主要是当创建m的时候，m里面的g0的栈根据不同的系统或者cgo会创建系统的栈空间，否则就会使用heap中的空间。而在<code>mstart</code>方法中，判断是否为osStack，主要是需要判断，当前的栈是否可复用，如果是操作系统自动分配的栈是不在heap中的，无法回收管理，所以直接释放，若是在heap中，则需要进行回收操作。</p>\n<p>而<code>mexit</code>函数，功能主要也是做一系列的变量释放、回收操作。后续会引出相关功能。</p>\n<p>之后，方法会进入<code>mstart1</code>函数中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func mstart1() &#123;</span><br><span class=\"line\">\t_g_ :&#x3D; getg()</span><br><span class=\"line\"></span><br><span class=\"line\">\tif _g_ !&#x3D; _g_.m.g0 &#123;</span><br><span class=\"line\">\t\tthrow(&quot;bad runtime·mstart&quot;)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tsave(getcallerpc(), getcallersp())</span><br><span class=\"line\">\tasminit()</span><br><span class=\"line\">\tminit()</span><br><span class=\"line\"></span><br><span class=\"line\">\tif _g_.m &#x3D;&#x3D; &amp;m0 &#123;</span><br><span class=\"line\">\t\tmstartm0()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tif fn :&#x3D; _g_.m.mstartfn; fn !&#x3D; nil &#123;</span><br><span class=\"line\">\t\tfn()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tif _g_.m !&#x3D; &amp;m0 &#123;</span><br><span class=\"line\">\t\tacquirep(_g_.m.nextp.ptr())</span><br><span class=\"line\">\t\t_g_.m.nextp &#x3D; 0</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tschedule()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>首先，当前方法保存了上一个函数的pc和sp地址，功能也就是为了调用mexit方法，这里不做叙述。再之后就是2个初始化方法，<code>asminit</code>方法，在大部分操作系统中是没有函数体的，而<code>minit</code>函数中，具体做的事情是信号的初始化，也就是每个m都有自己的一个信号栈。这一部分不在此次学习范围内。</p>\n<p>而后续的<code>mstartm0</code>函数，功能具体描述大致有2部分：创建扩展的线程、初始化信号回调方法。俩者也就是只会在m0上面执行一次，不在调度功能内，暂时不做过多介绍。</p>\n<blockquote>\n<p>问：扩展线程的功能是干嘛的？</p>\n</blockquote>\n<p>再之后就会有<code>mstartfn</code>函数的执行，这一个函数具体会存在3种情况：sysmon抢占线程、templateThread模板线程、mspinning自旋方法。前2者在前面也提到过是2个特殊的线程，进入后便会不断的轮询等待。后者的自旋只是对当前的m做了一个自旋的标记。</p>\n<p>而后，针对非m0的m要进行一个p的绑定，m0为啥不需要呢？当然是因为m0在之前就已经绑定好了。</p>\n<h3 id=\"开始调度循环\"><a href=\"#开始调度循环\" class=\"headerlink\" title=\"开始调度循环\"></a>开始调度循环</h3><p>题目是调度循环，而代码中其实是没有一个for循环，最后的逻辑是进入了一个execute方法，那具体是如何实现循环？</p>\n<p>循环具体涉及到了几个函数的循环：<code>schedule-&gt;execute-&gt;goexit-&gt;goexit1-&gt;goexit0-&gt;schedule</code></p>\n<h4 id=\"Schedule函数\"><a href=\"#Schedule函数\" class=\"headerlink\" title=\"Schedule函数\"></a>Schedule函数</h4><p>函数的第一段逻辑，主要会判断当前m是否存在绑定的g，如果存在，则暂停当前m，而后执行<code>lockedg</code>。Why？这一段不是主流程，稍后再看。</p>\n<blockquote>\n<p>什么情况下会从暂停m？</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if _g_.m.lockedg !&#x3D; 0 &#123;</span><br><span class=\"line\">\tstoplockedm()</span><br><span class=\"line\">\texecute(_g_.m.lockedg.ptr(), false) &#x2F;&#x2F; Never returns.</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>之后就是<code>gcwaiting</code>变量的判断，该变量不为0的情况主要是在GC的STW阶段。如果是STW阶段，则会暂停当前的m，等到startTheWorld时，会将所有的p唤醒。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if sched.gcwaiting !&#x3D; 0 &#123;</span><br><span class=\"line\">\tgcstopm()</span><br><span class=\"line\">\tgoto top</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面就是<code>runSafePointFn</code>这个名字，主要功能就是在GC前，需要打开所有的p读写屏障。而这个逻辑，就是简单的需要保证每个P都需要执行一遍。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if pp.runSafePointFn !&#x3D; 0 &#123;</span><br><span class=\"line\">\trunSafePointFn()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再之后就是执行当前p上挂载的定时器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">checkTimers(pp, 0)</span><br></pre></td></tr></table></figure>\n\n<p>上述都是一些m特殊的处理流程，等处理完后，就需要开始寻找g来进行执行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if gp &#x3D;&#x3D; nil &amp;&amp; gcBlackenEnabled !&#x3D; 0 &#123;</span><br><span class=\"line\">\tgp &#x3D; gcController.findRunnableGCWorker(_g_.m.p.ptr())</span><br><span class=\"line\">\ttryWakeP &#x3D; tryWakeP || gp !&#x3D; nil</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">if gp &#x3D;&#x3D; nil &#123;</span><br><span class=\"line\">\tif _g_.m.p.ptr().schedtick%61 &#x3D;&#x3D; 0 &amp;&amp; sched.runqsize &gt; 0 &#123;</span><br><span class=\"line\">\t\tlock(&amp;sched.lock)</span><br><span class=\"line\">\t\tgp &#x3D; globrunqget(_g_.m.p.ptr(), 1)</span><br><span class=\"line\">\t\tunlock(&amp;sched.lock)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">if gp &#x3D;&#x3D; nil &#123;</span><br><span class=\"line\">\tgp, inheritTime &#x3D; runqget(_g_.m.p.ptr())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码，基本上也就是3块逻辑：优先执行gc的g、其次查看是否需要获取全局列表、最后查看当前p的列表。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if gp.lockedm !&#x3D; 0 &#123;</span><br><span class=\"line\">\t&#x2F;&#x2F; Hands off own p to the locked m,</span><br><span class=\"line\">\t&#x2F;&#x2F; then blocks waiting for a new p.</span><br><span class=\"line\">\tstartlockedm(gp)</span><br><span class=\"line\">\tgoto top</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">execute(gp, inheritTime)</span><br></pre></td></tr></table></figure>\n\n<p>最后针对绑定的g进行特殊处理。否则就执行<code>execute</code>方法</p>\n<blockquote>\n<p>会从哪些地方去获取g？优先级是什么？</p>\n</blockquote>\n<h4 id=\"Execute函数\"><a href=\"#Execute函数\" class=\"headerlink\" title=\"Execute函数\"></a>Execute函数</h4><p>该函数主要功能切换当前上下文至指定的g中，具体源码如下，没有特别的逻辑，都是将g属性初始化一遍。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func execute(gp *g, inheritTime bool) &#123;</span><br><span class=\"line\">\t_g_ :&#x3D; getg()</span><br><span class=\"line\"></span><br><span class=\"line\">\t_g_.m.curg &#x3D; gp</span><br><span class=\"line\">\tgp.m &#x3D; _g_.m</span><br><span class=\"line\">\tcasgstatus(gp, _Grunnable, _Grunning)</span><br><span class=\"line\">\tgp.waitsince &#x3D; 0</span><br><span class=\"line\">\tgp.preempt &#x3D; false</span><br><span class=\"line\">\tgp.stackguard0 &#x3D; gp.stack.lo + _StackGuard</span><br><span class=\"line\">\tif !inheritTime &#123;</span><br><span class=\"line\">\t\t_g_.m.p.ptr().schedtick++</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tgogo(&amp;gp.sched)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而<code>gogo</code>方法是真正在汇编层切换寄存器的逻辑，传入的sched就是这个g的上下文信息，包含4个寄存器信息，代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TEXT runtime·gogo(SB), NOSPLIT, $16-8</span><br><span class=\"line\">\tMOVQ\tbuf+0(FP), BX\t\t&#x2F;&#x2F; gobuf</span><br><span class=\"line\">\tMOVQ\tgobuf_g(BX), DX</span><br><span class=\"line\">\tMOVQ\t0(DX), CX\t\t&#x2F;&#x2F; make sure g !&#x3D; nil</span><br><span class=\"line\">\tget_tls(CX)</span><br><span class=\"line\">\tMOVQ\tDX, g(CX)\t\t&#x2F;&#x2F; 保存g至tls中</span><br><span class=\"line\">\t&#x2F;&#x2F; 恢复sp，ax，dx，bp寄存器</span><br><span class=\"line\">\tMOVQ\tgobuf_sp(BX), SP\t&#x2F;&#x2F; restore SP</span><br><span class=\"line\">\tMOVQ\tgobuf_ret(BX), AX</span><br><span class=\"line\">\tMOVQ\tgobuf_ctxt(BX), DX</span><br><span class=\"line\">\tMOVQ\tgobuf_bp(BX), BP</span><br><span class=\"line\">\t&#x2F;&#x2F; 清空gobuf</span><br><span class=\"line\">\tMOVQ\t$0, gobuf_sp(BX)\t&#x2F;&#x2F; clear to help garbage collector</span><br><span class=\"line\">\tMOVQ\t$0, gobuf_ret(BX)</span><br><span class=\"line\">\tMOVQ\t$0, gobuf_ctxt(BX)</span><br><span class=\"line\">\tMOVQ\t$0, gobuf_bp(BX)</span><br><span class=\"line\">\tMOVQ\tgobuf_pc(BX), BX</span><br><span class=\"line\">\tJMP\tBX</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Goexit函数\"><a href=\"#Goexit函数\" class=\"headerlink\" title=\"Goexit函数\"></a>Goexit函数</h4><p>goexit方法是当当前线程执行完毕后执行的析构方法，设置的方法为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func gostartcallfn(gobuf *gobuf, fv *funcval) &#123;</span><br><span class=\"line\">    var fn unsafe.Pointer</span><br><span class=\"line\">    if fv !&#x3D; nil &#123;</span><br><span class=\"line\">        fn &#x3D; unsafe.Pointer(fv.fn)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        fn &#x3D; unsafe.Pointer(funcPC(nilfunc))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    gostartcall(gobuf, fn, unsafe.Pointer(fv))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; adjust Gobuf as if it executed a call to fn with context ctxt</span><br><span class=\"line\">&#x2F;&#x2F; and then did an immediate gosave.</span><br><span class=\"line\">func gostartcall(buf *gobuf, fn, ctxt unsafe.Pointer) &#123;</span><br><span class=\"line\">    sp :&#x3D; buf.sp</span><br><span class=\"line\">    if sys.RegSize &gt; sys.PtrSize &#123;</span><br><span class=\"line\">        sp -&#x3D; sys.PtrSize</span><br><span class=\"line\">        *(*uintptr)(unsafe.Pointer(sp)) &#x3D; 0</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sp -&#x3D; sys.PtrSize</span><br><span class=\"line\">    *(*uintptr)(unsafe.Pointer(sp)) &#x3D; buf.pc &#x2F;&#x2F; 注意这里，这个，这里的 buf.pc 实际上是 goexit 的 pc</span><br><span class=\"line\">    buf.sp &#x3D; sp</span><br><span class=\"line\">    buf.pc &#x3D; uintptr(fn)</span><br><span class=\"line\">    buf.ctxt &#x3D; ctxt</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 gostartcall 中把 newproc1 时设置到 buf.pc 中的 goexit 的函数地址放到了 goroutine 的栈顶，然后重新设置 buf.pc 为 goroutine 函数的位置。这样做的目的是为了在执行完任何 goroutine 的函数时，通过 RET 指令，都能从栈顶把 sp 保存的 goexit 的指令 pop 到 pc 寄存器，效果相当于任何 goroutine 执行函数执行完之后，都会去执行 runtime.goexit，完成一些清理工作后再进入 schedule。</p>\n<p>当前流程只剩下<code>goexit-&gt;goexit1-&gt;goexit0</code>，代码还算可读，直接上代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TEXT runtime·goexit(SB),NOSPLIT,$0-0</span><br><span class=\"line\">\tBYTE\t$0x90\t&#x2F;&#x2F; NOP</span><br><span class=\"line\">\tCALL\truntime·goexit1(SB)\t&#x2F;&#x2F; does not return</span><br><span class=\"line\">\t&#x2F;&#x2F; traceback from goexit1 must hit code range of goexit</span><br><span class=\"line\">\tBYTE\t$0x90\t&#x2F;&#x2F; NOP</span><br><span class=\"line\"></span><br><span class=\"line\">\t... ... </span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Finishes execution of the current goroutine.</span><br><span class=\"line\">func goexit1() &#123;</span><br><span class=\"line\">\tif raceenabled &#123;</span><br><span class=\"line\">\t\tracegoend()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif trace.enabled &#123;</span><br><span class=\"line\">\t\ttraceGoEnd()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tmcall(goexit0)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在代码来看，goexit和goexit1目标只是切换到g0协程中并执行<code>goexit0</code>中，第一部分，大部分都是变量清空，并清空当前的g状态置为_Gdead。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func goexit0(gp *g) &#123;</span><br><span class=\"line\">\t_g_ :&#x3D; getg()</span><br><span class=\"line\"></span><br><span class=\"line\">\tcasgstatus(gp, _Grunning, _Gdead)</span><br><span class=\"line\">\tif isSystemGoroutine(gp, false) &#123;</span><br><span class=\"line\">\t\tatomic.Xadd(&amp;sched.ngsys, -1)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tgp.m &#x3D; nil</span><br><span class=\"line\">\tlocked :&#x3D; gp.lockedm !&#x3D; 0</span><br><span class=\"line\">\tgp.lockedm &#x3D; 0</span><br><span class=\"line\">\t_g_.m.lockedg &#x3D; 0</span><br><span class=\"line\">\tgp.preemptStop &#x3D; false</span><br><span class=\"line\">\tgp.paniconfault &#x3D; false</span><br><span class=\"line\">\tgp._defer &#x3D; nil &#x2F;&#x2F; should be true already but just in case.</span><br><span class=\"line\">\tgp._panic &#x3D; nil &#x2F;&#x2F; non-nil for Goexit during panic. points at stack-allocated data.</span><br><span class=\"line\">\tgp.writebuf &#x3D; nil</span><br><span class=\"line\">\tgp.waitreason &#x3D; 0</span><br><span class=\"line\">\tgp.param &#x3D; nil</span><br><span class=\"line\">\tgp.labels &#x3D; nil</span><br><span class=\"line\">\tgp.timer &#x3D; nil</span><br><span class=\"line\">\tif gcBlackenEnabled !&#x3D; 0 &amp;&amp; gp.gcAssistBytes &gt; 0 &#123;</span><br><span class=\"line\">\t\tscanCredit :&#x3D; int64(gcController.assistWorkPerByte * float64(gp.gcAssistBytes))</span><br><span class=\"line\">\t\tatomic.Xaddint64(&amp;gcController.bgScanCredit, scanCredit)</span><br><span class=\"line\">\t\tgp.gcAssistBytes &#x3D; 0</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tdropg()</span><br></pre></td></tr></table></figure>\n\n<p>清空完自身的g后，主要就剩下清理其他的信息，例如：写入g的队列中，清空m，进入调度。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func goexit0(gp *g) &#123;</span><br><span class=\"line\">\t... ...</span><br><span class=\"line\">\tgfput(_g_.m.p.ptr(), gp)</span><br><span class=\"line\">\tif locked &#123;</span><br><span class=\"line\">\t\tif GOOS !&#x3D; &quot;plan9&quot; &#123; &#x2F;&#x2F; See golang.org&#x2F;issue&#x2F;22227.</span><br><span class=\"line\">\t\t\tgogo(&amp;_g_.m.g0.sched)</span><br><span class=\"line\">\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t_g_.m.lockedExt &#x3D; 0</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tschedule()</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"待办事项\"><a href=\"#待办事项\" class=\"headerlink\" title=\"待办事项\"></a>待办事项</h2><ul>\n<li>定时执行逻辑</li>\n<li>锁定线程逻辑</li>\n<li>tryWakeP逻辑</li>\n<li>findrunnable逻辑</li>\n<li>mcall、notesleep逻辑</li>\n<li>inheritTime功能</li>\n</ul>\n"},{"title":"Golang-Lockg学习","date":"2020-07-12T15:51:41.000Z","_content":"## 前言\n\n## GMP的关系\n\n## G的调度\n\n## 抢占逻辑\n\n## 锁协程\n\n## GMP清理","source":"_posts/golang-lockg.md","raw":"---\ntitle: Golang-Lockg学习\ndate: 2020-07-12 23:51:41\ntags:\n---\n## 前言\n\n## GMP的关系\n\n## G的调度\n\n## 抢占逻辑\n\n## 锁协程\n\n## GMP清理","slug":"golang-lockg","published":1,"updated":"2021-08-13T17:27:47.498Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckti9vicn00029gtjcj8z5osw","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><h2 id=\"GMP的关系\"><a href=\"#GMP的关系\" class=\"headerlink\" title=\"GMP的关系\"></a>GMP的关系</h2><h2 id=\"G的调度\"><a href=\"#G的调度\" class=\"headerlink\" title=\"G的调度\"></a>G的调度</h2><h2 id=\"抢占逻辑\"><a href=\"#抢占逻辑\" class=\"headerlink\" title=\"抢占逻辑\"></a>抢占逻辑</h2><h2 id=\"锁协程\"><a href=\"#锁协程\" class=\"headerlink\" title=\"锁协程\"></a>锁协程</h2><h2 id=\"GMP清理\"><a href=\"#GMP清理\" class=\"headerlink\" title=\"GMP清理\"></a>GMP清理</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><h2 id=\"GMP的关系\"><a href=\"#GMP的关系\" class=\"headerlink\" title=\"GMP的关系\"></a>GMP的关系</h2><h2 id=\"G的调度\"><a href=\"#G的调度\" class=\"headerlink\" title=\"G的调度\"></a>G的调度</h2><h2 id=\"抢占逻辑\"><a href=\"#抢占逻辑\" class=\"headerlink\" title=\"抢占逻辑\"></a>抢占逻辑</h2><h2 id=\"锁协程\"><a href=\"#锁协程\" class=\"headerlink\" title=\"锁协程\"></a>锁协程</h2><h2 id=\"GMP清理\"><a href=\"#GMP清理\" class=\"headerlink\" title=\"GMP清理\"></a>GMP清理</h2>"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2021-08-13T17:27:47.498Z","updated":"2021-08-13T17:27:47.498Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckti9vico00039gtjblfb2ouw","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"关于JVM的垃圾收集（1）","_content":"\n## 前言\n\n在java中，存在大量的设计概念，在概念中衍生出了很多理论基础，这类的学习对其他语言的深入理解有很大的帮助，因为本身java就是一个很大的知识库，于是，在飞机上，抽空下载了《深入理解JAVA虚拟机》，并学习了其中几张，发现了很多知识点在之前学习Golang时常常是没有提及的，也坚定了后续继续深入阅读java书籍的目标。\n\n### 关于垃圾收集\n\n垃圾收集主要还是针对堆内存中的对象，因为在栈中的对象，是随着线程的执行，会自动消逝，而堆中的对象，则是没有维护上级，对于C、C++来说，需要开发者自身通过free方法来释放，也衍生出了内存池的概念，而在更多编程语言中，例如最初的lisp、近期的golang，为了开发效率，不再提倡手动维护这类对象，而且交由应用程序运行时来管理对象的生命周期，这样也可以避免出现大量对象释放后，导致进程core的bug。\n\n而在整体的垃圾收集算法中，核心还是，如何判断一个对象是否已死？最初的死亡定义是：当一个对象不再有另一个对象引用时，便认为其已死亡。这样也就衍生出引用计数算法，这类算法在最初的PHP有实现，包括在redis中也是有简易的实现。该算法原理简单，效率高，对于简单场景是十分适用，但是该算法并解决不了最困难的问题：循环引用。\n\n所谓循环引用，就是2个对象互相引用，但是不在被其他对象引用，按理说，这类孤岛对象，算是僵尸对象，有人引用，但是不会再被使用，所以也应该被当做垃圾清理。而针对这类case，也衍生出了可达性分析算法，通过一个GC Roots的根对象来进行广度优先搜索，最终判断对象是否可达。这样也就可以解决循环引用的问题，而针对可达性分析算法，也衍生出各种各样的实现，其中也就包括golang的三色标记、php的n色标记、java的分代算法。\n\n## 分代垃圾收集算法 \n\n分代收集的核心理论是建立2个假说：\n\n1）弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。\n\n2）强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。\n\n因此，在java中，会分开新生代和老年代2块区域，针对新生代而言，大部分的对象都在垃圾收集时直接消亡，而剩余的对象逐步晋升为老年代中。这样就可以针对新生代和老年代进行分别垃圾清理。但中间还存在一个问题是当一个新生代对象被老年代引用时，原本只需要在新生代做垃圾收集算法，却必须要同时对老年代进行，这样完全没有达到分代的效果。于是，又引入了一个假说：\n\n3）跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。\n\n即存在互相引用的2个对象，最终肯定是同时生存、死亡，所以，应该同时晋升为老年代，这样跨代的问题便消失了。","source":"_posts/java-gc-1.md","raw":"---\ntitle: 关于JVM的垃圾收集（1）\n---\n\n## 前言\n\n在java中，存在大量的设计概念，在概念中衍生出了很多理论基础，这类的学习对其他语言的深入理解有很大的帮助，因为本身java就是一个很大的知识库，于是，在飞机上，抽空下载了《深入理解JAVA虚拟机》，并学习了其中几张，发现了很多知识点在之前学习Golang时常常是没有提及的，也坚定了后续继续深入阅读java书籍的目标。\n\n### 关于垃圾收集\n\n垃圾收集主要还是针对堆内存中的对象，因为在栈中的对象，是随着线程的执行，会自动消逝，而堆中的对象，则是没有维护上级，对于C、C++来说，需要开发者自身通过free方法来释放，也衍生出了内存池的概念，而在更多编程语言中，例如最初的lisp、近期的golang，为了开发效率，不再提倡手动维护这类对象，而且交由应用程序运行时来管理对象的生命周期，这样也可以避免出现大量对象释放后，导致进程core的bug。\n\n而在整体的垃圾收集算法中，核心还是，如何判断一个对象是否已死？最初的死亡定义是：当一个对象不再有另一个对象引用时，便认为其已死亡。这样也就衍生出引用计数算法，这类算法在最初的PHP有实现，包括在redis中也是有简易的实现。该算法原理简单，效率高，对于简单场景是十分适用，但是该算法并解决不了最困难的问题：循环引用。\n\n所谓循环引用，就是2个对象互相引用，但是不在被其他对象引用，按理说，这类孤岛对象，算是僵尸对象，有人引用，但是不会再被使用，所以也应该被当做垃圾清理。而针对这类case，也衍生出了可达性分析算法，通过一个GC Roots的根对象来进行广度优先搜索，最终判断对象是否可达。这样也就可以解决循环引用的问题，而针对可达性分析算法，也衍生出各种各样的实现，其中也就包括golang的三色标记、php的n色标记、java的分代算法。\n\n## 分代垃圾收集算法 \n\n分代收集的核心理论是建立2个假说：\n\n1）弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。\n\n2）强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。\n\n因此，在java中，会分开新生代和老年代2块区域，针对新生代而言，大部分的对象都在垃圾收集时直接消亡，而剩余的对象逐步晋升为老年代中。这样就可以针对新生代和老年代进行分别垃圾清理。但中间还存在一个问题是当一个新生代对象被老年代引用时，原本只需要在新生代做垃圾收集算法，却必须要同时对老年代进行，这样完全没有达到分代的效果。于是，又引入了一个假说：\n\n3）跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。\n\n即存在互相引用的2个对象，最终肯定是同时生存、死亡，所以，应该同时晋升为老年代，这样跨代的问题便消失了。","slug":"java-gc-1","published":1,"date":"2021-08-13T17:27:47.498Z","updated":"2021-08-13T17:27:47.498Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckti9vicp00049gtj56lv5idq","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在java中，存在大量的设计概念，在概念中衍生出了很多理论基础，这类的学习对其他语言的深入理解有很大的帮助，因为本身java就是一个很大的知识库，于是，在飞机上，抽空下载了《深入理解JAVA虚拟机》，并学习了其中几张，发现了很多知识点在之前学习Golang时常常是没有提及的，也坚定了后续继续深入阅读java书籍的目标。</p>\n<h3 id=\"关于垃圾收集\"><a href=\"#关于垃圾收集\" class=\"headerlink\" title=\"关于垃圾收集\"></a>关于垃圾收集</h3><p>垃圾收集主要还是针对堆内存中的对象，因为在栈中的对象，是随着线程的执行，会自动消逝，而堆中的对象，则是没有维护上级，对于C、C++来说，需要开发者自身通过free方法来释放，也衍生出了内存池的概念，而在更多编程语言中，例如最初的lisp、近期的golang，为了开发效率，不再提倡手动维护这类对象，而且交由应用程序运行时来管理对象的生命周期，这样也可以避免出现大量对象释放后，导致进程core的bug。</p>\n<p>而在整体的垃圾收集算法中，核心还是，如何判断一个对象是否已死？最初的死亡定义是：当一个对象不再有另一个对象引用时，便认为其已死亡。这样也就衍生出引用计数算法，这类算法在最初的PHP有实现，包括在redis中也是有简易的实现。该算法原理简单，效率高，对于简单场景是十分适用，但是该算法并解决不了最困难的问题：循环引用。</p>\n<p>所谓循环引用，就是2个对象互相引用，但是不在被其他对象引用，按理说，这类孤岛对象，算是僵尸对象，有人引用，但是不会再被使用，所以也应该被当做垃圾清理。而针对这类case，也衍生出了可达性分析算法，通过一个GC Roots的根对象来进行广度优先搜索，最终判断对象是否可达。这样也就可以解决循环引用的问题，而针对可达性分析算法，也衍生出各种各样的实现，其中也就包括golang的三色标记、php的n色标记、java的分代算法。</p>\n<h2 id=\"分代垃圾收集算法\"><a href=\"#分代垃圾收集算法\" class=\"headerlink\" title=\"分代垃圾收集算法\"></a>分代垃圾收集算法</h2><p>分代收集的核心理论是建立2个假说：</p>\n<p>1）弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。</p>\n<p>2）强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。</p>\n<p>因此，在java中，会分开新生代和老年代2块区域，针对新生代而言，大部分的对象都在垃圾收集时直接消亡，而剩余的对象逐步晋升为老年代中。这样就可以针对新生代和老年代进行分别垃圾清理。但中间还存在一个问题是当一个新生代对象被老年代引用时，原本只需要在新生代做垃圾收集算法，却必须要同时对老年代进行，这样完全没有达到分代的效果。于是，又引入了一个假说：</p>\n<p>3）跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。</p>\n<p>即存在互相引用的2个对象，最终肯定是同时生存、死亡，所以，应该同时晋升为老年代，这样跨代的问题便消失了。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在java中，存在大量的设计概念，在概念中衍生出了很多理论基础，这类的学习对其他语言的深入理解有很大的帮助，因为本身java就是一个很大的知识库，于是，在飞机上，抽空下载了《深入理解JAVA虚拟机》，并学习了其中几张，发现了很多知识点在之前学习Golang时常常是没有提及的，也坚定了后续继续深入阅读java书籍的目标。</p>\n<h3 id=\"关于垃圾收集\"><a href=\"#关于垃圾收集\" class=\"headerlink\" title=\"关于垃圾收集\"></a>关于垃圾收集</h3><p>垃圾收集主要还是针对堆内存中的对象，因为在栈中的对象，是随着线程的执行，会自动消逝，而堆中的对象，则是没有维护上级，对于C、C++来说，需要开发者自身通过free方法来释放，也衍生出了内存池的概念，而在更多编程语言中，例如最初的lisp、近期的golang，为了开发效率，不再提倡手动维护这类对象，而且交由应用程序运行时来管理对象的生命周期，这样也可以避免出现大量对象释放后，导致进程core的bug。</p>\n<p>而在整体的垃圾收集算法中，核心还是，如何判断一个对象是否已死？最初的死亡定义是：当一个对象不再有另一个对象引用时，便认为其已死亡。这样也就衍生出引用计数算法，这类算法在最初的PHP有实现，包括在redis中也是有简易的实现。该算法原理简单，效率高，对于简单场景是十分适用，但是该算法并解决不了最困难的问题：循环引用。</p>\n<p>所谓循环引用，就是2个对象互相引用，但是不在被其他对象引用，按理说，这类孤岛对象，算是僵尸对象，有人引用，但是不会再被使用，所以也应该被当做垃圾清理。而针对这类case，也衍生出了可达性分析算法，通过一个GC Roots的根对象来进行广度优先搜索，最终判断对象是否可达。这样也就可以解决循环引用的问题，而针对可达性分析算法，也衍生出各种各样的实现，其中也就包括golang的三色标记、php的n色标记、java的分代算法。</p>\n<h2 id=\"分代垃圾收集算法\"><a href=\"#分代垃圾收集算法\" class=\"headerlink\" title=\"分代垃圾收集算法\"></a>分代垃圾收集算法</h2><p>分代收集的核心理论是建立2个假说：</p>\n<p>1）弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。</p>\n<p>2）强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。</p>\n<p>因此，在java中，会分开新生代和老年代2块区域，针对新生代而言，大部分的对象都在垃圾收集时直接消亡，而剩余的对象逐步晋升为老年代中。这样就可以针对新生代和老年代进行分别垃圾清理。但中间还存在一个问题是当一个新生代对象被老年代引用时，原本只需要在新生代做垃圾收集算法，却必须要同时对老年代进行，这样完全没有达到分代的效果。于是，又引入了一个假说：</p>\n<p>3）跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。</p>\n<p>即存在互相引用的2个对象，最终肯定是同时生存、死亡，所以，应该同时晋升为老年代，这样跨代的问题便消失了。</p>\n"},{"title":"Golang-GMP模型","date":"2020-07-19T10:04:28.000Z","_content":"\n## 前言\n\n\n## GMP模型\n\n### 关于线程和协程\n\n在计算机操作系统中,轻量级进程（LWP）是一种实现多任务的方法。与普通进程相比，LWP与其他进程共享所有（或大部分）它的逻辑地址空间和系统资源；与线程相比，LWP有它自己的进程标识符，优先级，状态，以及栈和局部存储区，并和其他进程有着父子关系；这是和类Unix操作系统的系统调用vfork()生成的进程一样的。另外，线程既可由应用程序管理，又可由内核管理，而LWP只能由内核管理并像普通进程一样被调度。Linux内核是支持LWP的典型例子。\n\n![img](1767848-9c4b06362907280d.webp)\n\n### Golang中的模型\n\n有2个支持高并发的模型：CSP和Actor（erlang）。Go选择了CSP，Go为了提供更容易的并发使用方法，提供了2个重要的概念`goroutine`和`channel`。\n\n**goroutine**来自协程的概念，让一组可复用的函数运行在一组线程之上，即使有协程阻塞，该线程的其他协程也可以被`runtime`调度，转移到其他可运行的线程上。\n\n![img](3184f3.jpg)\n\n其实**老调度器**有4个缺点：详见[Scalable Go Scheduler Design Doc](https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit#!)\n\n1. 创建、销毁、调度G都需要每个M获取锁，这就形成了激烈的锁竞争\n2. M转移G会造成延迟和额外的系统开销。\n3. M中的mcache是用来存放小对象的，mcache和栈都和M关联造成了大量的内存开销和差的局部性\n4. 系统调用导致频繁的线程阻塞和取消阻塞操作增加了系统开销。\n\n所以Go语言在2012年重新设计了调度器方案（[Scalable Go Scheduler Design Doc](https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit#!)，[设计方案](https://golang.org/s/go11sched)）。\n\n![img](567399-d400f4b192f3dc48.webp)\n\n## 关于GMP模型\n\n### 关于Machine\n \nmachine代表一个线程，每次创建一个M的时候，都会有一个底层线程创建；所有的G任务，最终还是在M上执行。\n\nmachine的字段多达几十个，但将其进行粗劣的分类是可以明确m的具体职责：\n\n1. 特殊g的管理：g0、gsignal、curg\n2. p的管理：p、nextp、oldp\n3. 状态管理：locks、preemptoff、mallocing、throwing、dying、incgo、signalPending、blocked\n4. 锁的管理：lockedg、lockedExt、lockedInt、nextwaitm、waitlock\n5. cgo运行相关：ncgocall、ncgo、cgoCallersUse、cgoCallers\n\n从字段中可以看出，在m层，主要方向有几个关键词：锁、抢占、cgo、g与p的管理、信号。主要原因还是由于m是一个贴近操作系统的结构体，而操作系统的调度的核心问题也是锁、信号，阻塞等。\n\n> 如何解决m和m的绑定问题？\n\n#### 创建Machine\n\n创建m的时机有3类：sysmon抢占线程、templateThread模板线程、运行p。前2者是特殊的线程，不会进入调度系统中。创建m的方法是直接调用`runtime.newm`方法：\n```\nfunc newm(fn func(), _p_ *p) {\n\t// 分配一个m对象\n\tmp := allocm(_p_, fn)\n\t// 设置下一个执行的p\n\tmp.nextp.set(_p_)\n\t// 初始化系统信号拦截\n\tmp.sigmask = initSigmask\n    ... ...\n\tnewm1(mp)\n}\n```\n可以看出在m的创建流程中，具体分为2步：结构体的创建、线程的创建。在`allocm`方法中，核心是需要申请一个m的对象以及相关的g0空间，而针对不同的操作系统，g0的内存空间又区分为是使用系统分配，还是go指定。\n```\nfunc allocm(_p_ *p, fn func()) *m {\n\n    ... ...\n\tmp := new(m)\n\tmp.mstartfn = fn\n\tmcommoninit(mp)\n\n\tif iscgo || GOOS == \"solaris\" || GOOS == \"illumos\" || GOOS == \"windows\" || GOOS == \"plan9\" || GOOS == \"darwin\" {\n\t\tmp.g0 = malg(-1)\n\t} else {\n\t\tmp.g0 = malg(8192 * sys.StackGuardMultiplier)\n\t}\n\tmp.g0.m = mp\n\n\treturn mp\n}\n```\n而在`runtime.newm1`方法中，主要是直接调用`runtime.newosproc`方法，正如其名，就是用于创建一个系统的线程。\n```\nfunc newm1(mp *m) {\n    ... ...\n\tnewosproc(mp)\n    ... ...\n}\n\nfunc newosproc(mp *m) {\n\tstk := unsafe.Pointer(mp.g0.stack.hi)\n    ... ...\n\tvar oset sigset\n\tsigprocmask(_SIG_SETMASK, &sigset_all, &oset)\n\tret := clone(cloneFlags, stk, unsafe.Pointer(mp), unsafe.Pointer(mp.g0), unsafe.Pointer(funcPC(mstart)))\n\tsigprocmask(_SIG_SETMASK, &oset, nil)\n    ... ...\n}\n```\n\n### 关于Processor\n\n每一个运行的M都必须绑定一个P，就像线程必须在么一个CPU核上执行一样，由P来调度G在M上的运行，P的个数就是GOMAXPROCS（最大256），启动时固定的，一般不修改；\n\nprocessor的字段可以分为以下几类：\n\n1. 内存管理相关：mcache、pcache、mspancache、palloc\n2. 调度计数相关：schedtick、syscalltick、sysmontick\n3. cache相关：deferpool、deferpoolbuf、gFree、sudogcache、sudogbuf\n4. g调度相关：runqhead、runqtail、runq、runnext\n5. 定时器相关：timer0When、timersLock、timers、numTimers、adjustTimers、deletedTimers、\n6. gc相关：gcAssistTime、gcFractionalMarkTime、gcBgMarkWorker、gcMarkWorkerMode、gcMarkWorkerStartTime、gcw、wbBuf、runSafePointFn\n\n这几大方面主要是由于p本身的定位是执行器有关，当执行用户代码时，需要在效率和性能方面做到兼容，\n\np的创建流程代码并不难懂，方法由procresize来执行，也就是平时大家设置GOMAXPROCS计数，其中涉及到扩容和缩容操作。\n\n### 关于Goroutine\n\ngorountine也就是平时的协程，每次go调用的时候，都会创建一个G对象，它包括栈、指令指针以及对于调用goroutines很重要的其它信息\n\ngorountine的字段可以分为以下几类：\n\n1. 上下文信息：startpc、gopc、sigpc、sched、syscallsp、syscallpc、stktopsp、param\n2. 抢占相关：preempt、preemptStop、preemptShrink\n3. 栈相关：stack、stackguard0、stackguard1\n4. defer相关：\\_panic、\\_defer\n5. 锁相关：waiting、timer、selectDone、\n6. 信号相关：sigcode0、sigcode1、sigpc\n\n当然，gorountine不仅仅是上述的字段，还有大量的pprof的计数字段，本次暂时不做讨论。\n\n可以看出，g和m的字段中，都有信号、锁、抢占相关的字段，但是，为什么m中却没有栈信息，难道不需要栈信息？这就是g0协程的重要性，golang中为了做权限隔离，避免用户代码影响runtime的运行，专门抽象了g0协程执行。既然无法向操作系统中通过中断实现内核态切换，就考虑使用特殊协程，这样相关上下文切换逻辑是完全复用，所以，g0是一个只做权限隔离的协程，同时所有m都拥有一个g0。\n\n#### 创建Gorountine\n\n创建gorountine就是平时大家使用的`go func()`关键字。在编译阶段，关键字会变编译为`runtime.newproc`方法，同时会传入参数大小和函数指针fn。然后从堆栈中获取参数并调用`runtime.newproc1`方法。\n```\nfunc newproc(siz int32, fn *funcval) {\n\targp := add(unsafe.Pointer(&fn), sys.PtrSize)\n\tgp := getg()\n\tpc := getcallerpc()\n\tsystemstack(func() {\n\t\tnewproc1(fn, argp, siz, gp, pc)\n\t})\n}\n```\n在`runtime.newproc1`方法中具体可以分为3块逻辑：\n1. gorountine结构体创建\n2. gorountine对象的初始化\n3. 插入调度对象并唤醒p\n\n创建完的gorountine结构体最终会插入p中的runq链表中。\n\n## 调度实现\n\n从m的创建流程中，可以看到`newosproc`方法是第四个参数，也就是系统线程的入口函数。线程创建完成后，操作系统会根据系统调度算法运行线程，`runtime.mstart`也就是线程的初始化方法。\n\n### 线程初始化\n\n`runtime.mstart`方法中，优先将栈的检查地址更新，这是因为如果是操作系统自动生成的堆栈，线程运行前是无法确定的。之后会调用`runtime.mstart1`方法执行进一步的初始化方法。最后，针对特殊的线程（被lockg的线程），会执行`runtime.mexit`方法。\n```\nfunc mstart() {\n\t_g_ := getg()\n\n\tosStack := _g_.stack.lo == 0\n\tif osStack {\n\t\tsize := _g_.stack.hi\n\t\tif size == 0 {\n\t\t\tsize = 8192 * sys.StackGuardMultiplier\n\t\t}\n\t\t_g_.stack.hi = uintptr(noescape(unsafe.Pointer(&size)))\n\t\t_g_.stack.lo = _g_.stack.hi - size + 1024\n\t}\n\t_g_.stackguard0 = _g_.stack.lo + _StackGuard\n\t_g_.stackguard1 = _g_.stackguard0\n\tmstart1()\n\n\tmexit(osStack)\n}\n```\n继续看`runtime.mstart1`方法，也还是一系列的初始化方法：\n1. 保存调用寄存器信息，主要用于当用户g切换至g0时，需要恢复的上下文\n2. 初始化信号处理方法，因为每个线程都需要自己的信号处理g\n3. 执行mstartfn方法，这个方法是针对sysmon这类的特殊线程实现的功能，使当前线程不进入调度循环中。\n\n执行完上述的初始化操作后，当前线程就将`nextp`字段转正进行绑定，并进入`runtime.schedule`方法中调度。\n\n### 线程循环\n\n在调用循环中，存在3个因素影响调度：当前是否需要stw、当前是否获取到g、当前m是否被g绑定。三者中获取g是调度循环的主流程，其他2者也是golang的特殊功能。所以先抽离出获取g的整体流程。\n\n#### 获取Gorountine\n\n在获取gorountine流程中，可以分为3部分：\n1. 若当前p不存在g，或者调度计数满足61次，则从全局中获取g运行\n2. 产生从p本地队列中获取g\n3. 本地和全局都获取不到时，则在`findrunable`方法中阻塞获取g\n\n```\nfunc schedule() {\n    ... ... \ntop:\n\tif gp == nil {\n\t\tif _g_.m.p.ptr().schedtick%61 == 0 && sched.runqsize > 0 {\n\t\t\tlock(&sched.lock)\n\t\t\tgp = globrunqget(_g_.m.p.ptr(), 1)\n\t\t\tunlock(&sched.lock)\n\t\t}\n\t}\n\tif gp == nil {\n\t\tgp, inheritTime = runqget(_g_.m.p.ptr())\n\t\t// We can see gp != nil here even if the M is spinning,\n\t\t// if checkTimers added a local goroutine via goready.\n\t}\n\t// 如果实在没找到，那就强行找一个可用的\n\tif gp == nil {\n\t\tgp, inheritTime = findrunnable() // blocks until work is available\n\t}\n    execute(gp, inheritTime)\n}\n```\n\n##### globrunqget方法\n在从全局队列中获取g时，会从全局队列中获取g，并同时迁移`1/len(allp)`个数的g到本地队列中。\n```\nfunc globrunqget(_p_ *p, max int32) *g {\n\tn := sched.runqsize/gomaxprocs + 1\n\tif n > int32(len(_p_.runq))/2 {\n\t\tn = int32(len(_p_.runq)) / 2\n\t}\n\n\tsched.runqsize -= n\n\n\tgp := sched.runq.pop()\n\tn--\n\tfor ; n > 0; n-- {\n\t\tgp1 := sched.runq.pop()\n\t\trunqput(_p_, gp1, false)\n\t}\n\treturn gp\n}\n```\n\n##### runqget方法\n而在获取本地队列g的时候，优先会尝试获取`runnext`字段的g，在从`runq`中获取头部的g对象。当然由于`runq`是通过循环队列实现，所以gp是通过下标取余获取。\n```\nfunc runqget(_p_ *p) (gp *g, inheritTime bool) {\n\tfor {\n\t\tnext := _p_.runnext\n\t\tif next == 0 {\n\t\t\tbreak\n\t\t}\n\t\tif _p_.runnext.cas(next, 0) {\n\t\t\treturn next.ptr(), true\n\t\t}\n\t}\n\n\tfor {\n\t\th := atomic.LoadAcq(&_p_.runqhead) // load-acquire, synchronize with other consumers\n\t\tt := _p_.runqtail\n\t\tif t == h {\n\t\t\treturn nil, false\n\t\t}\n\t\tgp := _p_.runq[h%uint32(len(_p_.runq))].ptr()\n\t\tif atomic.CasRel(&_p_.runqhead, h, h+1) { // cas-release, commits consume\n\t\t\treturn gp, false\n\t\t}\n\t}\n}\n```\n##### findrunnable方法\n\n由于前2个方法实在获取不到可运行的g，所以在`findrunnable`方法中会不断的在各个可能存在可运行g的地方查询。具体的查询流程如下：\n1. 检查finalizer是否存在析构对象\n2. 检查本地对象是否存在可用g\n3. 查询全局队列是否存在可用g\n4. 非阻塞检查netpoll\n5. 如果大家都空闲中，或者自旋的m超过了忙碌的p，则进入强制查询阶段\n6. 再不济，随机4次去其他的p中窃取g\n\n上述流程实在找不到，m就不在持有p，然后开始特殊判断阶段。m开始循环判断是否存在可运行的g。判断区域还是从全局队列中、所有p的本地队列中以及netpoll三个方面。最终如果实在获取不到，则休眠当前m，等待有可用的p来唤醒。\n\n\n#### 执行Gorountine\n\n获取到可执行的g之后，就需要调用`runtime.execute`方法，主要针对g做一些变量赋值：\n```\n\tcasgstatus(gp, _Grunnable, _Grunning)\n\tgp.waitsince = 0\n\tgp.preempt = false\n\tgp.stackguard0 = gp.stack.lo + _StackGuard\n\tif !inheritTime {\n\t\t_g_.m.p.ptr().schedtick++\n\t}\n\t_g_.m.curg = gp\n\tgp.m = _g_.m\n```\n赋值完后，会调用`runtime.gogo`方法进行协程的上下文切换，将原有的g0协程，切换至gp协程。\n\n## 调度工具\n\n- trace\n- pprof\n\n## 相关主题\n- lock ranking\n\n\n## 相关链接\nhttps://docs.oracle.com/cd/E19683-01/806-6867/guide-60747/index.html\nhttps://www.linuxjournal.com/article/3184\n\n","source":"_posts/golang-gmp.md","raw":"---\ntitle: Golang-GMP模型\ndate: 2020-07-19 18:04:28\ntags:\n---\n\n## 前言\n\n\n## GMP模型\n\n### 关于线程和协程\n\n在计算机操作系统中,轻量级进程（LWP）是一种实现多任务的方法。与普通进程相比，LWP与其他进程共享所有（或大部分）它的逻辑地址空间和系统资源；与线程相比，LWP有它自己的进程标识符，优先级，状态，以及栈和局部存储区，并和其他进程有着父子关系；这是和类Unix操作系统的系统调用vfork()生成的进程一样的。另外，线程既可由应用程序管理，又可由内核管理，而LWP只能由内核管理并像普通进程一样被调度。Linux内核是支持LWP的典型例子。\n\n![img](1767848-9c4b06362907280d.webp)\n\n### Golang中的模型\n\n有2个支持高并发的模型：CSP和Actor（erlang）。Go选择了CSP，Go为了提供更容易的并发使用方法，提供了2个重要的概念`goroutine`和`channel`。\n\n**goroutine**来自协程的概念，让一组可复用的函数运行在一组线程之上，即使有协程阻塞，该线程的其他协程也可以被`runtime`调度，转移到其他可运行的线程上。\n\n![img](3184f3.jpg)\n\n其实**老调度器**有4个缺点：详见[Scalable Go Scheduler Design Doc](https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit#!)\n\n1. 创建、销毁、调度G都需要每个M获取锁，这就形成了激烈的锁竞争\n2. M转移G会造成延迟和额外的系统开销。\n3. M中的mcache是用来存放小对象的，mcache和栈都和M关联造成了大量的内存开销和差的局部性\n4. 系统调用导致频繁的线程阻塞和取消阻塞操作增加了系统开销。\n\n所以Go语言在2012年重新设计了调度器方案（[Scalable Go Scheduler Design Doc](https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit#!)，[设计方案](https://golang.org/s/go11sched)）。\n\n![img](567399-d400f4b192f3dc48.webp)\n\n## 关于GMP模型\n\n### 关于Machine\n \nmachine代表一个线程，每次创建一个M的时候，都会有一个底层线程创建；所有的G任务，最终还是在M上执行。\n\nmachine的字段多达几十个，但将其进行粗劣的分类是可以明确m的具体职责：\n\n1. 特殊g的管理：g0、gsignal、curg\n2. p的管理：p、nextp、oldp\n3. 状态管理：locks、preemptoff、mallocing、throwing、dying、incgo、signalPending、blocked\n4. 锁的管理：lockedg、lockedExt、lockedInt、nextwaitm、waitlock\n5. cgo运行相关：ncgocall、ncgo、cgoCallersUse、cgoCallers\n\n从字段中可以看出，在m层，主要方向有几个关键词：锁、抢占、cgo、g与p的管理、信号。主要原因还是由于m是一个贴近操作系统的结构体，而操作系统的调度的核心问题也是锁、信号，阻塞等。\n\n> 如何解决m和m的绑定问题？\n\n#### 创建Machine\n\n创建m的时机有3类：sysmon抢占线程、templateThread模板线程、运行p。前2者是特殊的线程，不会进入调度系统中。创建m的方法是直接调用`runtime.newm`方法：\n```\nfunc newm(fn func(), _p_ *p) {\n\t// 分配一个m对象\n\tmp := allocm(_p_, fn)\n\t// 设置下一个执行的p\n\tmp.nextp.set(_p_)\n\t// 初始化系统信号拦截\n\tmp.sigmask = initSigmask\n    ... ...\n\tnewm1(mp)\n}\n```\n可以看出在m的创建流程中，具体分为2步：结构体的创建、线程的创建。在`allocm`方法中，核心是需要申请一个m的对象以及相关的g0空间，而针对不同的操作系统，g0的内存空间又区分为是使用系统分配，还是go指定。\n```\nfunc allocm(_p_ *p, fn func()) *m {\n\n    ... ...\n\tmp := new(m)\n\tmp.mstartfn = fn\n\tmcommoninit(mp)\n\n\tif iscgo || GOOS == \"solaris\" || GOOS == \"illumos\" || GOOS == \"windows\" || GOOS == \"plan9\" || GOOS == \"darwin\" {\n\t\tmp.g0 = malg(-1)\n\t} else {\n\t\tmp.g0 = malg(8192 * sys.StackGuardMultiplier)\n\t}\n\tmp.g0.m = mp\n\n\treturn mp\n}\n```\n而在`runtime.newm1`方法中，主要是直接调用`runtime.newosproc`方法，正如其名，就是用于创建一个系统的线程。\n```\nfunc newm1(mp *m) {\n    ... ...\n\tnewosproc(mp)\n    ... ...\n}\n\nfunc newosproc(mp *m) {\n\tstk := unsafe.Pointer(mp.g0.stack.hi)\n    ... ...\n\tvar oset sigset\n\tsigprocmask(_SIG_SETMASK, &sigset_all, &oset)\n\tret := clone(cloneFlags, stk, unsafe.Pointer(mp), unsafe.Pointer(mp.g0), unsafe.Pointer(funcPC(mstart)))\n\tsigprocmask(_SIG_SETMASK, &oset, nil)\n    ... ...\n}\n```\n\n### 关于Processor\n\n每一个运行的M都必须绑定一个P，就像线程必须在么一个CPU核上执行一样，由P来调度G在M上的运行，P的个数就是GOMAXPROCS（最大256），启动时固定的，一般不修改；\n\nprocessor的字段可以分为以下几类：\n\n1. 内存管理相关：mcache、pcache、mspancache、palloc\n2. 调度计数相关：schedtick、syscalltick、sysmontick\n3. cache相关：deferpool、deferpoolbuf、gFree、sudogcache、sudogbuf\n4. g调度相关：runqhead、runqtail、runq、runnext\n5. 定时器相关：timer0When、timersLock、timers、numTimers、adjustTimers、deletedTimers、\n6. gc相关：gcAssistTime、gcFractionalMarkTime、gcBgMarkWorker、gcMarkWorkerMode、gcMarkWorkerStartTime、gcw、wbBuf、runSafePointFn\n\n这几大方面主要是由于p本身的定位是执行器有关，当执行用户代码时，需要在效率和性能方面做到兼容，\n\np的创建流程代码并不难懂，方法由procresize来执行，也就是平时大家设置GOMAXPROCS计数，其中涉及到扩容和缩容操作。\n\n### 关于Goroutine\n\ngorountine也就是平时的协程，每次go调用的时候，都会创建一个G对象，它包括栈、指令指针以及对于调用goroutines很重要的其它信息\n\ngorountine的字段可以分为以下几类：\n\n1. 上下文信息：startpc、gopc、sigpc、sched、syscallsp、syscallpc、stktopsp、param\n2. 抢占相关：preempt、preemptStop、preemptShrink\n3. 栈相关：stack、stackguard0、stackguard1\n4. defer相关：\\_panic、\\_defer\n5. 锁相关：waiting、timer、selectDone、\n6. 信号相关：sigcode0、sigcode1、sigpc\n\n当然，gorountine不仅仅是上述的字段，还有大量的pprof的计数字段，本次暂时不做讨论。\n\n可以看出，g和m的字段中，都有信号、锁、抢占相关的字段，但是，为什么m中却没有栈信息，难道不需要栈信息？这就是g0协程的重要性，golang中为了做权限隔离，避免用户代码影响runtime的运行，专门抽象了g0协程执行。既然无法向操作系统中通过中断实现内核态切换，就考虑使用特殊协程，这样相关上下文切换逻辑是完全复用，所以，g0是一个只做权限隔离的协程，同时所有m都拥有一个g0。\n\n#### 创建Gorountine\n\n创建gorountine就是平时大家使用的`go func()`关键字。在编译阶段，关键字会变编译为`runtime.newproc`方法，同时会传入参数大小和函数指针fn。然后从堆栈中获取参数并调用`runtime.newproc1`方法。\n```\nfunc newproc(siz int32, fn *funcval) {\n\targp := add(unsafe.Pointer(&fn), sys.PtrSize)\n\tgp := getg()\n\tpc := getcallerpc()\n\tsystemstack(func() {\n\t\tnewproc1(fn, argp, siz, gp, pc)\n\t})\n}\n```\n在`runtime.newproc1`方法中具体可以分为3块逻辑：\n1. gorountine结构体创建\n2. gorountine对象的初始化\n3. 插入调度对象并唤醒p\n\n创建完的gorountine结构体最终会插入p中的runq链表中。\n\n## 调度实现\n\n从m的创建流程中，可以看到`newosproc`方法是第四个参数，也就是系统线程的入口函数。线程创建完成后，操作系统会根据系统调度算法运行线程，`runtime.mstart`也就是线程的初始化方法。\n\n### 线程初始化\n\n`runtime.mstart`方法中，优先将栈的检查地址更新，这是因为如果是操作系统自动生成的堆栈，线程运行前是无法确定的。之后会调用`runtime.mstart1`方法执行进一步的初始化方法。最后，针对特殊的线程（被lockg的线程），会执行`runtime.mexit`方法。\n```\nfunc mstart() {\n\t_g_ := getg()\n\n\tosStack := _g_.stack.lo == 0\n\tif osStack {\n\t\tsize := _g_.stack.hi\n\t\tif size == 0 {\n\t\t\tsize = 8192 * sys.StackGuardMultiplier\n\t\t}\n\t\t_g_.stack.hi = uintptr(noescape(unsafe.Pointer(&size)))\n\t\t_g_.stack.lo = _g_.stack.hi - size + 1024\n\t}\n\t_g_.stackguard0 = _g_.stack.lo + _StackGuard\n\t_g_.stackguard1 = _g_.stackguard0\n\tmstart1()\n\n\tmexit(osStack)\n}\n```\n继续看`runtime.mstart1`方法，也还是一系列的初始化方法：\n1. 保存调用寄存器信息，主要用于当用户g切换至g0时，需要恢复的上下文\n2. 初始化信号处理方法，因为每个线程都需要自己的信号处理g\n3. 执行mstartfn方法，这个方法是针对sysmon这类的特殊线程实现的功能，使当前线程不进入调度循环中。\n\n执行完上述的初始化操作后，当前线程就将`nextp`字段转正进行绑定，并进入`runtime.schedule`方法中调度。\n\n### 线程循环\n\n在调用循环中，存在3个因素影响调度：当前是否需要stw、当前是否获取到g、当前m是否被g绑定。三者中获取g是调度循环的主流程，其他2者也是golang的特殊功能。所以先抽离出获取g的整体流程。\n\n#### 获取Gorountine\n\n在获取gorountine流程中，可以分为3部分：\n1. 若当前p不存在g，或者调度计数满足61次，则从全局中获取g运行\n2. 产生从p本地队列中获取g\n3. 本地和全局都获取不到时，则在`findrunable`方法中阻塞获取g\n\n```\nfunc schedule() {\n    ... ... \ntop:\n\tif gp == nil {\n\t\tif _g_.m.p.ptr().schedtick%61 == 0 && sched.runqsize > 0 {\n\t\t\tlock(&sched.lock)\n\t\t\tgp = globrunqget(_g_.m.p.ptr(), 1)\n\t\t\tunlock(&sched.lock)\n\t\t}\n\t}\n\tif gp == nil {\n\t\tgp, inheritTime = runqget(_g_.m.p.ptr())\n\t\t// We can see gp != nil here even if the M is spinning,\n\t\t// if checkTimers added a local goroutine via goready.\n\t}\n\t// 如果实在没找到，那就强行找一个可用的\n\tif gp == nil {\n\t\tgp, inheritTime = findrunnable() // blocks until work is available\n\t}\n    execute(gp, inheritTime)\n}\n```\n\n##### globrunqget方法\n在从全局队列中获取g时，会从全局队列中获取g，并同时迁移`1/len(allp)`个数的g到本地队列中。\n```\nfunc globrunqget(_p_ *p, max int32) *g {\n\tn := sched.runqsize/gomaxprocs + 1\n\tif n > int32(len(_p_.runq))/2 {\n\t\tn = int32(len(_p_.runq)) / 2\n\t}\n\n\tsched.runqsize -= n\n\n\tgp := sched.runq.pop()\n\tn--\n\tfor ; n > 0; n-- {\n\t\tgp1 := sched.runq.pop()\n\t\trunqput(_p_, gp1, false)\n\t}\n\treturn gp\n}\n```\n\n##### runqget方法\n而在获取本地队列g的时候，优先会尝试获取`runnext`字段的g，在从`runq`中获取头部的g对象。当然由于`runq`是通过循环队列实现，所以gp是通过下标取余获取。\n```\nfunc runqget(_p_ *p) (gp *g, inheritTime bool) {\n\tfor {\n\t\tnext := _p_.runnext\n\t\tif next == 0 {\n\t\t\tbreak\n\t\t}\n\t\tif _p_.runnext.cas(next, 0) {\n\t\t\treturn next.ptr(), true\n\t\t}\n\t}\n\n\tfor {\n\t\th := atomic.LoadAcq(&_p_.runqhead) // load-acquire, synchronize with other consumers\n\t\tt := _p_.runqtail\n\t\tif t == h {\n\t\t\treturn nil, false\n\t\t}\n\t\tgp := _p_.runq[h%uint32(len(_p_.runq))].ptr()\n\t\tif atomic.CasRel(&_p_.runqhead, h, h+1) { // cas-release, commits consume\n\t\t\treturn gp, false\n\t\t}\n\t}\n}\n```\n##### findrunnable方法\n\n由于前2个方法实在获取不到可运行的g，所以在`findrunnable`方法中会不断的在各个可能存在可运行g的地方查询。具体的查询流程如下：\n1. 检查finalizer是否存在析构对象\n2. 检查本地对象是否存在可用g\n3. 查询全局队列是否存在可用g\n4. 非阻塞检查netpoll\n5. 如果大家都空闲中，或者自旋的m超过了忙碌的p，则进入强制查询阶段\n6. 再不济，随机4次去其他的p中窃取g\n\n上述流程实在找不到，m就不在持有p，然后开始特殊判断阶段。m开始循环判断是否存在可运行的g。判断区域还是从全局队列中、所有p的本地队列中以及netpoll三个方面。最终如果实在获取不到，则休眠当前m，等待有可用的p来唤醒。\n\n\n#### 执行Gorountine\n\n获取到可执行的g之后，就需要调用`runtime.execute`方法，主要针对g做一些变量赋值：\n```\n\tcasgstatus(gp, _Grunnable, _Grunning)\n\tgp.waitsince = 0\n\tgp.preempt = false\n\tgp.stackguard0 = gp.stack.lo + _StackGuard\n\tif !inheritTime {\n\t\t_g_.m.p.ptr().schedtick++\n\t}\n\t_g_.m.curg = gp\n\tgp.m = _g_.m\n```\n赋值完后，会调用`runtime.gogo`方法进行协程的上下文切换，将原有的g0协程，切换至gp协程。\n\n## 调度工具\n\n- trace\n- pprof\n\n## 相关主题\n- lock ranking\n\n\n## 相关链接\nhttps://docs.oracle.com/cd/E19683-01/806-6867/guide-60747/index.html\nhttps://www.linuxjournal.com/article/3184\n\n","slug":"golang-gmp","published":1,"updated":"2021-08-13T17:27:47.498Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckti9vicq00059gtj0vjf9lt8","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><h2 id=\"GMP模型\"><a href=\"#GMP模型\" class=\"headerlink\" title=\"GMP模型\"></a>GMP模型</h2><h3 id=\"关于线程和协程\"><a href=\"#关于线程和协程\" class=\"headerlink\" title=\"关于线程和协程\"></a>关于线程和协程</h3><p>在计算机操作系统中,轻量级进程（LWP）是一种实现多任务的方法。与普通进程相比，LWP与其他进程共享所有（或大部分）它的逻辑地址空间和系统资源；与线程相比，LWP有它自己的进程标识符，优先级，状态，以及栈和局部存储区，并和其他进程有着父子关系；这是和类Unix操作系统的系统调用vfork()生成的进程一样的。另外，线程既可由应用程序管理，又可由内核管理，而LWP只能由内核管理并像普通进程一样被调度。Linux内核是支持LWP的典型例子。</p>\n<p><img src=\"1767848-9c4b06362907280d.webp\" alt=\"img\"></p>\n<h3 id=\"Golang中的模型\"><a href=\"#Golang中的模型\" class=\"headerlink\" title=\"Golang中的模型\"></a>Golang中的模型</h3><p>有2个支持高并发的模型：CSP和Actor（erlang）。Go选择了CSP，Go为了提供更容易的并发使用方法，提供了2个重要的概念<code>goroutine</code>和<code>channel</code>。</p>\n<p><strong>goroutine</strong>来自协程的概念，让一组可复用的函数运行在一组线程之上，即使有协程阻塞，该线程的其他协程也可以被<code>runtime</code>调度，转移到其他可运行的线程上。</p>\n<p><img src=\"3184f3.jpg\" alt=\"img\"></p>\n<p>其实<strong>老调度器</strong>有4个缺点：详见<a href=\"https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit#!\" target=\"_blank\" rel=\"noopener\">Scalable Go Scheduler Design Doc</a></p>\n<ol>\n<li>创建、销毁、调度G都需要每个M获取锁，这就形成了激烈的锁竞争</li>\n<li>M转移G会造成延迟和额外的系统开销。</li>\n<li>M中的mcache是用来存放小对象的，mcache和栈都和M关联造成了大量的内存开销和差的局部性</li>\n<li>系统调用导致频繁的线程阻塞和取消阻塞操作增加了系统开销。</li>\n</ol>\n<p>所以Go语言在2012年重新设计了调度器方案（<a href=\"https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit#!\" target=\"_blank\" rel=\"noopener\">Scalable Go Scheduler Design Doc</a>，<a href=\"https://golang.org/s/go11sched\" target=\"_blank\" rel=\"noopener\">设计方案</a>）。</p>\n<p><img src=\"567399-d400f4b192f3dc48.webp\" alt=\"img\"></p>\n<h2 id=\"关于GMP模型\"><a href=\"#关于GMP模型\" class=\"headerlink\" title=\"关于GMP模型\"></a>关于GMP模型</h2><h3 id=\"关于Machine\"><a href=\"#关于Machine\" class=\"headerlink\" title=\"关于Machine\"></a>关于Machine</h3><p>machine代表一个线程，每次创建一个M的时候，都会有一个底层线程创建；所有的G任务，最终还是在M上执行。</p>\n<p>machine的字段多达几十个，但将其进行粗劣的分类是可以明确m的具体职责：</p>\n<ol>\n<li>特殊g的管理：g0、gsignal、curg</li>\n<li>p的管理：p、nextp、oldp</li>\n<li>状态管理：locks、preemptoff、mallocing、throwing、dying、incgo、signalPending、blocked</li>\n<li>锁的管理：lockedg、lockedExt、lockedInt、nextwaitm、waitlock</li>\n<li>cgo运行相关：ncgocall、ncgo、cgoCallersUse、cgoCallers</li>\n</ol>\n<p>从字段中可以看出，在m层，主要方向有几个关键词：锁、抢占、cgo、g与p的管理、信号。主要原因还是由于m是一个贴近操作系统的结构体，而操作系统的调度的核心问题也是锁、信号，阻塞等。</p>\n<blockquote>\n<p>如何解决m和m的绑定问题？</p>\n</blockquote>\n<h4 id=\"创建Machine\"><a href=\"#创建Machine\" class=\"headerlink\" title=\"创建Machine\"></a>创建Machine</h4><p>创建m的时机有3类：sysmon抢占线程、templateThread模板线程、运行p。前2者是特殊的线程，不会进入调度系统中。创建m的方法是直接调用<code>runtime.newm</code>方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func newm(fn func(), _p_ *p) &#123;</span><br><span class=\"line\">\t&#x2F;&#x2F; 分配一个m对象</span><br><span class=\"line\">\tmp :&#x3D; allocm(_p_, fn)</span><br><span class=\"line\">\t&#x2F;&#x2F; 设置下一个执行的p</span><br><span class=\"line\">\tmp.nextp.set(_p_)</span><br><span class=\"line\">\t&#x2F;&#x2F; 初始化系统信号拦截</span><br><span class=\"line\">\tmp.sigmask &#x3D; initSigmask</span><br><span class=\"line\">    ... ...</span><br><span class=\"line\">\tnewm1(mp)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出在m的创建流程中，具体分为2步：结构体的创建、线程的创建。在<code>allocm</code>方法中，核心是需要申请一个m的对象以及相关的g0空间，而针对不同的操作系统，g0的内存空间又区分为是使用系统分配，还是go指定。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func allocm(_p_ *p, fn func()) *m &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ... ...</span><br><span class=\"line\">\tmp :&#x3D; new(m)</span><br><span class=\"line\">\tmp.mstartfn &#x3D; fn</span><br><span class=\"line\">\tmcommoninit(mp)</span><br><span class=\"line\"></span><br><span class=\"line\">\tif iscgo || GOOS &#x3D;&#x3D; &quot;solaris&quot; || GOOS &#x3D;&#x3D; &quot;illumos&quot; || GOOS &#x3D;&#x3D; &quot;windows&quot; || GOOS &#x3D;&#x3D; &quot;plan9&quot; || GOOS &#x3D;&#x3D; &quot;darwin&quot; &#123;</span><br><span class=\"line\">\t\tmp.g0 &#x3D; malg(-1)</span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t\tmp.g0 &#x3D; malg(8192 * sys.StackGuardMultiplier)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tmp.g0.m &#x3D; mp</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn mp</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而在<code>runtime.newm1</code>方法中，主要是直接调用<code>runtime.newosproc</code>方法，正如其名，就是用于创建一个系统的线程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func newm1(mp *m) &#123;</span><br><span class=\"line\">    ... ...</span><br><span class=\"line\">\tnewosproc(mp)</span><br><span class=\"line\">    ... ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func newosproc(mp *m) &#123;</span><br><span class=\"line\">\tstk :&#x3D; unsafe.Pointer(mp.g0.stack.hi)</span><br><span class=\"line\">    ... ...</span><br><span class=\"line\">\tvar oset sigset</span><br><span class=\"line\">\tsigprocmask(_SIG_SETMASK, &amp;sigset_all, &amp;oset)</span><br><span class=\"line\">\tret :&#x3D; clone(cloneFlags, stk, unsafe.Pointer(mp), unsafe.Pointer(mp.g0), unsafe.Pointer(funcPC(mstart)))</span><br><span class=\"line\">\tsigprocmask(_SIG_SETMASK, &amp;oset, nil)</span><br><span class=\"line\">    ... ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关于Processor\"><a href=\"#关于Processor\" class=\"headerlink\" title=\"关于Processor\"></a>关于Processor</h3><p>每一个运行的M都必须绑定一个P，就像线程必须在么一个CPU核上执行一样，由P来调度G在M上的运行，P的个数就是GOMAXPROCS（最大256），启动时固定的，一般不修改；</p>\n<p>processor的字段可以分为以下几类：</p>\n<ol>\n<li>内存管理相关：mcache、pcache、mspancache、palloc</li>\n<li>调度计数相关：schedtick、syscalltick、sysmontick</li>\n<li>cache相关：deferpool、deferpoolbuf、gFree、sudogcache、sudogbuf</li>\n<li>g调度相关：runqhead、runqtail、runq、runnext</li>\n<li>定时器相关：timer0When、timersLock、timers、numTimers、adjustTimers、deletedTimers、</li>\n<li>gc相关：gcAssistTime、gcFractionalMarkTime、gcBgMarkWorker、gcMarkWorkerMode、gcMarkWorkerStartTime、gcw、wbBuf、runSafePointFn</li>\n</ol>\n<p>这几大方面主要是由于p本身的定位是执行器有关，当执行用户代码时，需要在效率和性能方面做到兼容，</p>\n<p>p的创建流程代码并不难懂，方法由procresize来执行，也就是平时大家设置GOMAXPROCS计数，其中涉及到扩容和缩容操作。</p>\n<h3 id=\"关于Goroutine\"><a href=\"#关于Goroutine\" class=\"headerlink\" title=\"关于Goroutine\"></a>关于Goroutine</h3><p>gorountine也就是平时的协程，每次go调用的时候，都会创建一个G对象，它包括栈、指令指针以及对于调用goroutines很重要的其它信息</p>\n<p>gorountine的字段可以分为以下几类：</p>\n<ol>\n<li>上下文信息：startpc、gopc、sigpc、sched、syscallsp、syscallpc、stktopsp、param</li>\n<li>抢占相关：preempt、preemptStop、preemptShrink</li>\n<li>栈相关：stack、stackguard0、stackguard1</li>\n<li>defer相关：_panic、_defer</li>\n<li>锁相关：waiting、timer、selectDone、</li>\n<li>信号相关：sigcode0、sigcode1、sigpc</li>\n</ol>\n<p>当然，gorountine不仅仅是上述的字段，还有大量的pprof的计数字段，本次暂时不做讨论。</p>\n<p>可以看出，g和m的字段中，都有信号、锁、抢占相关的字段，但是，为什么m中却没有栈信息，难道不需要栈信息？这就是g0协程的重要性，golang中为了做权限隔离，避免用户代码影响runtime的运行，专门抽象了g0协程执行。既然无法向操作系统中通过中断实现内核态切换，就考虑使用特殊协程，这样相关上下文切换逻辑是完全复用，所以，g0是一个只做权限隔离的协程，同时所有m都拥有一个g0。</p>\n<h4 id=\"创建Gorountine\"><a href=\"#创建Gorountine\" class=\"headerlink\" title=\"创建Gorountine\"></a>创建Gorountine</h4><p>创建gorountine就是平时大家使用的<code>go func()</code>关键字。在编译阶段，关键字会变编译为<code>runtime.newproc</code>方法，同时会传入参数大小和函数指针fn。然后从堆栈中获取参数并调用<code>runtime.newproc1</code>方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func newproc(siz int32, fn *funcval) &#123;</span><br><span class=\"line\">\targp :&#x3D; add(unsafe.Pointer(&amp;fn), sys.PtrSize)</span><br><span class=\"line\">\tgp :&#x3D; getg()</span><br><span class=\"line\">\tpc :&#x3D; getcallerpc()</span><br><span class=\"line\">\tsystemstack(func() &#123;</span><br><span class=\"line\">\t\tnewproc1(fn, argp, siz, gp, pc)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在<code>runtime.newproc1</code>方法中具体可以分为3块逻辑：</p>\n<ol>\n<li>gorountine结构体创建</li>\n<li>gorountine对象的初始化</li>\n<li>插入调度对象并唤醒p</li>\n</ol>\n<p>创建完的gorountine结构体最终会插入p中的runq链表中。</p>\n<h2 id=\"调度实现\"><a href=\"#调度实现\" class=\"headerlink\" title=\"调度实现\"></a>调度实现</h2><p>从m的创建流程中，可以看到<code>newosproc</code>方法是第四个参数，也就是系统线程的入口函数。线程创建完成后，操作系统会根据系统调度算法运行线程，<code>runtime.mstart</code>也就是线程的初始化方法。</p>\n<h3 id=\"线程初始化\"><a href=\"#线程初始化\" class=\"headerlink\" title=\"线程初始化\"></a>线程初始化</h3><p><code>runtime.mstart</code>方法中，优先将栈的检查地址更新，这是因为如果是操作系统自动生成的堆栈，线程运行前是无法确定的。之后会调用<code>runtime.mstart1</code>方法执行进一步的初始化方法。最后，针对特殊的线程（被lockg的线程），会执行<code>runtime.mexit</code>方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func mstart() &#123;</span><br><span class=\"line\">\t_g_ :&#x3D; getg()</span><br><span class=\"line\"></span><br><span class=\"line\">\tosStack :&#x3D; _g_.stack.lo &#x3D;&#x3D; 0</span><br><span class=\"line\">\tif osStack &#123;</span><br><span class=\"line\">\t\tsize :&#x3D; _g_.stack.hi</span><br><span class=\"line\">\t\tif size &#x3D;&#x3D; 0 &#123;</span><br><span class=\"line\">\t\t\tsize &#x3D; 8192 * sys.StackGuardMultiplier</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t_g_.stack.hi &#x3D; uintptr(noescape(unsafe.Pointer(&amp;size)))</span><br><span class=\"line\">\t\t_g_.stack.lo &#x3D; _g_.stack.hi - size + 1024</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t_g_.stackguard0 &#x3D; _g_.stack.lo + _StackGuard</span><br><span class=\"line\">\t_g_.stackguard1 &#x3D; _g_.stackguard0</span><br><span class=\"line\">\tmstart1()</span><br><span class=\"line\"></span><br><span class=\"line\">\tmexit(osStack)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>继续看<code>runtime.mstart1</code>方法，也还是一系列的初始化方法：</p>\n<ol>\n<li>保存调用寄存器信息，主要用于当用户g切换至g0时，需要恢复的上下文</li>\n<li>初始化信号处理方法，因为每个线程都需要自己的信号处理g</li>\n<li>执行mstartfn方法，这个方法是针对sysmon这类的特殊线程实现的功能，使当前线程不进入调度循环中。</li>\n</ol>\n<p>执行完上述的初始化操作后，当前线程就将<code>nextp</code>字段转正进行绑定，并进入<code>runtime.schedule</code>方法中调度。</p>\n<h3 id=\"线程循环\"><a href=\"#线程循环\" class=\"headerlink\" title=\"线程循环\"></a>线程循环</h3><p>在调用循环中，存在3个因素影响调度：当前是否需要stw、当前是否获取到g、当前m是否被g绑定。三者中获取g是调度循环的主流程，其他2者也是golang的特殊功能。所以先抽离出获取g的整体流程。</p>\n<h4 id=\"获取Gorountine\"><a href=\"#获取Gorountine\" class=\"headerlink\" title=\"获取Gorountine\"></a>获取Gorountine</h4><p>在获取gorountine流程中，可以分为3部分：</p>\n<ol>\n<li>若当前p不存在g，或者调度计数满足61次，则从全局中获取g运行</li>\n<li>产生从p本地队列中获取g</li>\n<li>本地和全局都获取不到时，则在<code>findrunable</code>方法中阻塞获取g</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func schedule() &#123;</span><br><span class=\"line\">    ... ... </span><br><span class=\"line\">top:</span><br><span class=\"line\">\tif gp &#x3D;&#x3D; nil &#123;</span><br><span class=\"line\">\t\tif _g_.m.p.ptr().schedtick%61 &#x3D;&#x3D; 0 &amp;&amp; sched.runqsize &gt; 0 &#123;</span><br><span class=\"line\">\t\t\tlock(&amp;sched.lock)</span><br><span class=\"line\">\t\t\tgp &#x3D; globrunqget(_g_.m.p.ptr(), 1)</span><br><span class=\"line\">\t\t\tunlock(&amp;sched.lock)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif gp &#x3D;&#x3D; nil &#123;</span><br><span class=\"line\">\t\tgp, inheritTime &#x3D; runqget(_g_.m.p.ptr())</span><br><span class=\"line\">\t\t&#x2F;&#x2F; We can see gp !&#x3D; nil here even if the M is spinning,</span><br><span class=\"line\">\t\t&#x2F;&#x2F; if checkTimers added a local goroutine via goready.</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t&#x2F;&#x2F; 如果实在没找到，那就强行找一个可用的</span><br><span class=\"line\">\tif gp &#x3D;&#x3D; nil &#123;</span><br><span class=\"line\">\t\tgp, inheritTime &#x3D; findrunnable() &#x2F;&#x2F; blocks until work is available</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    execute(gp, inheritTime)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"globrunqget方法\"><a href=\"#globrunqget方法\" class=\"headerlink\" title=\"globrunqget方法\"></a>globrunqget方法</h5><p>在从全局队列中获取g时，会从全局队列中获取g，并同时迁移<code>1/len(allp)</code>个数的g到本地队列中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func globrunqget(_p_ *p, max int32) *g &#123;</span><br><span class=\"line\">\tn :&#x3D; sched.runqsize&#x2F;gomaxprocs + 1</span><br><span class=\"line\">\tif n &gt; int32(len(_p_.runq))&#x2F;2 &#123;</span><br><span class=\"line\">\t\tn &#x3D; int32(len(_p_.runq)) &#x2F; 2</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tsched.runqsize -&#x3D; n</span><br><span class=\"line\"></span><br><span class=\"line\">\tgp :&#x3D; sched.runq.pop()</span><br><span class=\"line\">\tn--</span><br><span class=\"line\">\tfor ; n &gt; 0; n-- &#123;</span><br><span class=\"line\">\t\tgp1 :&#x3D; sched.runq.pop()</span><br><span class=\"line\">\t\trunqput(_p_, gp1, false)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn gp</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"runqget方法\"><a href=\"#runqget方法\" class=\"headerlink\" title=\"runqget方法\"></a>runqget方法</h5><p>而在获取本地队列g的时候，优先会尝试获取<code>runnext</code>字段的g，在从<code>runq</code>中获取头部的g对象。当然由于<code>runq</code>是通过循环队列实现，所以gp是通过下标取余获取。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func runqget(_p_ *p) (gp *g, inheritTime bool) &#123;</span><br><span class=\"line\">\tfor &#123;</span><br><span class=\"line\">\t\tnext :&#x3D; _p_.runnext</span><br><span class=\"line\">\t\tif next &#x3D;&#x3D; 0 &#123;</span><br><span class=\"line\">\t\t\tbreak</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif _p_.runnext.cas(next, 0) &#123;</span><br><span class=\"line\">\t\t\treturn next.ptr(), true</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfor &#123;</span><br><span class=\"line\">\t\th :&#x3D; atomic.LoadAcq(&amp;_p_.runqhead) &#x2F;&#x2F; load-acquire, synchronize with other consumers</span><br><span class=\"line\">\t\tt :&#x3D; _p_.runqtail</span><br><span class=\"line\">\t\tif t &#x3D;&#x3D; h &#123;</span><br><span class=\"line\">\t\t\treturn nil, false</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tgp :&#x3D; _p_.runq[h%uint32(len(_p_.runq))].ptr()</span><br><span class=\"line\">\t\tif atomic.CasRel(&amp;_p_.runqhead, h, h+1) &#123; &#x2F;&#x2F; cas-release, commits consume</span><br><span class=\"line\">\t\t\treturn gp, false</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"findrunnable方法\"><a href=\"#findrunnable方法\" class=\"headerlink\" title=\"findrunnable方法\"></a>findrunnable方法</h5><p>由于前2个方法实在获取不到可运行的g，所以在<code>findrunnable</code>方法中会不断的在各个可能存在可运行g的地方查询。具体的查询流程如下：</p>\n<ol>\n<li>检查finalizer是否存在析构对象</li>\n<li>检查本地对象是否存在可用g</li>\n<li>查询全局队列是否存在可用g</li>\n<li>非阻塞检查netpoll</li>\n<li>如果大家都空闲中，或者自旋的m超过了忙碌的p，则进入强制查询阶段</li>\n<li>再不济，随机4次去其他的p中窃取g</li>\n</ol>\n<p>上述流程实在找不到，m就不在持有p，然后开始特殊判断阶段。m开始循环判断是否存在可运行的g。判断区域还是从全局队列中、所有p的本地队列中以及netpoll三个方面。最终如果实在获取不到，则休眠当前m，等待有可用的p来唤醒。</p>\n<h4 id=\"执行Gorountine\"><a href=\"#执行Gorountine\" class=\"headerlink\" title=\"执行Gorountine\"></a>执行Gorountine</h4><p>获取到可执行的g之后，就需要调用<code>runtime.execute</code>方法，主要针对g做一些变量赋值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">casgstatus(gp, _Grunnable, _Grunning)</span><br><span class=\"line\">gp.waitsince &#x3D; 0</span><br><span class=\"line\">gp.preempt &#x3D; false</span><br><span class=\"line\">gp.stackguard0 &#x3D; gp.stack.lo + _StackGuard</span><br><span class=\"line\">if !inheritTime &#123;</span><br><span class=\"line\">\t_g_.m.p.ptr().schedtick++</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">_g_.m.curg &#x3D; gp</span><br><span class=\"line\">gp.m &#x3D; _g_.m</span><br></pre></td></tr></table></figure>\n<p>赋值完后，会调用<code>runtime.gogo</code>方法进行协程的上下文切换，将原有的g0协程，切换至gp协程。</p>\n<h2 id=\"调度工具\"><a href=\"#调度工具\" class=\"headerlink\" title=\"调度工具\"></a>调度工具</h2><ul>\n<li>trace</li>\n<li>pprof</li>\n</ul>\n<h2 id=\"相关主题\"><a href=\"#相关主题\" class=\"headerlink\" title=\"相关主题\"></a>相关主题</h2><ul>\n<li>lock ranking</li>\n</ul>\n<h2 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h2><p><a href=\"https://docs.oracle.com/cd/E19683-01/806-6867/guide-60747/index.html\" target=\"_blank\" rel=\"noopener\">https://docs.oracle.com/cd/E19683-01/806-6867/guide-60747/index.html</a><br><a href=\"https://www.linuxjournal.com/article/3184\" target=\"_blank\" rel=\"noopener\">https://www.linuxjournal.com/article/3184</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><h2 id=\"GMP模型\"><a href=\"#GMP模型\" class=\"headerlink\" title=\"GMP模型\"></a>GMP模型</h2><h3 id=\"关于线程和协程\"><a href=\"#关于线程和协程\" class=\"headerlink\" title=\"关于线程和协程\"></a>关于线程和协程</h3><p>在计算机操作系统中,轻量级进程（LWP）是一种实现多任务的方法。与普通进程相比，LWP与其他进程共享所有（或大部分）它的逻辑地址空间和系统资源；与线程相比，LWP有它自己的进程标识符，优先级，状态，以及栈和局部存储区，并和其他进程有着父子关系；这是和类Unix操作系统的系统调用vfork()生成的进程一样的。另外，线程既可由应用程序管理，又可由内核管理，而LWP只能由内核管理并像普通进程一样被调度。Linux内核是支持LWP的典型例子。</p>\n<p><img src=\"1767848-9c4b06362907280d.webp\" alt=\"img\"></p>\n<h3 id=\"Golang中的模型\"><a href=\"#Golang中的模型\" class=\"headerlink\" title=\"Golang中的模型\"></a>Golang中的模型</h3><p>有2个支持高并发的模型：CSP和Actor（erlang）。Go选择了CSP，Go为了提供更容易的并发使用方法，提供了2个重要的概念<code>goroutine</code>和<code>channel</code>。</p>\n<p><strong>goroutine</strong>来自协程的概念，让一组可复用的函数运行在一组线程之上，即使有协程阻塞，该线程的其他协程也可以被<code>runtime</code>调度，转移到其他可运行的线程上。</p>\n<p><img src=\"3184f3.jpg\" alt=\"img\"></p>\n<p>其实<strong>老调度器</strong>有4个缺点：详见<a href=\"https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit#!\" target=\"_blank\" rel=\"noopener\">Scalable Go Scheduler Design Doc</a></p>\n<ol>\n<li>创建、销毁、调度G都需要每个M获取锁，这就形成了激烈的锁竞争</li>\n<li>M转移G会造成延迟和额外的系统开销。</li>\n<li>M中的mcache是用来存放小对象的，mcache和栈都和M关联造成了大量的内存开销和差的局部性</li>\n<li>系统调用导致频繁的线程阻塞和取消阻塞操作增加了系统开销。</li>\n</ol>\n<p>所以Go语言在2012年重新设计了调度器方案（<a href=\"https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit#!\" target=\"_blank\" rel=\"noopener\">Scalable Go Scheduler Design Doc</a>，<a href=\"https://golang.org/s/go11sched\" target=\"_blank\" rel=\"noopener\">设计方案</a>）。</p>\n<p><img src=\"567399-d400f4b192f3dc48.webp\" alt=\"img\"></p>\n<h2 id=\"关于GMP模型\"><a href=\"#关于GMP模型\" class=\"headerlink\" title=\"关于GMP模型\"></a>关于GMP模型</h2><h3 id=\"关于Machine\"><a href=\"#关于Machine\" class=\"headerlink\" title=\"关于Machine\"></a>关于Machine</h3><p>machine代表一个线程，每次创建一个M的时候，都会有一个底层线程创建；所有的G任务，最终还是在M上执行。</p>\n<p>machine的字段多达几十个，但将其进行粗劣的分类是可以明确m的具体职责：</p>\n<ol>\n<li>特殊g的管理：g0、gsignal、curg</li>\n<li>p的管理：p、nextp、oldp</li>\n<li>状态管理：locks、preemptoff、mallocing、throwing、dying、incgo、signalPending、blocked</li>\n<li>锁的管理：lockedg、lockedExt、lockedInt、nextwaitm、waitlock</li>\n<li>cgo运行相关：ncgocall、ncgo、cgoCallersUse、cgoCallers</li>\n</ol>\n<p>从字段中可以看出，在m层，主要方向有几个关键词：锁、抢占、cgo、g与p的管理、信号。主要原因还是由于m是一个贴近操作系统的结构体，而操作系统的调度的核心问题也是锁、信号，阻塞等。</p>\n<blockquote>\n<p>如何解决m和m的绑定问题？</p>\n</blockquote>\n<h4 id=\"创建Machine\"><a href=\"#创建Machine\" class=\"headerlink\" title=\"创建Machine\"></a>创建Machine</h4><p>创建m的时机有3类：sysmon抢占线程、templateThread模板线程、运行p。前2者是特殊的线程，不会进入调度系统中。创建m的方法是直接调用<code>runtime.newm</code>方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func newm(fn func(), _p_ *p) &#123;</span><br><span class=\"line\">\t&#x2F;&#x2F; 分配一个m对象</span><br><span class=\"line\">\tmp :&#x3D; allocm(_p_, fn)</span><br><span class=\"line\">\t&#x2F;&#x2F; 设置下一个执行的p</span><br><span class=\"line\">\tmp.nextp.set(_p_)</span><br><span class=\"line\">\t&#x2F;&#x2F; 初始化系统信号拦截</span><br><span class=\"line\">\tmp.sigmask &#x3D; initSigmask</span><br><span class=\"line\">    ... ...</span><br><span class=\"line\">\tnewm1(mp)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出在m的创建流程中，具体分为2步：结构体的创建、线程的创建。在<code>allocm</code>方法中，核心是需要申请一个m的对象以及相关的g0空间，而针对不同的操作系统，g0的内存空间又区分为是使用系统分配，还是go指定。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func allocm(_p_ *p, fn func()) *m &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ... ...</span><br><span class=\"line\">\tmp :&#x3D; new(m)</span><br><span class=\"line\">\tmp.mstartfn &#x3D; fn</span><br><span class=\"line\">\tmcommoninit(mp)</span><br><span class=\"line\"></span><br><span class=\"line\">\tif iscgo || GOOS &#x3D;&#x3D; &quot;solaris&quot; || GOOS &#x3D;&#x3D; &quot;illumos&quot; || GOOS &#x3D;&#x3D; &quot;windows&quot; || GOOS &#x3D;&#x3D; &quot;plan9&quot; || GOOS &#x3D;&#x3D; &quot;darwin&quot; &#123;</span><br><span class=\"line\">\t\tmp.g0 &#x3D; malg(-1)</span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t\tmp.g0 &#x3D; malg(8192 * sys.StackGuardMultiplier)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tmp.g0.m &#x3D; mp</span><br><span class=\"line\"></span><br><span class=\"line\">\treturn mp</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而在<code>runtime.newm1</code>方法中，主要是直接调用<code>runtime.newosproc</code>方法，正如其名，就是用于创建一个系统的线程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func newm1(mp *m) &#123;</span><br><span class=\"line\">    ... ...</span><br><span class=\"line\">\tnewosproc(mp)</span><br><span class=\"line\">    ... ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func newosproc(mp *m) &#123;</span><br><span class=\"line\">\tstk :&#x3D; unsafe.Pointer(mp.g0.stack.hi)</span><br><span class=\"line\">    ... ...</span><br><span class=\"line\">\tvar oset sigset</span><br><span class=\"line\">\tsigprocmask(_SIG_SETMASK, &amp;sigset_all, &amp;oset)</span><br><span class=\"line\">\tret :&#x3D; clone(cloneFlags, stk, unsafe.Pointer(mp), unsafe.Pointer(mp.g0), unsafe.Pointer(funcPC(mstart)))</span><br><span class=\"line\">\tsigprocmask(_SIG_SETMASK, &amp;oset, nil)</span><br><span class=\"line\">    ... ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关于Processor\"><a href=\"#关于Processor\" class=\"headerlink\" title=\"关于Processor\"></a>关于Processor</h3><p>每一个运行的M都必须绑定一个P，就像线程必须在么一个CPU核上执行一样，由P来调度G在M上的运行，P的个数就是GOMAXPROCS（最大256），启动时固定的，一般不修改；</p>\n<p>processor的字段可以分为以下几类：</p>\n<ol>\n<li>内存管理相关：mcache、pcache、mspancache、palloc</li>\n<li>调度计数相关：schedtick、syscalltick、sysmontick</li>\n<li>cache相关：deferpool、deferpoolbuf、gFree、sudogcache、sudogbuf</li>\n<li>g调度相关：runqhead、runqtail、runq、runnext</li>\n<li>定时器相关：timer0When、timersLock、timers、numTimers、adjustTimers、deletedTimers、</li>\n<li>gc相关：gcAssistTime、gcFractionalMarkTime、gcBgMarkWorker、gcMarkWorkerMode、gcMarkWorkerStartTime、gcw、wbBuf、runSafePointFn</li>\n</ol>\n<p>这几大方面主要是由于p本身的定位是执行器有关，当执行用户代码时，需要在效率和性能方面做到兼容，</p>\n<p>p的创建流程代码并不难懂，方法由procresize来执行，也就是平时大家设置GOMAXPROCS计数，其中涉及到扩容和缩容操作。</p>\n<h3 id=\"关于Goroutine\"><a href=\"#关于Goroutine\" class=\"headerlink\" title=\"关于Goroutine\"></a>关于Goroutine</h3><p>gorountine也就是平时的协程，每次go调用的时候，都会创建一个G对象，它包括栈、指令指针以及对于调用goroutines很重要的其它信息</p>\n<p>gorountine的字段可以分为以下几类：</p>\n<ol>\n<li>上下文信息：startpc、gopc、sigpc、sched、syscallsp、syscallpc、stktopsp、param</li>\n<li>抢占相关：preempt、preemptStop、preemptShrink</li>\n<li>栈相关：stack、stackguard0、stackguard1</li>\n<li>defer相关：_panic、_defer</li>\n<li>锁相关：waiting、timer、selectDone、</li>\n<li>信号相关：sigcode0、sigcode1、sigpc</li>\n</ol>\n<p>当然，gorountine不仅仅是上述的字段，还有大量的pprof的计数字段，本次暂时不做讨论。</p>\n<p>可以看出，g和m的字段中，都有信号、锁、抢占相关的字段，但是，为什么m中却没有栈信息，难道不需要栈信息？这就是g0协程的重要性，golang中为了做权限隔离，避免用户代码影响runtime的运行，专门抽象了g0协程执行。既然无法向操作系统中通过中断实现内核态切换，就考虑使用特殊协程，这样相关上下文切换逻辑是完全复用，所以，g0是一个只做权限隔离的协程，同时所有m都拥有一个g0。</p>\n<h4 id=\"创建Gorountine\"><a href=\"#创建Gorountine\" class=\"headerlink\" title=\"创建Gorountine\"></a>创建Gorountine</h4><p>创建gorountine就是平时大家使用的<code>go func()</code>关键字。在编译阶段，关键字会变编译为<code>runtime.newproc</code>方法，同时会传入参数大小和函数指针fn。然后从堆栈中获取参数并调用<code>runtime.newproc1</code>方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func newproc(siz int32, fn *funcval) &#123;</span><br><span class=\"line\">\targp :&#x3D; add(unsafe.Pointer(&amp;fn), sys.PtrSize)</span><br><span class=\"line\">\tgp :&#x3D; getg()</span><br><span class=\"line\">\tpc :&#x3D; getcallerpc()</span><br><span class=\"line\">\tsystemstack(func() &#123;</span><br><span class=\"line\">\t\tnewproc1(fn, argp, siz, gp, pc)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在<code>runtime.newproc1</code>方法中具体可以分为3块逻辑：</p>\n<ol>\n<li>gorountine结构体创建</li>\n<li>gorountine对象的初始化</li>\n<li>插入调度对象并唤醒p</li>\n</ol>\n<p>创建完的gorountine结构体最终会插入p中的runq链表中。</p>\n<h2 id=\"调度实现\"><a href=\"#调度实现\" class=\"headerlink\" title=\"调度实现\"></a>调度实现</h2><p>从m的创建流程中，可以看到<code>newosproc</code>方法是第四个参数，也就是系统线程的入口函数。线程创建完成后，操作系统会根据系统调度算法运行线程，<code>runtime.mstart</code>也就是线程的初始化方法。</p>\n<h3 id=\"线程初始化\"><a href=\"#线程初始化\" class=\"headerlink\" title=\"线程初始化\"></a>线程初始化</h3><p><code>runtime.mstart</code>方法中，优先将栈的检查地址更新，这是因为如果是操作系统自动生成的堆栈，线程运行前是无法确定的。之后会调用<code>runtime.mstart1</code>方法执行进一步的初始化方法。最后，针对特殊的线程（被lockg的线程），会执行<code>runtime.mexit</code>方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func mstart() &#123;</span><br><span class=\"line\">\t_g_ :&#x3D; getg()</span><br><span class=\"line\"></span><br><span class=\"line\">\tosStack :&#x3D; _g_.stack.lo &#x3D;&#x3D; 0</span><br><span class=\"line\">\tif osStack &#123;</span><br><span class=\"line\">\t\tsize :&#x3D; _g_.stack.hi</span><br><span class=\"line\">\t\tif size &#x3D;&#x3D; 0 &#123;</span><br><span class=\"line\">\t\t\tsize &#x3D; 8192 * sys.StackGuardMultiplier</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t_g_.stack.hi &#x3D; uintptr(noescape(unsafe.Pointer(&amp;size)))</span><br><span class=\"line\">\t\t_g_.stack.lo &#x3D; _g_.stack.hi - size + 1024</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t_g_.stackguard0 &#x3D; _g_.stack.lo + _StackGuard</span><br><span class=\"line\">\t_g_.stackguard1 &#x3D; _g_.stackguard0</span><br><span class=\"line\">\tmstart1()</span><br><span class=\"line\"></span><br><span class=\"line\">\tmexit(osStack)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>继续看<code>runtime.mstart1</code>方法，也还是一系列的初始化方法：</p>\n<ol>\n<li>保存调用寄存器信息，主要用于当用户g切换至g0时，需要恢复的上下文</li>\n<li>初始化信号处理方法，因为每个线程都需要自己的信号处理g</li>\n<li>执行mstartfn方法，这个方法是针对sysmon这类的特殊线程实现的功能，使当前线程不进入调度循环中。</li>\n</ol>\n<p>执行完上述的初始化操作后，当前线程就将<code>nextp</code>字段转正进行绑定，并进入<code>runtime.schedule</code>方法中调度。</p>\n<h3 id=\"线程循环\"><a href=\"#线程循环\" class=\"headerlink\" title=\"线程循环\"></a>线程循环</h3><p>在调用循环中，存在3个因素影响调度：当前是否需要stw、当前是否获取到g、当前m是否被g绑定。三者中获取g是调度循环的主流程，其他2者也是golang的特殊功能。所以先抽离出获取g的整体流程。</p>\n<h4 id=\"获取Gorountine\"><a href=\"#获取Gorountine\" class=\"headerlink\" title=\"获取Gorountine\"></a>获取Gorountine</h4><p>在获取gorountine流程中，可以分为3部分：</p>\n<ol>\n<li>若当前p不存在g，或者调度计数满足61次，则从全局中获取g运行</li>\n<li>产生从p本地队列中获取g</li>\n<li>本地和全局都获取不到时，则在<code>findrunable</code>方法中阻塞获取g</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func schedule() &#123;</span><br><span class=\"line\">    ... ... </span><br><span class=\"line\">top:</span><br><span class=\"line\">\tif gp &#x3D;&#x3D; nil &#123;</span><br><span class=\"line\">\t\tif _g_.m.p.ptr().schedtick%61 &#x3D;&#x3D; 0 &amp;&amp; sched.runqsize &gt; 0 &#123;</span><br><span class=\"line\">\t\t\tlock(&amp;sched.lock)</span><br><span class=\"line\">\t\t\tgp &#x3D; globrunqget(_g_.m.p.ptr(), 1)</span><br><span class=\"line\">\t\t\tunlock(&amp;sched.lock)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif gp &#x3D;&#x3D; nil &#123;</span><br><span class=\"line\">\t\tgp, inheritTime &#x3D; runqget(_g_.m.p.ptr())</span><br><span class=\"line\">\t\t&#x2F;&#x2F; We can see gp !&#x3D; nil here even if the M is spinning,</span><br><span class=\"line\">\t\t&#x2F;&#x2F; if checkTimers added a local goroutine via goready.</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t&#x2F;&#x2F; 如果实在没找到，那就强行找一个可用的</span><br><span class=\"line\">\tif gp &#x3D;&#x3D; nil &#123;</span><br><span class=\"line\">\t\tgp, inheritTime &#x3D; findrunnable() &#x2F;&#x2F; blocks until work is available</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    execute(gp, inheritTime)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"globrunqget方法\"><a href=\"#globrunqget方法\" class=\"headerlink\" title=\"globrunqget方法\"></a>globrunqget方法</h5><p>在从全局队列中获取g时，会从全局队列中获取g，并同时迁移<code>1/len(allp)</code>个数的g到本地队列中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func globrunqget(_p_ *p, max int32) *g &#123;</span><br><span class=\"line\">\tn :&#x3D; sched.runqsize&#x2F;gomaxprocs + 1</span><br><span class=\"line\">\tif n &gt; int32(len(_p_.runq))&#x2F;2 &#123;</span><br><span class=\"line\">\t\tn &#x3D; int32(len(_p_.runq)) &#x2F; 2</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tsched.runqsize -&#x3D; n</span><br><span class=\"line\"></span><br><span class=\"line\">\tgp :&#x3D; sched.runq.pop()</span><br><span class=\"line\">\tn--</span><br><span class=\"line\">\tfor ; n &gt; 0; n-- &#123;</span><br><span class=\"line\">\t\tgp1 :&#x3D; sched.runq.pop()</span><br><span class=\"line\">\t\trunqput(_p_, gp1, false)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn gp</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"runqget方法\"><a href=\"#runqget方法\" class=\"headerlink\" title=\"runqget方法\"></a>runqget方法</h5><p>而在获取本地队列g的时候，优先会尝试获取<code>runnext</code>字段的g，在从<code>runq</code>中获取头部的g对象。当然由于<code>runq</code>是通过循环队列实现，所以gp是通过下标取余获取。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func runqget(_p_ *p) (gp *g, inheritTime bool) &#123;</span><br><span class=\"line\">\tfor &#123;</span><br><span class=\"line\">\t\tnext :&#x3D; _p_.runnext</span><br><span class=\"line\">\t\tif next &#x3D;&#x3D; 0 &#123;</span><br><span class=\"line\">\t\t\tbreak</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif _p_.runnext.cas(next, 0) &#123;</span><br><span class=\"line\">\t\t\treturn next.ptr(), true</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tfor &#123;</span><br><span class=\"line\">\t\th :&#x3D; atomic.LoadAcq(&amp;_p_.runqhead) &#x2F;&#x2F; load-acquire, synchronize with other consumers</span><br><span class=\"line\">\t\tt :&#x3D; _p_.runqtail</span><br><span class=\"line\">\t\tif t &#x3D;&#x3D; h &#123;</span><br><span class=\"line\">\t\t\treturn nil, false</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tgp :&#x3D; _p_.runq[h%uint32(len(_p_.runq))].ptr()</span><br><span class=\"line\">\t\tif atomic.CasRel(&amp;_p_.runqhead, h, h+1) &#123; &#x2F;&#x2F; cas-release, commits consume</span><br><span class=\"line\">\t\t\treturn gp, false</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"findrunnable方法\"><a href=\"#findrunnable方法\" class=\"headerlink\" title=\"findrunnable方法\"></a>findrunnable方法</h5><p>由于前2个方法实在获取不到可运行的g，所以在<code>findrunnable</code>方法中会不断的在各个可能存在可运行g的地方查询。具体的查询流程如下：</p>\n<ol>\n<li>检查finalizer是否存在析构对象</li>\n<li>检查本地对象是否存在可用g</li>\n<li>查询全局队列是否存在可用g</li>\n<li>非阻塞检查netpoll</li>\n<li>如果大家都空闲中，或者自旋的m超过了忙碌的p，则进入强制查询阶段</li>\n<li>再不济，随机4次去其他的p中窃取g</li>\n</ol>\n<p>上述流程实在找不到，m就不在持有p，然后开始特殊判断阶段。m开始循环判断是否存在可运行的g。判断区域还是从全局队列中、所有p的本地队列中以及netpoll三个方面。最终如果实在获取不到，则休眠当前m，等待有可用的p来唤醒。</p>\n<h4 id=\"执行Gorountine\"><a href=\"#执行Gorountine\" class=\"headerlink\" title=\"执行Gorountine\"></a>执行Gorountine</h4><p>获取到可执行的g之后，就需要调用<code>runtime.execute</code>方法，主要针对g做一些变量赋值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">casgstatus(gp, _Grunnable, _Grunning)</span><br><span class=\"line\">gp.waitsince &#x3D; 0</span><br><span class=\"line\">gp.preempt &#x3D; false</span><br><span class=\"line\">gp.stackguard0 &#x3D; gp.stack.lo + _StackGuard</span><br><span class=\"line\">if !inheritTime &#123;</span><br><span class=\"line\">\t_g_.m.p.ptr().schedtick++</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">_g_.m.curg &#x3D; gp</span><br><span class=\"line\">gp.m &#x3D; _g_.m</span><br></pre></td></tr></table></figure>\n<p>赋值完后，会调用<code>runtime.gogo</code>方法进行协程的上下文切换，将原有的g0协程，切换至gp协程。</p>\n<h2 id=\"调度工具\"><a href=\"#调度工具\" class=\"headerlink\" title=\"调度工具\"></a>调度工具</h2><ul>\n<li>trace</li>\n<li>pprof</li>\n</ul>\n<h2 id=\"相关主题\"><a href=\"#相关主题\" class=\"headerlink\" title=\"相关主题\"></a>相关主题</h2><ul>\n<li>lock ranking</li>\n</ul>\n<h2 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h2><p><a href=\"https://docs.oracle.com/cd/E19683-01/806-6867/guide-60747/index.html\" target=\"_blank\" rel=\"noopener\">https://docs.oracle.com/cd/E19683-01/806-6867/guide-60747/index.html</a><br><a href=\"https://www.linuxjournal.com/article/3184\" target=\"_blank\" rel=\"noopener\">https://www.linuxjournal.com/article/3184</a></p>\n"},{"title":"关于JVM的垃圾收集（2）","_content":"\n关于垃圾收集，上文已经提到了2类算法：引用计数、可达性计算。而针对可达性算法，为了提高垃圾收集效率，将内存分为新生代和老年代，并演化出3类假说：大部分对象朝生夕灭、熬过多次的垃圾收集越难消亡、跨代引用相对于同代引用是极少的。\n\n在这些基础上，java本身也会对gc进行分类处理，而非每次都是全内存进行垃圾清理。其中的分类为Minor GC、Major GC，分别为新生代GC和老年代GC，Mixed GC，表示对新生代和部分老年代的GC、Full GC，收集整个Java堆和方法区的垃圾。\n\n而在不同的GC阶段，自然也有不同的实现方式\n\n## 标记清理算法\n\n所谓标记清理当然分为标记和清理2个阶段：标记出所有需要收集的对象，而后统一进行回收。标记阶段负责判断垃圾，而清理阶段则直接处理相关垃圾对象。\n\n该方法的实际实现便是Golang中的三色标记。其主要确定在于执行效率不稳定，若存在大量对象，且大部分对象都需要回溯，则需要进行大规模的标记和清理动作，其次是内存空间碎片化问题，标记清理会导致大量的空间碎片，而当分配大对象时找不到足够的连续内存，则会提前触发下一次垃圾回收。\n\n## 标记复制算法\n\n为了解决标记清理算法面对大量可回收对象时执行效率低的问题，便产生出了半区复制的GC算法。原理是将可用内存按容量划分为大小相等的两块，每次只使用其中一块，当一块用完后将存活的对象复制到另外一块上面。而后再直接将旧有的一半空间清理。\n\n这类算法缺点则是会产生大量的内存间复制的开销，同时空间浪费相对比较严重。而在IBM公司的实验中发现，新生代98%的对象都熬不过第一轮收集，那也可以佐证并不需要进行半区1：1的空间分配。\n\n于是也就产生了经典的8：1：1的分区关系，划分为Eden（8）、Survivor0（1）、Survivor1（1），在对象申请时，只使用Eden+Survivor0区域，而当进行GC时，就将对象复制到Survivor1区域，并直接清空内存。这样只有10%的空间会浪费，同时，当存活的对象大于10%，那就需要启用老年代空间来存放对象。\n\n## 标记整理算法\n\n标记复制算法的问题则是在存活对象过多的情况下，需要进行较多的对象复制操作，效率极低。同时，如果出现100%的对象存活，那还需要额外的空间来保证算法稳定。那针对老年代的对象特征，那就是需要新的一类算法来保证空间的利用率。\n\n而标记整理便是当前的实际算法，这算法与标记清理的差异在于，前者在回收后需要对存活的对象进行移动。\n\n移动对象的确定在于，需要小心的维护对象的连接关系，保证在移动的过程中，不会直接导致进程崩坏。而如果不进行整理，那么空间碎片化会导致需要类似的内存分配器和访问器来解决。\n\n是否移动对象在实践中都存在利弊，那考虑整体老年代的特征而言，并不需要频繁的GC，更多的是空间利用率的提升，那选择移动对象那必然是较优的选择。","source":"_posts/java-gc-2.md","raw":"---\ntitle: 关于JVM的垃圾收集（2）\n---\n\n关于垃圾收集，上文已经提到了2类算法：引用计数、可达性计算。而针对可达性算法，为了提高垃圾收集效率，将内存分为新生代和老年代，并演化出3类假说：大部分对象朝生夕灭、熬过多次的垃圾收集越难消亡、跨代引用相对于同代引用是极少的。\n\n在这些基础上，java本身也会对gc进行分类处理，而非每次都是全内存进行垃圾清理。其中的分类为Minor GC、Major GC，分别为新生代GC和老年代GC，Mixed GC，表示对新生代和部分老年代的GC、Full GC，收集整个Java堆和方法区的垃圾。\n\n而在不同的GC阶段，自然也有不同的实现方式\n\n## 标记清理算法\n\n所谓标记清理当然分为标记和清理2个阶段：标记出所有需要收集的对象，而后统一进行回收。标记阶段负责判断垃圾，而清理阶段则直接处理相关垃圾对象。\n\n该方法的实际实现便是Golang中的三色标记。其主要确定在于执行效率不稳定，若存在大量对象，且大部分对象都需要回溯，则需要进行大规模的标记和清理动作，其次是内存空间碎片化问题，标记清理会导致大量的空间碎片，而当分配大对象时找不到足够的连续内存，则会提前触发下一次垃圾回收。\n\n## 标记复制算法\n\n为了解决标记清理算法面对大量可回收对象时执行效率低的问题，便产生出了半区复制的GC算法。原理是将可用内存按容量划分为大小相等的两块，每次只使用其中一块，当一块用完后将存活的对象复制到另外一块上面。而后再直接将旧有的一半空间清理。\n\n这类算法缺点则是会产生大量的内存间复制的开销，同时空间浪费相对比较严重。而在IBM公司的实验中发现，新生代98%的对象都熬不过第一轮收集，那也可以佐证并不需要进行半区1：1的空间分配。\n\n于是也就产生了经典的8：1：1的分区关系，划分为Eden（8）、Survivor0（1）、Survivor1（1），在对象申请时，只使用Eden+Survivor0区域，而当进行GC时，就将对象复制到Survivor1区域，并直接清空内存。这样只有10%的空间会浪费，同时，当存活的对象大于10%，那就需要启用老年代空间来存放对象。\n\n## 标记整理算法\n\n标记复制算法的问题则是在存活对象过多的情况下，需要进行较多的对象复制操作，效率极低。同时，如果出现100%的对象存活，那还需要额外的空间来保证算法稳定。那针对老年代的对象特征，那就是需要新的一类算法来保证空间的利用率。\n\n而标记整理便是当前的实际算法，这算法与标记清理的差异在于，前者在回收后需要对存活的对象进行移动。\n\n移动对象的确定在于，需要小心的维护对象的连接关系，保证在移动的过程中，不会直接导致进程崩坏。而如果不进行整理，那么空间碎片化会导致需要类似的内存分配器和访问器来解决。\n\n是否移动对象在实践中都存在利弊，那考虑整体老年代的特征而言，并不需要频繁的GC，更多的是空间利用率的提升，那选择移动对象那必然是较优的选择。","slug":"java-gc-2","published":1,"date":"2021-08-13T17:27:47.498Z","updated":"2021-08-13T17:27:47.498Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckti9vicq00069gtj0u0r7up7","content":"<p>关于垃圾收集，上文已经提到了2类算法：引用计数、可达性计算。而针对可达性算法，为了提高垃圾收集效率，将内存分为新生代和老年代，并演化出3类假说：大部分对象朝生夕灭、熬过多次的垃圾收集越难消亡、跨代引用相对于同代引用是极少的。</p>\n<p>在这些基础上，java本身也会对gc进行分类处理，而非每次都是全内存进行垃圾清理。其中的分类为Minor GC、Major GC，分别为新生代GC和老年代GC，Mixed GC，表示对新生代和部分老年代的GC、Full GC，收集整个Java堆和方法区的垃圾。</p>\n<p>而在不同的GC阶段，自然也有不同的实现方式</p>\n<h2 id=\"标记清理算法\"><a href=\"#标记清理算法\" class=\"headerlink\" title=\"标记清理算法\"></a>标记清理算法</h2><p>所谓标记清理当然分为标记和清理2个阶段：标记出所有需要收集的对象，而后统一进行回收。标记阶段负责判断垃圾，而清理阶段则直接处理相关垃圾对象。</p>\n<p>该方法的实际实现便是Golang中的三色标记。其主要确定在于执行效率不稳定，若存在大量对象，且大部分对象都需要回溯，则需要进行大规模的标记和清理动作，其次是内存空间碎片化问题，标记清理会导致大量的空间碎片，而当分配大对象时找不到足够的连续内存，则会提前触发下一次垃圾回收。</p>\n<h2 id=\"标记复制算法\"><a href=\"#标记复制算法\" class=\"headerlink\" title=\"标记复制算法\"></a>标记复制算法</h2><p>为了解决标记清理算法面对大量可回收对象时执行效率低的问题，便产生出了半区复制的GC算法。原理是将可用内存按容量划分为大小相等的两块，每次只使用其中一块，当一块用完后将存活的对象复制到另外一块上面。而后再直接将旧有的一半空间清理。</p>\n<p>这类算法缺点则是会产生大量的内存间复制的开销，同时空间浪费相对比较严重。而在IBM公司的实验中发现，新生代98%的对象都熬不过第一轮收集，那也可以佐证并不需要进行半区1：1的空间分配。</p>\n<p>于是也就产生了经典的8：1：1的分区关系，划分为Eden（8）、Survivor0（1）、Survivor1（1），在对象申请时，只使用Eden+Survivor0区域，而当进行GC时，就将对象复制到Survivor1区域，并直接清空内存。这样只有10%的空间会浪费，同时，当存活的对象大于10%，那就需要启用老年代空间来存放对象。</p>\n<h2 id=\"标记整理算法\"><a href=\"#标记整理算法\" class=\"headerlink\" title=\"标记整理算法\"></a>标记整理算法</h2><p>标记复制算法的问题则是在存活对象过多的情况下，需要进行较多的对象复制操作，效率极低。同时，如果出现100%的对象存活，那还需要额外的空间来保证算法稳定。那针对老年代的对象特征，那就是需要新的一类算法来保证空间的利用率。</p>\n<p>而标记整理便是当前的实际算法，这算法与标记清理的差异在于，前者在回收后需要对存活的对象进行移动。</p>\n<p>移动对象的确定在于，需要小心的维护对象的连接关系，保证在移动的过程中，不会直接导致进程崩坏。而如果不进行整理，那么空间碎片化会导致需要类似的内存分配器和访问器来解决。</p>\n<p>是否移动对象在实践中都存在利弊，那考虑整体老年代的特征而言，并不需要频繁的GC，更多的是空间利用率的提升，那选择移动对象那必然是较优的选择。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>关于垃圾收集，上文已经提到了2类算法：引用计数、可达性计算。而针对可达性算法，为了提高垃圾收集效率，将内存分为新生代和老年代，并演化出3类假说：大部分对象朝生夕灭、熬过多次的垃圾收集越难消亡、跨代引用相对于同代引用是极少的。</p>\n<p>在这些基础上，java本身也会对gc进行分类处理，而非每次都是全内存进行垃圾清理。其中的分类为Minor GC、Major GC，分别为新生代GC和老年代GC，Mixed GC，表示对新生代和部分老年代的GC、Full GC，收集整个Java堆和方法区的垃圾。</p>\n<p>而在不同的GC阶段，自然也有不同的实现方式</p>\n<h2 id=\"标记清理算法\"><a href=\"#标记清理算法\" class=\"headerlink\" title=\"标记清理算法\"></a>标记清理算法</h2><p>所谓标记清理当然分为标记和清理2个阶段：标记出所有需要收集的对象，而后统一进行回收。标记阶段负责判断垃圾，而清理阶段则直接处理相关垃圾对象。</p>\n<p>该方法的实际实现便是Golang中的三色标记。其主要确定在于执行效率不稳定，若存在大量对象，且大部分对象都需要回溯，则需要进行大规模的标记和清理动作，其次是内存空间碎片化问题，标记清理会导致大量的空间碎片，而当分配大对象时找不到足够的连续内存，则会提前触发下一次垃圾回收。</p>\n<h2 id=\"标记复制算法\"><a href=\"#标记复制算法\" class=\"headerlink\" title=\"标记复制算法\"></a>标记复制算法</h2><p>为了解决标记清理算法面对大量可回收对象时执行效率低的问题，便产生出了半区复制的GC算法。原理是将可用内存按容量划分为大小相等的两块，每次只使用其中一块，当一块用完后将存活的对象复制到另外一块上面。而后再直接将旧有的一半空间清理。</p>\n<p>这类算法缺点则是会产生大量的内存间复制的开销，同时空间浪费相对比较严重。而在IBM公司的实验中发现，新生代98%的对象都熬不过第一轮收集，那也可以佐证并不需要进行半区1：1的空间分配。</p>\n<p>于是也就产生了经典的8：1：1的分区关系，划分为Eden（8）、Survivor0（1）、Survivor1（1），在对象申请时，只使用Eden+Survivor0区域，而当进行GC时，就将对象复制到Survivor1区域，并直接清空内存。这样只有10%的空间会浪费，同时，当存活的对象大于10%，那就需要启用老年代空间来存放对象。</p>\n<h2 id=\"标记整理算法\"><a href=\"#标记整理算法\" class=\"headerlink\" title=\"标记整理算法\"></a>标记整理算法</h2><p>标记复制算法的问题则是在存活对象过多的情况下，需要进行较多的对象复制操作，效率极低。同时，如果出现100%的对象存活，那还需要额外的空间来保证算法稳定。那针对老年代的对象特征，那就是需要新的一类算法来保证空间的利用率。</p>\n<p>而标记整理便是当前的实际算法，这算法与标记清理的差异在于，前者在回收后需要对存活的对象进行移动。</p>\n<p>移动对象的确定在于，需要小心的维护对象的连接关系，保证在移动的过程中，不会直接导致进程崩坏。而如果不进行整理，那么空间碎片化会导致需要类似的内存分配器和访问器来解决。</p>\n<p>是否移动对象在实践中都存在利弊，那考虑整体老年代的特征而言，并不需要频繁的GC，更多的是空间利用率的提升，那选择移动对象那必然是较优的选择。</p>\n"},{"title":"浅析levelDB文件格式","_content":"\n## 前言\n\nleveldb本身是基于文件来实现的高速kv数据库，期间涉及到了多种文件格式\n\n## 文件介绍\n\n### CURRENT文件\n\n此文件是针对奔溃恢复时，定位MANIFEST文件使用，其中的存储内容就是MANIFEST文件的文件名。\n\n### LOCK文件\n\n此文件控制多进程访问数据库的关键。当一个进程打开了数据库时，会在这个文件上加上互斥文件锁，进程结束时，锁就会自动释放。\n\n### MANIFEST文件\n\n所有文件的 Key 取值范围、层级和其它元信息会存储在数据库目录里面的 MANIFEST 文件中。数据库打开时，读取一下这个文件就知道了所有文件的层级和 Key 取值范围。\n\nMANIFEST 文件也有版本号，它的版本号体现在文件名上如 MANIFEST-000361。每一次重新打开数据库，都会生成一个新的 MANIFEST 文件，具有不同的版本号，然后还需要将老的 MANIFEST 文件删除。\n\n数据库目录中还有另外一个文件 CURRENT，它里面的内容很简单，就是当前 MANIFEST 的文件名。LevelDB 首先读取 CURRENT 文件才知道哪个 MANIFEST 文件是有效文件。在遇到断电时，会存在一个小概率中间状态，新旧 MANIFEST 文件共存于数据库目录中。\n\n### LOG文件\n\n在LevelDb中的主要作用是系统故障恢复时，能够保证不会丢失数据。因为在将记录写入内存的Memtable之前，会先写入Log文件，这样即使系统发生故障，Memtable中的数据没有来得及Dump到磁盘的SSTable文件，LevelDB也可以根据log文件恢复内存的Memtable数据结构内容，不会造成系统丢失数据.\n\nLog文件，会把它切割成以32K为单位的物理Block，每次读取的单位以一个Block作为基本读取单位\n\n### SST文件\n\n同Log文件一样，也是划分为固定大小的存储块，每个Block分为三个部分，红色部分是数据存储区， 蓝色的Type区用于标识数据存储区是否采用了数据压缩算法（Snappy压缩或者无压缩两种），CRC部分则是数据校验码，用于判别数据是否在生成和传输中出错。\n\n从大的方面，可以将.sst文件划分为数据存储区和数据管理区，数据存储区存放实际的Key:Value数据，数据管理区则提供一些索引指针等管理数据，目的是更快速便捷的查找相应的记录。两个区域都是在上述的分块基础上的，就是说文件的前面若干块实际存储KV数据，后面数据管理区存储管理数据。管理数据又分为四种不同类型：紫色的Meta Block，红色的MetaBlock 索引和蓝色的数据索引块以及一个文件尾部块。\n\n## 相关链接\n\n[LevelDB SSTable文件 - Tekkaman - 博客园](https://www.cnblogs.com/tekkaman/p/4877100.html)","source":"_posts/level-db-file.md","raw":"---\ntitle: 浅析levelDB文件格式\n---\n\n## 前言\n\nleveldb本身是基于文件来实现的高速kv数据库，期间涉及到了多种文件格式\n\n## 文件介绍\n\n### CURRENT文件\n\n此文件是针对奔溃恢复时，定位MANIFEST文件使用，其中的存储内容就是MANIFEST文件的文件名。\n\n### LOCK文件\n\n此文件控制多进程访问数据库的关键。当一个进程打开了数据库时，会在这个文件上加上互斥文件锁，进程结束时，锁就会自动释放。\n\n### MANIFEST文件\n\n所有文件的 Key 取值范围、层级和其它元信息会存储在数据库目录里面的 MANIFEST 文件中。数据库打开时，读取一下这个文件就知道了所有文件的层级和 Key 取值范围。\n\nMANIFEST 文件也有版本号，它的版本号体现在文件名上如 MANIFEST-000361。每一次重新打开数据库，都会生成一个新的 MANIFEST 文件，具有不同的版本号，然后还需要将老的 MANIFEST 文件删除。\n\n数据库目录中还有另外一个文件 CURRENT，它里面的内容很简单，就是当前 MANIFEST 的文件名。LevelDB 首先读取 CURRENT 文件才知道哪个 MANIFEST 文件是有效文件。在遇到断电时，会存在一个小概率中间状态，新旧 MANIFEST 文件共存于数据库目录中。\n\n### LOG文件\n\n在LevelDb中的主要作用是系统故障恢复时，能够保证不会丢失数据。因为在将记录写入内存的Memtable之前，会先写入Log文件，这样即使系统发生故障，Memtable中的数据没有来得及Dump到磁盘的SSTable文件，LevelDB也可以根据log文件恢复内存的Memtable数据结构内容，不会造成系统丢失数据.\n\nLog文件，会把它切割成以32K为单位的物理Block，每次读取的单位以一个Block作为基本读取单位\n\n### SST文件\n\n同Log文件一样，也是划分为固定大小的存储块，每个Block分为三个部分，红色部分是数据存储区， 蓝色的Type区用于标识数据存储区是否采用了数据压缩算法（Snappy压缩或者无压缩两种），CRC部分则是数据校验码，用于判别数据是否在生成和传输中出错。\n\n从大的方面，可以将.sst文件划分为数据存储区和数据管理区，数据存储区存放实际的Key:Value数据，数据管理区则提供一些索引指针等管理数据，目的是更快速便捷的查找相应的记录。两个区域都是在上述的分块基础上的，就是说文件的前面若干块实际存储KV数据，后面数据管理区存储管理数据。管理数据又分为四种不同类型：紫色的Meta Block，红色的MetaBlock 索引和蓝色的数据索引块以及一个文件尾部块。\n\n## 相关链接\n\n[LevelDB SSTable文件 - Tekkaman - 博客园](https://www.cnblogs.com/tekkaman/p/4877100.html)","slug":"level-db-file","published":1,"date":"2021-08-13T17:27:47.498Z","updated":"2021-08-13T17:27:47.498Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckti9vicr00079gtj3l9i61d1","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>leveldb本身是基于文件来实现的高速kv数据库，期间涉及到了多种文件格式</p>\n<h2 id=\"文件介绍\"><a href=\"#文件介绍\" class=\"headerlink\" title=\"文件介绍\"></a>文件介绍</h2><h3 id=\"CURRENT文件\"><a href=\"#CURRENT文件\" class=\"headerlink\" title=\"CURRENT文件\"></a>CURRENT文件</h3><p>此文件是针对奔溃恢复时，定位MANIFEST文件使用，其中的存储内容就是MANIFEST文件的文件名。</p>\n<h3 id=\"LOCK文件\"><a href=\"#LOCK文件\" class=\"headerlink\" title=\"LOCK文件\"></a>LOCK文件</h3><p>此文件控制多进程访问数据库的关键。当一个进程打开了数据库时，会在这个文件上加上互斥文件锁，进程结束时，锁就会自动释放。</p>\n<h3 id=\"MANIFEST文件\"><a href=\"#MANIFEST文件\" class=\"headerlink\" title=\"MANIFEST文件\"></a>MANIFEST文件</h3><p>所有文件的 Key 取值范围、层级和其它元信息会存储在数据库目录里面的 MANIFEST 文件中。数据库打开时，读取一下这个文件就知道了所有文件的层级和 Key 取值范围。</p>\n<p>MANIFEST 文件也有版本号，它的版本号体现在文件名上如 MANIFEST-000361。每一次重新打开数据库，都会生成一个新的 MANIFEST 文件，具有不同的版本号，然后还需要将老的 MANIFEST 文件删除。</p>\n<p>数据库目录中还有另外一个文件 CURRENT，它里面的内容很简单，就是当前 MANIFEST 的文件名。LevelDB 首先读取 CURRENT 文件才知道哪个 MANIFEST 文件是有效文件。在遇到断电时，会存在一个小概率中间状态，新旧 MANIFEST 文件共存于数据库目录中。</p>\n<h3 id=\"LOG文件\"><a href=\"#LOG文件\" class=\"headerlink\" title=\"LOG文件\"></a>LOG文件</h3><p>在LevelDb中的主要作用是系统故障恢复时，能够保证不会丢失数据。因为在将记录写入内存的Memtable之前，会先写入Log文件，这样即使系统发生故障，Memtable中的数据没有来得及Dump到磁盘的SSTable文件，LevelDB也可以根据log文件恢复内存的Memtable数据结构内容，不会造成系统丢失数据.</p>\n<p>Log文件，会把它切割成以32K为单位的物理Block，每次读取的单位以一个Block作为基本读取单位</p>\n<h3 id=\"SST文件\"><a href=\"#SST文件\" class=\"headerlink\" title=\"SST文件\"></a>SST文件</h3><p>同Log文件一样，也是划分为固定大小的存储块，每个Block分为三个部分，红色部分是数据存储区， 蓝色的Type区用于标识数据存储区是否采用了数据压缩算法（Snappy压缩或者无压缩两种），CRC部分则是数据校验码，用于判别数据是否在生成和传输中出错。</p>\n<p>从大的方面，可以将.sst文件划分为数据存储区和数据管理区，数据存储区存放实际的Key:Value数据，数据管理区则提供一些索引指针等管理数据，目的是更快速便捷的查找相应的记录。两个区域都是在上述的分块基础上的，就是说文件的前面若干块实际存储KV数据，后面数据管理区存储管理数据。管理数据又分为四种不同类型：紫色的Meta Block，红色的MetaBlock 索引和蓝色的数据索引块以及一个文件尾部块。</p>\n<h2 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h2><p><a href=\"https://www.cnblogs.com/tekkaman/p/4877100.html\" target=\"_blank\" rel=\"noopener\">LevelDB SSTable文件 - Tekkaman - 博客园</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>leveldb本身是基于文件来实现的高速kv数据库，期间涉及到了多种文件格式</p>\n<h2 id=\"文件介绍\"><a href=\"#文件介绍\" class=\"headerlink\" title=\"文件介绍\"></a>文件介绍</h2><h3 id=\"CURRENT文件\"><a href=\"#CURRENT文件\" class=\"headerlink\" title=\"CURRENT文件\"></a>CURRENT文件</h3><p>此文件是针对奔溃恢复时，定位MANIFEST文件使用，其中的存储内容就是MANIFEST文件的文件名。</p>\n<h3 id=\"LOCK文件\"><a href=\"#LOCK文件\" class=\"headerlink\" title=\"LOCK文件\"></a>LOCK文件</h3><p>此文件控制多进程访问数据库的关键。当一个进程打开了数据库时，会在这个文件上加上互斥文件锁，进程结束时，锁就会自动释放。</p>\n<h3 id=\"MANIFEST文件\"><a href=\"#MANIFEST文件\" class=\"headerlink\" title=\"MANIFEST文件\"></a>MANIFEST文件</h3><p>所有文件的 Key 取值范围、层级和其它元信息会存储在数据库目录里面的 MANIFEST 文件中。数据库打开时，读取一下这个文件就知道了所有文件的层级和 Key 取值范围。</p>\n<p>MANIFEST 文件也有版本号，它的版本号体现在文件名上如 MANIFEST-000361。每一次重新打开数据库，都会生成一个新的 MANIFEST 文件，具有不同的版本号，然后还需要将老的 MANIFEST 文件删除。</p>\n<p>数据库目录中还有另外一个文件 CURRENT，它里面的内容很简单，就是当前 MANIFEST 的文件名。LevelDB 首先读取 CURRENT 文件才知道哪个 MANIFEST 文件是有效文件。在遇到断电时，会存在一个小概率中间状态，新旧 MANIFEST 文件共存于数据库目录中。</p>\n<h3 id=\"LOG文件\"><a href=\"#LOG文件\" class=\"headerlink\" title=\"LOG文件\"></a>LOG文件</h3><p>在LevelDb中的主要作用是系统故障恢复时，能够保证不会丢失数据。因为在将记录写入内存的Memtable之前，会先写入Log文件，这样即使系统发生故障，Memtable中的数据没有来得及Dump到磁盘的SSTable文件，LevelDB也可以根据log文件恢复内存的Memtable数据结构内容，不会造成系统丢失数据.</p>\n<p>Log文件，会把它切割成以32K为单位的物理Block，每次读取的单位以一个Block作为基本读取单位</p>\n<h3 id=\"SST文件\"><a href=\"#SST文件\" class=\"headerlink\" title=\"SST文件\"></a>SST文件</h3><p>同Log文件一样，也是划分为固定大小的存储块，每个Block分为三个部分，红色部分是数据存储区， 蓝色的Type区用于标识数据存储区是否采用了数据压缩算法（Snappy压缩或者无压缩两种），CRC部分则是数据校验码，用于判别数据是否在生成和传输中出错。</p>\n<p>从大的方面，可以将.sst文件划分为数据存储区和数据管理区，数据存储区存放实际的Key:Value数据，数据管理区则提供一些索引指针等管理数据，目的是更快速便捷的查找相应的记录。两个区域都是在上述的分块基础上的，就是说文件的前面若干块实际存储KV数据，后面数据管理区存储管理数据。管理数据又分为四种不同类型：紫色的Meta Block，红色的MetaBlock 索引和蓝色的数据索引块以及一个文件尾部块。</p>\n<h2 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h2><p><a href=\"https://www.cnblogs.com/tekkaman/p/4877100.html\" target=\"_blank\" rel=\"noopener\">LevelDB SSTable文件 - Tekkaman - 博客园</a></p>\n"},{"title":"浅析levelDB流程（读流程）","_content":"\n## 前言\n\n前文描述完写流程，此时就需要描述一下大体的数据读取流程。\n\n## 命令封装\n\n读取的时候，由于是kv数据库，当然只会有一个参数，那就是key的值，同时还有一个读取时的选型，当前是包含是否读取缓存、是否严格查询。两者含义挖坑之后再填\n\n同时，在得到key的数据后，为了避免读写冲突，所以会在db层面生成一个快照，保证读取的数据不会被后来的写入所影响，这也是变现的实现了一下可重复读？\n\n而具体的快照，则只是当前数据库中的唯一递增序号。这也避免了在读取时，数据被销毁，导致数据丢失。\n\n进入读取方法后，leveldb还会将读取命令生成一个internalKey对象，其中包含`key`、`seq`、`keyType`三个属性。\n\n\n## 读取MEM流程\n\n`get`方法里面，还支持传入memDB和tFile对象，目的是支持事务操作，这块逻辑暂不考虑。\n\n拿到数据后，则优先从`memDB`中获取数据，当然，在leveldb中，memDB一直存在2个：`mem`和`frozenMem`。在读取时，为了避免内存变更，则将2者进行引用增加。\n\n获取到memDB后,则直接从跳表中获取,\b\b如果获取到后，则直接返回，此时，引用并没有清理，且引用清理时机过长，完全可能导致引用一直不释放。\n\n## 读取FILE流程\n\nfile中，则涉及到version的概念，因为之前讲过，version中保存了整个leveldb的文件信息，所以，在数据读取时，还是需要保证version不会被销毁，同理还是增加引用。\n\n其次则就会传入key信息，此时，则需要对leveldb每一次文件进行遍历。\n\n第一遍历level0文件，全部遍历，第二则遍历levle0+的文件，则只需要对比最大key信息即可，\n\n\n\n","source":"_posts/level-db-read.md","raw":"---\ntitle: 浅析levelDB流程（读流程）\n---\n\n## 前言\n\n前文描述完写流程，此时就需要描述一下大体的数据读取流程。\n\n## 命令封装\n\n读取的时候，由于是kv数据库，当然只会有一个参数，那就是key的值，同时还有一个读取时的选型，当前是包含是否读取缓存、是否严格查询。两者含义挖坑之后再填\n\n同时，在得到key的数据后，为了避免读写冲突，所以会在db层面生成一个快照，保证读取的数据不会被后来的写入所影响，这也是变现的实现了一下可重复读？\n\n而具体的快照，则只是当前数据库中的唯一递增序号。这也避免了在读取时，数据被销毁，导致数据丢失。\n\n进入读取方法后，leveldb还会将读取命令生成一个internalKey对象，其中包含`key`、`seq`、`keyType`三个属性。\n\n\n## 读取MEM流程\n\n`get`方法里面，还支持传入memDB和tFile对象，目的是支持事务操作，这块逻辑暂不考虑。\n\n拿到数据后，则优先从`memDB`中获取数据，当然，在leveldb中，memDB一直存在2个：`mem`和`frozenMem`。在读取时，为了避免内存变更，则将2者进行引用增加。\n\n获取到memDB后,则直接从跳表中获取,\b\b如果获取到后，则直接返回，此时，引用并没有清理，且引用清理时机过长，完全可能导致引用一直不释放。\n\n## 读取FILE流程\n\nfile中，则涉及到version的概念，因为之前讲过，version中保存了整个leveldb的文件信息，所以，在数据读取时，还是需要保证version不会被销毁，同理还是增加引用。\n\n其次则就会传入key信息，此时，则需要对leveldb每一次文件进行遍历。\n\n第一遍历level0文件，全部遍历，第二则遍历levle0+的文件，则只需要对比最大key信息即可，\n\n\n\n","slug":"level-db-read","published":1,"date":"2021-08-13T17:27:47.499Z","updated":"2021-08-13T17:27:47.499Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckti9vics00089gtj5oun4khh","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前文描述完写流程，此时就需要描述一下大体的数据读取流程。</p>\n<h2 id=\"命令封装\"><a href=\"#命令封装\" class=\"headerlink\" title=\"命令封装\"></a>命令封装</h2><p>读取的时候，由于是kv数据库，当然只会有一个参数，那就是key的值，同时还有一个读取时的选型，当前是包含是否读取缓存、是否严格查询。两者含义挖坑之后再填</p>\n<p>同时，在得到key的数据后，为了避免读写冲突，所以会在db层面生成一个快照，保证读取的数据不会被后来的写入所影响，这也是变现的实现了一下可重复读？</p>\n<p>而具体的快照，则只是当前数据库中的唯一递增序号。这也避免了在读取时，数据被销毁，导致数据丢失。</p>\n<p>进入读取方法后，leveldb还会将读取命令生成一个internalKey对象，其中包含<code>key</code>、<code>seq</code>、<code>keyType</code>三个属性。</p>\n<h2 id=\"读取MEM流程\"><a href=\"#读取MEM流程\" class=\"headerlink\" title=\"读取MEM流程\"></a>读取MEM流程</h2><p><code>get</code>方法里面，还支持传入memDB和tFile对象，目的是支持事务操作，这块逻辑暂不考虑。</p>\n<p>拿到数据后，则优先从<code>memDB</code>中获取数据，当然，在leveldb中，memDB一直存在2个：<code>mem</code>和<code>frozenMem</code>。在读取时，为了避免内存变更，则将2者进行引用增加。</p>\n<p>获取到memDB后,则直接从跳表中获取,\b\b如果获取到后，则直接返回，此时，引用并没有清理，且引用清理时机过长，完全可能导致引用一直不释放。</p>\n<h2 id=\"读取FILE流程\"><a href=\"#读取FILE流程\" class=\"headerlink\" title=\"读取FILE流程\"></a>读取FILE流程</h2><p>file中，则涉及到version的概念，因为之前讲过，version中保存了整个leveldb的文件信息，所以，在数据读取时，还是需要保证version不会被销毁，同理还是增加引用。</p>\n<p>其次则就会传入key信息，此时，则需要对leveldb每一次文件进行遍历。</p>\n<p>第一遍历level0文件，全部遍历，第二则遍历levle0+的文件，则只需要对比最大key信息即可，</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前文描述完写流程，此时就需要描述一下大体的数据读取流程。</p>\n<h2 id=\"命令封装\"><a href=\"#命令封装\" class=\"headerlink\" title=\"命令封装\"></a>命令封装</h2><p>读取的时候，由于是kv数据库，当然只会有一个参数，那就是key的值，同时还有一个读取时的选型，当前是包含是否读取缓存、是否严格查询。两者含义挖坑之后再填</p>\n<p>同时，在得到key的数据后，为了避免读写冲突，所以会在db层面生成一个快照，保证读取的数据不会被后来的写入所影响，这也是变现的实现了一下可重复读？</p>\n<p>而具体的快照，则只是当前数据库中的唯一递增序号。这也避免了在读取时，数据被销毁，导致数据丢失。</p>\n<p>进入读取方法后，leveldb还会将读取命令生成一个internalKey对象，其中包含<code>key</code>、<code>seq</code>、<code>keyType</code>三个属性。</p>\n<h2 id=\"读取MEM流程\"><a href=\"#读取MEM流程\" class=\"headerlink\" title=\"读取MEM流程\"></a>读取MEM流程</h2><p><code>get</code>方法里面，还支持传入memDB和tFile对象，目的是支持事务操作，这块逻辑暂不考虑。</p>\n<p>拿到数据后，则优先从<code>memDB</code>中获取数据，当然，在leveldb中，memDB一直存在2个：<code>mem</code>和<code>frozenMem</code>。在读取时，为了避免内存变更，则将2者进行引用增加。</p>\n<p>获取到memDB后,则直接从跳表中获取,\b\b如果获取到后，则直接返回，此时，引用并没有清理，且引用清理时机过长，完全可能导致引用一直不释放。</p>\n<h2 id=\"读取FILE流程\"><a href=\"#读取FILE流程\" class=\"headerlink\" title=\"读取FILE流程\"></a>读取FILE流程</h2><p>file中，则涉及到version的概念，因为之前讲过，version中保存了整个leveldb的文件信息，所以，在数据读取时，还是需要保证version不会被销毁，同理还是增加引用。</p>\n<p>其次则就会传入key信息，此时，则需要对leveldb每一次文件进行遍历。</p>\n<p>第一遍历level0文件，全部遍历，第二则遍历levle0+的文件，则只需要对比最大key信息即可，</p>\n"},{"title":"关于LevelDB中的管道","_content":"\n在开源项目https://github.com/syndtr/goleveldb中，存在大量的管道通信，而没有使用类似于锁之类的操作，在写法上是一件特别麻烦的事情。不过这也是项目高性能的一大原因。\n\n## 管道汇总\n\n#### 写相关管道\n\nwriteMergeC/writeMergedC\n\n这是一对通信方式，当写入时，判断writeMergeC是能够写入，能写入表示抢到了锁操作，并继续往下执行，等待拿到writeMergedC消息，说明自己的写入已经被人合并，并不需要处理。\n\n当然如果当前处理未成功，则会继续往下处理，由另外一个协程进行合并操作。\n\nwriteLockC\n\n这个管道和上述的writeMerge是并集操作，当写入成功该管道，则认为抢锁成功，继续往下执行写入操作。当写入完成后，则会释放锁资源。\n\nwriteAckC\n\nack的管道则是表示当前的操作结果，前2者表示的当前处理流程是否成功。\n\n三者使用了管道来完成了一个队列的功能\n\n### 压缩相关管道\n\ntcompCmdC\n\n该管道表示写入一个cCmd，用于触发压缩操作，这个是由于压缩是一个单独的协程来循环处理，所以需要管道通信\n\ntcompPauseC\n\n这个则是为了快速暂停table的压缩流程，通过管道传入一个管道来让压缩流程停止。当然，如果已经开始进行实际的压缩操作，这个流程是无法终止的。\n\nmcompCmdC\n\n这个管道和tcompCmdC同理，也是用于触发压缩操作，只不过，这个操作是用于mem落入table文件时触发。\n\n## 错误相关管道\n\ncompErrC\\compPerErrC\\compErrSetC\n\n这三者构成了一个错误升级的结构，在压缩时，如果出现异常，则会写入compErrSetC，\n\n而如果当前compErrSetC管道堵住，且已经有compPerErrC产生，那直接panic，主要是因为compPerErrC是由于多次的compErrSetC错误导致写入。\n\n当然，如果compErrSetC成功过一次，则会降级等待，否则连续失败，且compErrC一直没人处理，则表示错误无法处理，并需要终止服务。\n\ncloseC\n\n这个管道则是在db调用关闭操作时触发，在等待操作中都有监听。\n\n## 总结\n\n可以看出，Golang管道不仅仅是一个通信工具，还能实现各类的加锁操作，包括锁升级。","source":"_posts/level-db-chan.md","raw":"---\ntitle: 关于LevelDB中的管道\n---\n\n在开源项目https://github.com/syndtr/goleveldb中，存在大量的管道通信，而没有使用类似于锁之类的操作，在写法上是一件特别麻烦的事情。不过这也是项目高性能的一大原因。\n\n## 管道汇总\n\n#### 写相关管道\n\nwriteMergeC/writeMergedC\n\n这是一对通信方式，当写入时，判断writeMergeC是能够写入，能写入表示抢到了锁操作，并继续往下执行，等待拿到writeMergedC消息，说明自己的写入已经被人合并，并不需要处理。\n\n当然如果当前处理未成功，则会继续往下处理，由另外一个协程进行合并操作。\n\nwriteLockC\n\n这个管道和上述的writeMerge是并集操作，当写入成功该管道，则认为抢锁成功，继续往下执行写入操作。当写入完成后，则会释放锁资源。\n\nwriteAckC\n\nack的管道则是表示当前的操作结果，前2者表示的当前处理流程是否成功。\n\n三者使用了管道来完成了一个队列的功能\n\n### 压缩相关管道\n\ntcompCmdC\n\n该管道表示写入一个cCmd，用于触发压缩操作，这个是由于压缩是一个单独的协程来循环处理，所以需要管道通信\n\ntcompPauseC\n\n这个则是为了快速暂停table的压缩流程，通过管道传入一个管道来让压缩流程停止。当然，如果已经开始进行实际的压缩操作，这个流程是无法终止的。\n\nmcompCmdC\n\n这个管道和tcompCmdC同理，也是用于触发压缩操作，只不过，这个操作是用于mem落入table文件时触发。\n\n## 错误相关管道\n\ncompErrC\\compPerErrC\\compErrSetC\n\n这三者构成了一个错误升级的结构，在压缩时，如果出现异常，则会写入compErrSetC，\n\n而如果当前compErrSetC管道堵住，且已经有compPerErrC产生，那直接panic，主要是因为compPerErrC是由于多次的compErrSetC错误导致写入。\n\n当然，如果compErrSetC成功过一次，则会降级等待，否则连续失败，且compErrC一直没人处理，则表示错误无法处理，并需要终止服务。\n\ncloseC\n\n这个管道则是在db调用关闭操作时触发，在等待操作中都有监听。\n\n## 总结\n\n可以看出，Golang管道不仅仅是一个通信工具，还能实现各类的加锁操作，包括锁升级。","slug":"level-db-chan","published":1,"date":"2021-08-13T17:27:47.498Z","updated":"2021-08-13T17:27:47.498Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckti9vics00099gtj6qwadny2","content":"<p>在开源项目<a href=\"https://github.com/syndtr/goleveldb中，存在大量的管道通信，而没有使用类似于锁之类的操作，在写法上是一件特别麻烦的事情。不过这也是项目高性能的一大原因。\" target=\"_blank\" rel=\"noopener\">https://github.com/syndtr/goleveldb中，存在大量的管道通信，而没有使用类似于锁之类的操作，在写法上是一件特别麻烦的事情。不过这也是项目高性能的一大原因。</a></p>\n<h2 id=\"管道汇总\"><a href=\"#管道汇总\" class=\"headerlink\" title=\"管道汇总\"></a>管道汇总</h2><h4 id=\"写相关管道\"><a href=\"#写相关管道\" class=\"headerlink\" title=\"写相关管道\"></a>写相关管道</h4><p>writeMergeC/writeMergedC</p>\n<p>这是一对通信方式，当写入时，判断writeMergeC是能够写入，能写入表示抢到了锁操作，并继续往下执行，等待拿到writeMergedC消息，说明自己的写入已经被人合并，并不需要处理。</p>\n<p>当然如果当前处理未成功，则会继续往下处理，由另外一个协程进行合并操作。</p>\n<p>writeLockC</p>\n<p>这个管道和上述的writeMerge是并集操作，当写入成功该管道，则认为抢锁成功，继续往下执行写入操作。当写入完成后，则会释放锁资源。</p>\n<p>writeAckC</p>\n<p>ack的管道则是表示当前的操作结果，前2者表示的当前处理流程是否成功。</p>\n<p>三者使用了管道来完成了一个队列的功能</p>\n<h3 id=\"压缩相关管道\"><a href=\"#压缩相关管道\" class=\"headerlink\" title=\"压缩相关管道\"></a>压缩相关管道</h3><p>tcompCmdC</p>\n<p>该管道表示写入一个cCmd，用于触发压缩操作，这个是由于压缩是一个单独的协程来循环处理，所以需要管道通信</p>\n<p>tcompPauseC</p>\n<p>这个则是为了快速暂停table的压缩流程，通过管道传入一个管道来让压缩流程停止。当然，如果已经开始进行实际的压缩操作，这个流程是无法终止的。</p>\n<p>mcompCmdC</p>\n<p>这个管道和tcompCmdC同理，也是用于触发压缩操作，只不过，这个操作是用于mem落入table文件时触发。</p>\n<h2 id=\"错误相关管道\"><a href=\"#错误相关管道\" class=\"headerlink\" title=\"错误相关管道\"></a>错误相关管道</h2><p>compErrC\\compPerErrC\\compErrSetC</p>\n<p>这三者构成了一个错误升级的结构，在压缩时，如果出现异常，则会写入compErrSetC，</p>\n<p>而如果当前compErrSetC管道堵住，且已经有compPerErrC产生，那直接panic，主要是因为compPerErrC是由于多次的compErrSetC错误导致写入。</p>\n<p>当然，如果compErrSetC成功过一次，则会降级等待，否则连续失败，且compErrC一直没人处理，则表示错误无法处理，并需要终止服务。</p>\n<p>closeC</p>\n<p>这个管道则是在db调用关闭操作时触发，在等待操作中都有监听。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>可以看出，Golang管道不仅仅是一个通信工具，还能实现各类的加锁操作，包括锁升级。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在开源项目<a href=\"https://github.com/syndtr/goleveldb中，存在大量的管道通信，而没有使用类似于锁之类的操作，在写法上是一件特别麻烦的事情。不过这也是项目高性能的一大原因。\" target=\"_blank\" rel=\"noopener\">https://github.com/syndtr/goleveldb中，存在大量的管道通信，而没有使用类似于锁之类的操作，在写法上是一件特别麻烦的事情。不过这也是项目高性能的一大原因。</a></p>\n<h2 id=\"管道汇总\"><a href=\"#管道汇总\" class=\"headerlink\" title=\"管道汇总\"></a>管道汇总</h2><h4 id=\"写相关管道\"><a href=\"#写相关管道\" class=\"headerlink\" title=\"写相关管道\"></a>写相关管道</h4><p>writeMergeC/writeMergedC</p>\n<p>这是一对通信方式，当写入时，判断writeMergeC是能够写入，能写入表示抢到了锁操作，并继续往下执行，等待拿到writeMergedC消息，说明自己的写入已经被人合并，并不需要处理。</p>\n<p>当然如果当前处理未成功，则会继续往下处理，由另外一个协程进行合并操作。</p>\n<p>writeLockC</p>\n<p>这个管道和上述的writeMerge是并集操作，当写入成功该管道，则认为抢锁成功，继续往下执行写入操作。当写入完成后，则会释放锁资源。</p>\n<p>writeAckC</p>\n<p>ack的管道则是表示当前的操作结果，前2者表示的当前处理流程是否成功。</p>\n<p>三者使用了管道来完成了一个队列的功能</p>\n<h3 id=\"压缩相关管道\"><a href=\"#压缩相关管道\" class=\"headerlink\" title=\"压缩相关管道\"></a>压缩相关管道</h3><p>tcompCmdC</p>\n<p>该管道表示写入一个cCmd，用于触发压缩操作，这个是由于压缩是一个单独的协程来循环处理，所以需要管道通信</p>\n<p>tcompPauseC</p>\n<p>这个则是为了快速暂停table的压缩流程，通过管道传入一个管道来让压缩流程停止。当然，如果已经开始进行实际的压缩操作，这个流程是无法终止的。</p>\n<p>mcompCmdC</p>\n<p>这个管道和tcompCmdC同理，也是用于触发压缩操作，只不过，这个操作是用于mem落入table文件时触发。</p>\n<h2 id=\"错误相关管道\"><a href=\"#错误相关管道\" class=\"headerlink\" title=\"错误相关管道\"></a>错误相关管道</h2><p>compErrC\\compPerErrC\\compErrSetC</p>\n<p>这三者构成了一个错误升级的结构，在压缩时，如果出现异常，则会写入compErrSetC，</p>\n<p>而如果当前compErrSetC管道堵住，且已经有compPerErrC产生，那直接panic，主要是因为compPerErrC是由于多次的compErrSetC错误导致写入。</p>\n<p>当然，如果compErrSetC成功过一次，则会降级等待，否则连续失败，且compErrC一直没人处理，则表示错误无法处理，并需要终止服务。</p>\n<p>closeC</p>\n<p>这个管道则是在db调用关闭操作时触发，在等待操作中都有监听。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>可以看出，Golang管道不仅仅是一个通信工具，还能实现各类的加锁操作，包括锁升级。</p>\n"},{"title":"LevelDB实践","_content":"\n关于LevelDB，众所周知就是google基于lsm不断演化出来的一种kv存储库。而中间有各种语言的不同版本，今天则直接介绍一下golang版本中的一下实例。\n\n### 基本功能\n作为kv存储库，本身leveldb并不是和redis以及mysql一样拥有自己的独立服务，它本身是作为一个三方库，支持各个服务直接使用，这更像sqllite的能力，这中间就需要指定一个路径作为数据库的基本空间。\n\n```\ndb, err := leveldb.OpenFile(\"path/to/db\", nil)\n...\ndefer db.Close()\n```\n通过OpenFile方法，便可以指定对应的数据库路径，第二个参数则是当前数据库的相关属性，例如过滤器类型、缓存大小、压缩属性相关，这块就放在后面细说\n\n当打开数据库后，kv存储基本上就是3类操作：插入和查询、删除，只不过删除在最底层实现也还是插入逻辑。具体使用也是如下：\n```\nerr = db.Put([]byte(\"key\"), []byte(\"value\"), nil)\n\nif err != nil {\n\tpanic(err)\n}\n\ndata, err := db.Get([]byte(\"key\"), nil)\n\nif err != nil {\n\tpanic(err)\n}\n\nfmt.Println(data)\n\nerr = db.Delete([]byte(\"key\"), nil)\n\nif err != nil {\n\tpanic(err)\n}  \n```\n方法基本上没有什么特殊之处，而第二个参数都是操作中基本上需要的一下配置化信息：插入和更新操作关心**是否强制落库**以及**是否支持合并写入**、而查询所关心的则是**是否不走缓存**。\n\n当然，为了高性能，leveldb本身也支持批量插入\n```\nbatch := new(leveldb.Batch)\nbatch.Put([]byte(\"foo\"), []byte(\"value\"))\nbatch.Put([]byte(\"bar\"), []byte(\"another value\"))\nbatch.Delete([]byte(\"baz\"))\nerr = db.Write(batch, nil)\n```\n\b批量插入的核心优点就是会打开一个事务保证此次的插入原子性。关于本身事务的实现，这也是后续的一个课题。\n\n### 遍历\n\n当数据的存储已经给出实例，那这块还需要有检索能力，才能支持更丰富的应用场景。\n而关于遍历。由于本身是一个高性能的并发数据库，当并行时出现变更，则会导致遍历异常，而若直接加锁，则会导致性能的大规模损坏。这也映射了mysql中的mvcc实现。\n在leveldb中，直接使用的是迭代器+快照的方法来实现遍历能力。而遍历本身也就分为全局遍历、部分遍历、范围遍历、匹配遍历。这块也暂时举几个🌰，让人有直观的印象。\n```\n\tfor i := 0; i < 5; i++ {\n\t\tdb.Put([]byte(gofakeit.Name()), []byte(gofakeit.Address().Address), nil)\n\t}\n\n\titer := db.NewIterator(nil, nil)\n\tfor iter.Next() {\n\t\t// Remember that the contents of the returned slice should not be modified, and\n\t\t// only valid until the next call to Next.\n\t\tkey := iter.Key()\n\t\tvalue := iter.Value()\n\t\tfmt.Println(\"all date: \", string(key), \" -> \", string(value))\n\t}\n\titer.Release()\n```\n> 生成数据本身使用的是`github.com/brianvoe/gofakeit`\n而针对范围遍历。我们只需要更改一下迭代器的生成即可：\n```\niter = db.NewIterator(&util.Range{Start: []byte(\"Trinity Runte\"), Limit: []byte(\"Vito Gulgowski\")}, nil)\n```\n部分遍历。则是通过迭代器本身的seek方法来找到偏移量：\n```\niter.Seek([]byte(\"Trinity Runte\"))\n```\n还有一个有趣的点是，遍历能支持前缀匹配：\n```\niter := db.NewIterator(util.BytesPrefix([]byte(\"foo-\")), nil)\n```\n关于遍历本身，其实么有特别多好讲的，更多的是遍历对性能上是一个较大的损失，因为本身leveldb是分层文件，遍历则表示需要将所有数据全部查询，其中也就包括热点和非热点数据，这样会变现导致io的压力增加。\n","source":"_posts/level-db-demo.md","raw":"---\ntitle: LevelDB实践\n---\n\n关于LevelDB，众所周知就是google基于lsm不断演化出来的一种kv存储库。而中间有各种语言的不同版本，今天则直接介绍一下golang版本中的一下实例。\n\n### 基本功能\n作为kv存储库，本身leveldb并不是和redis以及mysql一样拥有自己的独立服务，它本身是作为一个三方库，支持各个服务直接使用，这更像sqllite的能力，这中间就需要指定一个路径作为数据库的基本空间。\n\n```\ndb, err := leveldb.OpenFile(\"path/to/db\", nil)\n...\ndefer db.Close()\n```\n通过OpenFile方法，便可以指定对应的数据库路径，第二个参数则是当前数据库的相关属性，例如过滤器类型、缓存大小、压缩属性相关，这块就放在后面细说\n\n当打开数据库后，kv存储基本上就是3类操作：插入和查询、删除，只不过删除在最底层实现也还是插入逻辑。具体使用也是如下：\n```\nerr = db.Put([]byte(\"key\"), []byte(\"value\"), nil)\n\nif err != nil {\n\tpanic(err)\n}\n\ndata, err := db.Get([]byte(\"key\"), nil)\n\nif err != nil {\n\tpanic(err)\n}\n\nfmt.Println(data)\n\nerr = db.Delete([]byte(\"key\"), nil)\n\nif err != nil {\n\tpanic(err)\n}  \n```\n方法基本上没有什么特殊之处，而第二个参数都是操作中基本上需要的一下配置化信息：插入和更新操作关心**是否强制落库**以及**是否支持合并写入**、而查询所关心的则是**是否不走缓存**。\n\n当然，为了高性能，leveldb本身也支持批量插入\n```\nbatch := new(leveldb.Batch)\nbatch.Put([]byte(\"foo\"), []byte(\"value\"))\nbatch.Put([]byte(\"bar\"), []byte(\"another value\"))\nbatch.Delete([]byte(\"baz\"))\nerr = db.Write(batch, nil)\n```\n\b批量插入的核心优点就是会打开一个事务保证此次的插入原子性。关于本身事务的实现，这也是后续的一个课题。\n\n### 遍历\n\n当数据的存储已经给出实例，那这块还需要有检索能力，才能支持更丰富的应用场景。\n而关于遍历。由于本身是一个高性能的并发数据库，当并行时出现变更，则会导致遍历异常，而若直接加锁，则会导致性能的大规模损坏。这也映射了mysql中的mvcc实现。\n在leveldb中，直接使用的是迭代器+快照的方法来实现遍历能力。而遍历本身也就分为全局遍历、部分遍历、范围遍历、匹配遍历。这块也暂时举几个🌰，让人有直观的印象。\n```\n\tfor i := 0; i < 5; i++ {\n\t\tdb.Put([]byte(gofakeit.Name()), []byte(gofakeit.Address().Address), nil)\n\t}\n\n\titer := db.NewIterator(nil, nil)\n\tfor iter.Next() {\n\t\t// Remember that the contents of the returned slice should not be modified, and\n\t\t// only valid until the next call to Next.\n\t\tkey := iter.Key()\n\t\tvalue := iter.Value()\n\t\tfmt.Println(\"all date: \", string(key), \" -> \", string(value))\n\t}\n\titer.Release()\n```\n> 生成数据本身使用的是`github.com/brianvoe/gofakeit`\n而针对范围遍历。我们只需要更改一下迭代器的生成即可：\n```\niter = db.NewIterator(&util.Range{Start: []byte(\"Trinity Runte\"), Limit: []byte(\"Vito Gulgowski\")}, nil)\n```\n部分遍历。则是通过迭代器本身的seek方法来找到偏移量：\n```\niter.Seek([]byte(\"Trinity Runte\"))\n```\n还有一个有趣的点是，遍历能支持前缀匹配：\n```\niter := db.NewIterator(util.BytesPrefix([]byte(\"foo-\")), nil)\n```\n关于遍历本身，其实么有特别多好讲的，更多的是遍历对性能上是一个较大的损失，因为本身leveldb是分层文件，遍历则表示需要将所有数据全部查询，其中也就包括热点和非热点数据，这样会变现导致io的压力增加。\n","slug":"level-db-demo","published":1,"date":"2021-08-13T17:27:47.498Z","updated":"2021-08-13T17:27:47.498Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckti9vict000a9gtj975f6cpl","content":"<p>关于LevelDB，众所周知就是google基于lsm不断演化出来的一种kv存储库。而中间有各种语言的不同版本，今天则直接介绍一下golang版本中的一下实例。</p>\n<h3 id=\"基本功能\"><a href=\"#基本功能\" class=\"headerlink\" title=\"基本功能\"></a>基本功能</h3><p>作为kv存储库，本身leveldb并不是和redis以及mysql一样拥有自己的独立服务，它本身是作为一个三方库，支持各个服务直接使用，这更像sqllite的能力，这中间就需要指定一个路径作为数据库的基本空间。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db, err :&#x3D; leveldb.OpenFile(&quot;path&#x2F;to&#x2F;db&quot;, nil)</span><br><span class=\"line\">...</span><br><span class=\"line\">defer db.Close()</span><br></pre></td></tr></table></figure>\n<p>通过OpenFile方法，便可以指定对应的数据库路径，第二个参数则是当前数据库的相关属性，例如过滤器类型、缓存大小、压缩属性相关，这块就放在后面细说</p>\n<p>当打开数据库后，kv存储基本上就是3类操作：插入和查询、删除，只不过删除在最底层实现也还是插入逻辑。具体使用也是如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">err &#x3D; db.Put([]byte(&quot;key&quot;), []byte(&quot;value&quot;), nil)</span><br><span class=\"line\"></span><br><span class=\"line\">if err !&#x3D; nil &#123;</span><br><span class=\"line\">\tpanic(err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">data, err :&#x3D; db.Get([]byte(&quot;key&quot;), nil)</span><br><span class=\"line\"></span><br><span class=\"line\">if err !&#x3D; nil &#123;</span><br><span class=\"line\">\tpanic(err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fmt.Println(data)</span><br><span class=\"line\"></span><br><span class=\"line\">err &#x3D; db.Delete([]byte(&quot;key&quot;), nil)</span><br><span class=\"line\"></span><br><span class=\"line\">if err !&#x3D; nil &#123;</span><br><span class=\"line\">\tpanic(err)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>方法基本上没有什么特殊之处，而第二个参数都是操作中基本上需要的一下配置化信息：插入和更新操作关心<strong>是否强制落库</strong>以及<strong>是否支持合并写入</strong>、而查询所关心的则是<strong>是否不走缓存</strong>。</p>\n<p>当然，为了高性能，leveldb本身也支持批量插入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">batch :&#x3D; new(leveldb.Batch)</span><br><span class=\"line\">batch.Put([]byte(&quot;foo&quot;), []byte(&quot;value&quot;))</span><br><span class=\"line\">batch.Put([]byte(&quot;bar&quot;), []byte(&quot;another value&quot;))</span><br><span class=\"line\">batch.Delete([]byte(&quot;baz&quot;))</span><br><span class=\"line\">err &#x3D; db.Write(batch, nil)</span><br></pre></td></tr></table></figure>\n<p>\b批量插入的核心优点就是会打开一个事务保证此次的插入原子性。关于本身事务的实现，这也是后续的一个课题。</p>\n<h3 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h3><p>当数据的存储已经给出实例，那这块还需要有检索能力，才能支持更丰富的应用场景。<br>而关于遍历。由于本身是一个高性能的并发数据库，当并行时出现变更，则会导致遍历异常，而若直接加锁，则会导致性能的大规模损坏。这也映射了mysql中的mvcc实现。<br>在leveldb中，直接使用的是迭代器+快照的方法来实现遍历能力。而遍历本身也就分为全局遍历、部分遍历、范围遍历、匹配遍历。这块也暂时举几个🌰，让人有直观的印象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for i :&#x3D; 0; i &lt; 5; i++ &#123;</span><br><span class=\"line\">\tdb.Put([]byte(gofakeit.Name()), []byte(gofakeit.Address().Address), nil)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">iter :&#x3D; db.NewIterator(nil, nil)</span><br><span class=\"line\">for iter.Next() &#123;</span><br><span class=\"line\">\t&#x2F;&#x2F; Remember that the contents of the returned slice should not be modified, and</span><br><span class=\"line\">\t&#x2F;&#x2F; only valid until the next call to Next.</span><br><span class=\"line\">\tkey :&#x3D; iter.Key()</span><br><span class=\"line\">\tvalue :&#x3D; iter.Value()</span><br><span class=\"line\">\tfmt.Println(&quot;all date: &quot;, string(key), &quot; -&gt; &quot;, string(value))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">iter.Release()</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>生成数据本身使用的是<code>github.com/brianvoe/gofakeit</code><br>而针对范围遍历。我们只需要更改一下迭代器的生成即可：</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iter &#x3D; db.NewIterator(&amp;util.Range&#123;Start: []byte(&quot;Trinity Runte&quot;), Limit: []byte(&quot;Vito Gulgowski&quot;)&#125;, nil)</span><br></pre></td></tr></table></figure>\n<p>部分遍历。则是通过迭代器本身的seek方法来找到偏移量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iter.Seek([]byte(&quot;Trinity Runte&quot;))</span><br></pre></td></tr></table></figure>\n<p>还有一个有趣的点是，遍历能支持前缀匹配：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iter :&#x3D; db.NewIterator(util.BytesPrefix([]byte(&quot;foo-&quot;)), nil)</span><br></pre></td></tr></table></figure>\n<p>关于遍历本身，其实么有特别多好讲的，更多的是遍历对性能上是一个较大的损失，因为本身leveldb是分层文件，遍历则表示需要将所有数据全部查询，其中也就包括热点和非热点数据，这样会变现导致io的压力增加。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>关于LevelDB，众所周知就是google基于lsm不断演化出来的一种kv存储库。而中间有各种语言的不同版本，今天则直接介绍一下golang版本中的一下实例。</p>\n<h3 id=\"基本功能\"><a href=\"#基本功能\" class=\"headerlink\" title=\"基本功能\"></a>基本功能</h3><p>作为kv存储库，本身leveldb并不是和redis以及mysql一样拥有自己的独立服务，它本身是作为一个三方库，支持各个服务直接使用，这更像sqllite的能力，这中间就需要指定一个路径作为数据库的基本空间。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db, err :&#x3D; leveldb.OpenFile(&quot;path&#x2F;to&#x2F;db&quot;, nil)</span><br><span class=\"line\">...</span><br><span class=\"line\">defer db.Close()</span><br></pre></td></tr></table></figure>\n<p>通过OpenFile方法，便可以指定对应的数据库路径，第二个参数则是当前数据库的相关属性，例如过滤器类型、缓存大小、压缩属性相关，这块就放在后面细说</p>\n<p>当打开数据库后，kv存储基本上就是3类操作：插入和查询、删除，只不过删除在最底层实现也还是插入逻辑。具体使用也是如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">err &#x3D; db.Put([]byte(&quot;key&quot;), []byte(&quot;value&quot;), nil)</span><br><span class=\"line\"></span><br><span class=\"line\">if err !&#x3D; nil &#123;</span><br><span class=\"line\">\tpanic(err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">data, err :&#x3D; db.Get([]byte(&quot;key&quot;), nil)</span><br><span class=\"line\"></span><br><span class=\"line\">if err !&#x3D; nil &#123;</span><br><span class=\"line\">\tpanic(err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fmt.Println(data)</span><br><span class=\"line\"></span><br><span class=\"line\">err &#x3D; db.Delete([]byte(&quot;key&quot;), nil)</span><br><span class=\"line\"></span><br><span class=\"line\">if err !&#x3D; nil &#123;</span><br><span class=\"line\">\tpanic(err)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>方法基本上没有什么特殊之处，而第二个参数都是操作中基本上需要的一下配置化信息：插入和更新操作关心<strong>是否强制落库</strong>以及<strong>是否支持合并写入</strong>、而查询所关心的则是<strong>是否不走缓存</strong>。</p>\n<p>当然，为了高性能，leveldb本身也支持批量插入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">batch :&#x3D; new(leveldb.Batch)</span><br><span class=\"line\">batch.Put([]byte(&quot;foo&quot;), []byte(&quot;value&quot;))</span><br><span class=\"line\">batch.Put([]byte(&quot;bar&quot;), []byte(&quot;another value&quot;))</span><br><span class=\"line\">batch.Delete([]byte(&quot;baz&quot;))</span><br><span class=\"line\">err &#x3D; db.Write(batch, nil)</span><br></pre></td></tr></table></figure>\n<p>\b批量插入的核心优点就是会打开一个事务保证此次的插入原子性。关于本身事务的实现，这也是后续的一个课题。</p>\n<h3 id=\"遍历\"><a href=\"#遍历\" class=\"headerlink\" title=\"遍历\"></a>遍历</h3><p>当数据的存储已经给出实例，那这块还需要有检索能力，才能支持更丰富的应用场景。<br>而关于遍历。由于本身是一个高性能的并发数据库，当并行时出现变更，则会导致遍历异常，而若直接加锁，则会导致性能的大规模损坏。这也映射了mysql中的mvcc实现。<br>在leveldb中，直接使用的是迭代器+快照的方法来实现遍历能力。而遍历本身也就分为全局遍历、部分遍历、范围遍历、匹配遍历。这块也暂时举几个🌰，让人有直观的印象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for i :&#x3D; 0; i &lt; 5; i++ &#123;</span><br><span class=\"line\">\tdb.Put([]byte(gofakeit.Name()), []byte(gofakeit.Address().Address), nil)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">iter :&#x3D; db.NewIterator(nil, nil)</span><br><span class=\"line\">for iter.Next() &#123;</span><br><span class=\"line\">\t&#x2F;&#x2F; Remember that the contents of the returned slice should not be modified, and</span><br><span class=\"line\">\t&#x2F;&#x2F; only valid until the next call to Next.</span><br><span class=\"line\">\tkey :&#x3D; iter.Key()</span><br><span class=\"line\">\tvalue :&#x3D; iter.Value()</span><br><span class=\"line\">\tfmt.Println(&quot;all date: &quot;, string(key), &quot; -&gt; &quot;, string(value))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">iter.Release()</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>生成数据本身使用的是<code>github.com/brianvoe/gofakeit</code><br>而针对范围遍历。我们只需要更改一下迭代器的生成即可：</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iter &#x3D; db.NewIterator(&amp;util.Range&#123;Start: []byte(&quot;Trinity Runte&quot;), Limit: []byte(&quot;Vito Gulgowski&quot;)&#125;, nil)</span><br></pre></td></tr></table></figure>\n<p>部分遍历。则是通过迭代器本身的seek方法来找到偏移量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iter.Seek([]byte(&quot;Trinity Runte&quot;))</span><br></pre></td></tr></table></figure>\n<p>还有一个有趣的点是，遍历能支持前缀匹配：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iter :&#x3D; db.NewIterator(util.BytesPrefix([]byte(&quot;foo-&quot;)), nil)</span><br></pre></td></tr></table></figure>\n<p>关于遍历本身，其实么有特别多好讲的，更多的是遍历对性能上是一个较大的损失，因为本身leveldb是分层文件，遍历则表示需要将所有数据全部查询，其中也就包括热点和非热点数据，这样会变现导致io的压力增加。</p>\n"},{"title":"浅析levelDB流程（写流程）","_content":"\n## 前言\n\n打开流程完成了整个db的初始化，而后就是整个level对比的存储流程，如何读写db是核心业务。当然读写自然会触发压缩流程，但本文单纯只会串联整个的读写过程，保证内容的简洁，至于压缩则另开一篇详解。\n\n\n## 写流程\n\n### 命令封装\n\n之前文章中，我们有提过更新的2个操作，在最后底层其实是一个操作：\n\n```\nfunc (db *DB) Put(key, value []byte, wo *opt.WriteOptions) error {\n\treturn db.putRec(keyTypeVal, key, value, wo)\n}\n\nfunc (db *DB) Delete(key []byte, wo *opt.WriteOptions) error {\n\treturn db.putRec(keyTypeDel, key, nil, wo)\n}\n```\n\n可以看出，在`Put`和`Delete`命令中，最终会直接调用`putRec`方法，而在此方法中，做的核心逻辑就是，抢锁，并等待信息，其中抢锁的逻辑还是由`channel`实现，逻辑后续再理，先了解一下写入流程`writeLocked`方法：\n```\nbatch := db.batchPool.Get().(*Batch)\nbatch.Reset()\nbatch.appendRec(kt, key, value)\nreturn db.writeLocked(batch, batch, merge, sync)\n```\n调用该方法后，则就是AOF写入以及落入`memdb`跳表数据库中：\n```\n\t// Seq number.\n\tseq := db.seq + 1\n\n\t// Write journal.\n\tif err := db.writeJournal(batches, seq, sync); err != nil {\n\t\tdb.unlockWrite(overflow, merged, err)\n\t\treturn err\n\t}\n\n\t// Put batches.\n\tfor _, batch := range batches {\n\t\tif err := batch.putMem(seq, mdb.DB); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tseq += uint64(batch.Len())\n\t}\n```\n至此，数据已经落入存储中，并返回告知请求处理正常。那么，这一套流程，中间还存在哪些问题呢？\n其中提高吞吐、提高内存空间利用率则是中间的优化点。\n\n### 合并写\n\n关于吞吐量的计算逻辑可以参考：https://zhuanlan.zhihu.com/p/337708438\n\n由于本身leveldb会写入内存，所以中间存在锁的抢占，而在golang中，leveldb使用的是channel进行锁争抢，当你能写入writeLockC管道时，便可以继续写入操作。然而，锁的争抢必定会导致性能下降，那么，合并写就成为了提供性能的一个解决方案。\n\n合并锁的逻辑就是，优先尝试写入writeMergeC管道中，如果写入成功，则等待合并写的结果返回\n```\ncase db.writeMergeC <- writeMerge{sync: sync, keyType: kt, key: key, value: value}:\n    if <-db.writeMergedC {\n        // Write is merged.\n        return <-db.writeAckC\n    }\n    // Write is not merged, the write lock is handed to us. Continue.\ncase db.writeLockC <- struct{}{}:\n    // Write lock acquired.\ncase err := <-db.compPerErrC:\n    // Compaction error.\n    return err\ncase <-db.closeC:\n    // Closed\n    return ErrClosed\n}\n```\n而如果合并锁写入不成功，则尝试去抢写入锁，如果当前写入锁还是没有释放，那其中有可能导致异常出现（猜测）。\n而在抢到写入锁的协程中，则会不断的等待合并写的请求达到上限\n```\nmerge: \n\nfor mergeLimit > 0 {\n    select {\n    case incoming := <-db.writeMergeC:\n        ... ...\n    default:\n        break merge\n    }\n}\n```\n由此可见，当一次写入异常时，常常会阻塞所有的合并写异常，所有，合并写其实是针对大数据量的变更。\n\n当然，如果处理完成后，则会写入writeAckC管道告知等待的写入，但是如果此次合并写并没有写入完成写入，则会使其抢锁成功，并自身去进行写入，这块逻辑便是之前的writeMergeC和writeLockC逻辑。\n```\nfunc (db *DB) unlockWrite(overflow bool, merged int, err error) {\n\tfor i := 0; i < merged; i++ {\n\t\tdb.writeAckC <- err\n\t}\n\tif overflow {\n\t\t// Pass lock to the next write (that failed to merge).\n\t\tdb.writeMergedC <- false\n\t} else {\n\t\t// Release lock.\n\t\t<-db.writeLockC\n\t}\n}\n```\n\n","source":"_posts/level-db-write.md","raw":"---\ntitle: 浅析levelDB流程（写流程）\n---\n\n## 前言\n\n打开流程完成了整个db的初始化，而后就是整个level对比的存储流程，如何读写db是核心业务。当然读写自然会触发压缩流程，但本文单纯只会串联整个的读写过程，保证内容的简洁，至于压缩则另开一篇详解。\n\n\n## 写流程\n\n### 命令封装\n\n之前文章中，我们有提过更新的2个操作，在最后底层其实是一个操作：\n\n```\nfunc (db *DB) Put(key, value []byte, wo *opt.WriteOptions) error {\n\treturn db.putRec(keyTypeVal, key, value, wo)\n}\n\nfunc (db *DB) Delete(key []byte, wo *opt.WriteOptions) error {\n\treturn db.putRec(keyTypeDel, key, nil, wo)\n}\n```\n\n可以看出，在`Put`和`Delete`命令中，最终会直接调用`putRec`方法，而在此方法中，做的核心逻辑就是，抢锁，并等待信息，其中抢锁的逻辑还是由`channel`实现，逻辑后续再理，先了解一下写入流程`writeLocked`方法：\n```\nbatch := db.batchPool.Get().(*Batch)\nbatch.Reset()\nbatch.appendRec(kt, key, value)\nreturn db.writeLocked(batch, batch, merge, sync)\n```\n调用该方法后，则就是AOF写入以及落入`memdb`跳表数据库中：\n```\n\t// Seq number.\n\tseq := db.seq + 1\n\n\t// Write journal.\n\tif err := db.writeJournal(batches, seq, sync); err != nil {\n\t\tdb.unlockWrite(overflow, merged, err)\n\t\treturn err\n\t}\n\n\t// Put batches.\n\tfor _, batch := range batches {\n\t\tif err := batch.putMem(seq, mdb.DB); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tseq += uint64(batch.Len())\n\t}\n```\n至此，数据已经落入存储中，并返回告知请求处理正常。那么，这一套流程，中间还存在哪些问题呢？\n其中提高吞吐、提高内存空间利用率则是中间的优化点。\n\n### 合并写\n\n关于吞吐量的计算逻辑可以参考：https://zhuanlan.zhihu.com/p/337708438\n\n由于本身leveldb会写入内存，所以中间存在锁的抢占，而在golang中，leveldb使用的是channel进行锁争抢，当你能写入writeLockC管道时，便可以继续写入操作。然而，锁的争抢必定会导致性能下降，那么，合并写就成为了提供性能的一个解决方案。\n\n合并锁的逻辑就是，优先尝试写入writeMergeC管道中，如果写入成功，则等待合并写的结果返回\n```\ncase db.writeMergeC <- writeMerge{sync: sync, keyType: kt, key: key, value: value}:\n    if <-db.writeMergedC {\n        // Write is merged.\n        return <-db.writeAckC\n    }\n    // Write is not merged, the write lock is handed to us. Continue.\ncase db.writeLockC <- struct{}{}:\n    // Write lock acquired.\ncase err := <-db.compPerErrC:\n    // Compaction error.\n    return err\ncase <-db.closeC:\n    // Closed\n    return ErrClosed\n}\n```\n而如果合并锁写入不成功，则尝试去抢写入锁，如果当前写入锁还是没有释放，那其中有可能导致异常出现（猜测）。\n而在抢到写入锁的协程中，则会不断的等待合并写的请求达到上限\n```\nmerge: \n\nfor mergeLimit > 0 {\n    select {\n    case incoming := <-db.writeMergeC:\n        ... ...\n    default:\n        break merge\n    }\n}\n```\n由此可见，当一次写入异常时，常常会阻塞所有的合并写异常，所有，合并写其实是针对大数据量的变更。\n\n当然，如果处理完成后，则会写入writeAckC管道告知等待的写入，但是如果此次合并写并没有写入完成写入，则会使其抢锁成功，并自身去进行写入，这块逻辑便是之前的writeMergeC和writeLockC逻辑。\n```\nfunc (db *DB) unlockWrite(overflow bool, merged int, err error) {\n\tfor i := 0; i < merged; i++ {\n\t\tdb.writeAckC <- err\n\t}\n\tif overflow {\n\t\t// Pass lock to the next write (that failed to merge).\n\t\tdb.writeMergedC <- false\n\t} else {\n\t\t// Release lock.\n\t\t<-db.writeLockC\n\t}\n}\n```\n\n","slug":"level-db-write","published":1,"date":"2021-08-13T17:27:47.499Z","updated":"2021-08-13T17:27:47.499Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckti9vicu000b9gtjgnxn346t","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>打开流程完成了整个db的初始化，而后就是整个level对比的存储流程，如何读写db是核心业务。当然读写自然会触发压缩流程，但本文单纯只会串联整个的读写过程，保证内容的简洁，至于压缩则另开一篇详解。</p>\n<h2 id=\"写流程\"><a href=\"#写流程\" class=\"headerlink\" title=\"写流程\"></a>写流程</h2><h3 id=\"命令封装\"><a href=\"#命令封装\" class=\"headerlink\" title=\"命令封装\"></a>命令封装</h3><p>之前文章中，我们有提过更新的2个操作，在最后底层其实是一个操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (db *DB) Put(key, value []byte, wo *opt.WriteOptions) error &#123;</span><br><span class=\"line\">\treturn db.putRec(keyTypeVal, key, value, wo)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (db *DB) Delete(key []byte, wo *opt.WriteOptions) error &#123;</span><br><span class=\"line\">\treturn db.putRec(keyTypeDel, key, nil, wo)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看出，在<code>Put</code>和<code>Delete</code>命令中，最终会直接调用<code>putRec</code>方法，而在此方法中，做的核心逻辑就是，抢锁，并等待信息，其中抢锁的逻辑还是由<code>channel</code>实现，逻辑后续再理，先了解一下写入流程<code>writeLocked</code>方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">batch :&#x3D; db.batchPool.Get().(*Batch)</span><br><span class=\"line\">batch.Reset()</span><br><span class=\"line\">batch.appendRec(kt, key, value)</span><br><span class=\"line\">return db.writeLocked(batch, batch, merge, sync)</span><br></pre></td></tr></table></figure>\n<p>调用该方法后，则就是AOF写入以及落入<code>memdb</code>跳表数据库中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; Seq number.</span><br><span class=\"line\">seq :&#x3D; db.seq + 1</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Write journal.</span><br><span class=\"line\">if err :&#x3D; db.writeJournal(batches, seq, sync); err !&#x3D; nil &#123;</span><br><span class=\"line\">\tdb.unlockWrite(overflow, merged, err)</span><br><span class=\"line\">\treturn err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Put batches.</span><br><span class=\"line\">for _, batch :&#x3D; range batches &#123;</span><br><span class=\"line\">\tif err :&#x3D; batch.putMem(seq, mdb.DB); err !&#x3D; nil &#123;</span><br><span class=\"line\">\t\tpanic(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tseq +&#x3D; uint64(batch.Len())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>至此，数据已经落入存储中，并返回告知请求处理正常。那么，这一套流程，中间还存在哪些问题呢？<br>其中提高吞吐、提高内存空间利用率则是中间的优化点。</p>\n<h3 id=\"合并写\"><a href=\"#合并写\" class=\"headerlink\" title=\"合并写\"></a>合并写</h3><p>关于吞吐量的计算逻辑可以参考：<a href=\"https://zhuanlan.zhihu.com/p/337708438\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/337708438</a></p>\n<p>由于本身leveldb会写入内存，所以中间存在锁的抢占，而在golang中，leveldb使用的是channel进行锁争抢，当你能写入writeLockC管道时，便可以继续写入操作。然而，锁的争抢必定会导致性能下降，那么，合并写就成为了提供性能的一个解决方案。</p>\n<p>合并锁的逻辑就是，优先尝试写入writeMergeC管道中，如果写入成功，则等待合并写的结果返回</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">case db.writeMergeC &lt;- writeMerge&#123;sync: sync, keyType: kt, key: key, value: value&#125;:</span><br><span class=\"line\">    if &lt;-db.writeMergedC &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; Write is merged.</span><br><span class=\"line\">        return &lt;-db.writeAckC</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F; Write is not merged, the write lock is handed to us. Continue.</span><br><span class=\"line\">case db.writeLockC &lt;- struct&#123;&#125;&#123;&#125;:</span><br><span class=\"line\">    &#x2F;&#x2F; Write lock acquired.</span><br><span class=\"line\">case err :&#x3D; &lt;-db.compPerErrC:</span><br><span class=\"line\">    &#x2F;&#x2F; Compaction error.</span><br><span class=\"line\">    return err</span><br><span class=\"line\">case &lt;-db.closeC:</span><br><span class=\"line\">    &#x2F;&#x2F; Closed</span><br><span class=\"line\">    return ErrClosed</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而如果合并锁写入不成功，则尝试去抢写入锁，如果当前写入锁还是没有释放，那其中有可能导致异常出现（猜测）。<br>而在抢到写入锁的协程中，则会不断的等待合并写的请求达到上限</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">merge: </span><br><span class=\"line\"></span><br><span class=\"line\">for mergeLimit &gt; 0 &#123;</span><br><span class=\"line\">    select &#123;</span><br><span class=\"line\">    case incoming :&#x3D; &lt;-db.writeMergeC:</span><br><span class=\"line\">        ... ...</span><br><span class=\"line\">    default:</span><br><span class=\"line\">        break merge</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由此可见，当一次写入异常时，常常会阻塞所有的合并写异常，所有，合并写其实是针对大数据量的变更。</p>\n<p>当然，如果处理完成后，则会写入writeAckC管道告知等待的写入，但是如果此次合并写并没有写入完成写入，则会使其抢锁成功，并自身去进行写入，这块逻辑便是之前的writeMergeC和writeLockC逻辑。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (db *DB) unlockWrite(overflow bool, merged int, err error) &#123;</span><br><span class=\"line\">\tfor i :&#x3D; 0; i &lt; merged; i++ &#123;</span><br><span class=\"line\">\t\tdb.writeAckC &lt;- err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif overflow &#123;</span><br><span class=\"line\">\t\t&#x2F;&#x2F; Pass lock to the next write (that failed to merge).</span><br><span class=\"line\">\t\tdb.writeMergedC &lt;- false</span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t\t&#x2F;&#x2F; Release lock.</span><br><span class=\"line\">\t\t&lt;-db.writeLockC</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>打开流程完成了整个db的初始化，而后就是整个level对比的存储流程，如何读写db是核心业务。当然读写自然会触发压缩流程，但本文单纯只会串联整个的读写过程，保证内容的简洁，至于压缩则另开一篇详解。</p>\n<h2 id=\"写流程\"><a href=\"#写流程\" class=\"headerlink\" title=\"写流程\"></a>写流程</h2><h3 id=\"命令封装\"><a href=\"#命令封装\" class=\"headerlink\" title=\"命令封装\"></a>命令封装</h3><p>之前文章中，我们有提过更新的2个操作，在最后底层其实是一个操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (db *DB) Put(key, value []byte, wo *opt.WriteOptions) error &#123;</span><br><span class=\"line\">\treturn db.putRec(keyTypeVal, key, value, wo)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func (db *DB) Delete(key []byte, wo *opt.WriteOptions) error &#123;</span><br><span class=\"line\">\treturn db.putRec(keyTypeDel, key, nil, wo)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看出，在<code>Put</code>和<code>Delete</code>命令中，最终会直接调用<code>putRec</code>方法，而在此方法中，做的核心逻辑就是，抢锁，并等待信息，其中抢锁的逻辑还是由<code>channel</code>实现，逻辑后续再理，先了解一下写入流程<code>writeLocked</code>方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">batch :&#x3D; db.batchPool.Get().(*Batch)</span><br><span class=\"line\">batch.Reset()</span><br><span class=\"line\">batch.appendRec(kt, key, value)</span><br><span class=\"line\">return db.writeLocked(batch, batch, merge, sync)</span><br></pre></td></tr></table></figure>\n<p>调用该方法后，则就是AOF写入以及落入<code>memdb</code>跳表数据库中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; Seq number.</span><br><span class=\"line\">seq :&#x3D; db.seq + 1</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Write journal.</span><br><span class=\"line\">if err :&#x3D; db.writeJournal(batches, seq, sync); err !&#x3D; nil &#123;</span><br><span class=\"line\">\tdb.unlockWrite(overflow, merged, err)</span><br><span class=\"line\">\treturn err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Put batches.</span><br><span class=\"line\">for _, batch :&#x3D; range batches &#123;</span><br><span class=\"line\">\tif err :&#x3D; batch.putMem(seq, mdb.DB); err !&#x3D; nil &#123;</span><br><span class=\"line\">\t\tpanic(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tseq +&#x3D; uint64(batch.Len())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>至此，数据已经落入存储中，并返回告知请求处理正常。那么，这一套流程，中间还存在哪些问题呢？<br>其中提高吞吐、提高内存空间利用率则是中间的优化点。</p>\n<h3 id=\"合并写\"><a href=\"#合并写\" class=\"headerlink\" title=\"合并写\"></a>合并写</h3><p>关于吞吐量的计算逻辑可以参考：<a href=\"https://zhuanlan.zhihu.com/p/337708438\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/337708438</a></p>\n<p>由于本身leveldb会写入内存，所以中间存在锁的抢占，而在golang中，leveldb使用的是channel进行锁争抢，当你能写入writeLockC管道时，便可以继续写入操作。然而，锁的争抢必定会导致性能下降，那么，合并写就成为了提供性能的一个解决方案。</p>\n<p>合并锁的逻辑就是，优先尝试写入writeMergeC管道中，如果写入成功，则等待合并写的结果返回</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">case db.writeMergeC &lt;- writeMerge&#123;sync: sync, keyType: kt, key: key, value: value&#125;:</span><br><span class=\"line\">    if &lt;-db.writeMergedC &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; Write is merged.</span><br><span class=\"line\">        return &lt;-db.writeAckC</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F; Write is not merged, the write lock is handed to us. Continue.</span><br><span class=\"line\">case db.writeLockC &lt;- struct&#123;&#125;&#123;&#125;:</span><br><span class=\"line\">    &#x2F;&#x2F; Write lock acquired.</span><br><span class=\"line\">case err :&#x3D; &lt;-db.compPerErrC:</span><br><span class=\"line\">    &#x2F;&#x2F; Compaction error.</span><br><span class=\"line\">    return err</span><br><span class=\"line\">case &lt;-db.closeC:</span><br><span class=\"line\">    &#x2F;&#x2F; Closed</span><br><span class=\"line\">    return ErrClosed</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而如果合并锁写入不成功，则尝试去抢写入锁，如果当前写入锁还是没有释放，那其中有可能导致异常出现（猜测）。<br>而在抢到写入锁的协程中，则会不断的等待合并写的请求达到上限</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">merge: </span><br><span class=\"line\"></span><br><span class=\"line\">for mergeLimit &gt; 0 &#123;</span><br><span class=\"line\">    select &#123;</span><br><span class=\"line\">    case incoming :&#x3D; &lt;-db.writeMergeC:</span><br><span class=\"line\">        ... ...</span><br><span class=\"line\">    default:</span><br><span class=\"line\">        break merge</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由此可见，当一次写入异常时，常常会阻塞所有的合并写异常，所有，合并写其实是针对大数据量的变更。</p>\n<p>当然，如果处理完成后，则会写入writeAckC管道告知等待的写入，但是如果此次合并写并没有写入完成写入，则会使其抢锁成功，并自身去进行写入，这块逻辑便是之前的writeMergeC和writeLockC逻辑。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func (db *DB) unlockWrite(overflow bool, merged int, err error) &#123;</span><br><span class=\"line\">\tfor i :&#x3D; 0; i &lt; merged; i++ &#123;</span><br><span class=\"line\">\t\tdb.writeAckC &lt;- err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tif overflow &#123;</span><br><span class=\"line\">\t\t&#x2F;&#x2F; Pass lock to the next write (that failed to merge).</span><br><span class=\"line\">\t\tdb.writeMergedC &lt;- false</span><br><span class=\"line\">\t&#125; else &#123;</span><br><span class=\"line\">\t\t&#x2F;&#x2F; Release lock.</span><br><span class=\"line\">\t\t&lt;-db.writeLockC</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"浅析levelDB流程（打开流程）","_content":"\n## 前言\n核心是逐步学习leveldb的实现，而其中一步步从读写开始学习相关实现\n\n## 打开的方法\n从上文的demo，我们可以看出常见的打开方式是传入一个文件夹目录，方法是`OpenFile`，而针对各种常见，leveldb也提供了多种方法，例如可以自身传入一个存储方式的`Open(stor storage.Storage, o *opt.Options)`、直接从目录中恢复数据的`RecoverFile(path string, o *opt.Options)`等。而此次，我们核心从基础的OpenFile方法中入手，看看在打开leveldb时，是如何进行初始化操作。\n\n## 数据的获取\n```\nstor, err := storage.OpenFile(path, o.GetReadOnly())\n```\n最初引入眼帘的便是通过`storage.OpenFile`去持有一个存储对象。这其中可以使用内存作为存储，当然大部分情况还是使用文件存储。\n在打开文件后，需要开始检查路径是否存在、检查文件锁是否存在。\b检查完这2项后，还有就是确定当前是否只读，如果只读，则不需要新建Log文件，因为Log文件是用于支持AOF能力，否则则需要重建。\n当检查完成后，便会得到以下的结构体：\n```\n\tfs := &fileStorage{\n\t\tpath:     path,\n\t\treadOnly: readOnly,\n\t\tflock:    flock,\n\t\tlogw:     logw,\n\t\tlogSize:  logSize,\n\t}\n```\n结构体中核心包含路径、是否只读、是否锁，以及log文件相关数据\n当然，还有有趣的一行代码是：\n```\nruntime.SetFinalizer(fs, (*fileStorage).Close)\n```\n这行代码的目的和析构函数类似，当对象销毁时，进行善后处理。\n\n## 会话的构建\n当已经持有存储对象时，第一步就开始针对存储对象构建会话session信息。\n```\ns, err := newSession(stor, o)\n\ts = &session{\n\t\tstor:      newIStorage(stor),\n\t\tstorLock:  storLock,\n\t\trefCh:     make(chan *vTask),\n\t\trelCh:     make(chan *vTask),\n\t\tdeltaCh:   make(chan *vDelta),\n\t\tabandon:   make(chan int64),\n\t\tfileRefCh: make(chan chan map[int64]int),\n\t\tcloseC:    make(chan struct{}),\n\t}\n```\n会话中一个大的属性便是管道信息，可以见得session持有了多类管道，中间的能力简单来说就是，当leveldb中文件存在变更，都是通过session来进行异步操作。例如文件的删除和添加。而后会启动一个协程来辅助处理：\n```\ngo s.refLoop()\n```\n得到session对象后，则需要用version对象来管理各个版本的文件信息，这也是保证leveldb中并发安全的基础\n```\ns.setVersion(nil, newVersion(s))\n--- \n\nfunc newVersion(s *session) *version {\n\tid := atomic.AddInt64(&s.ntVersionId, 1)\n\tnv := &version{s: s, id: id - 1}\n\treturn nv\n}\n```\n当在初始化时，仅仅只是将version和session进行绑定。\n\n\n## 奔溃恢复\n初始化完基本信息，leveldb就进入了奔溃恢复流程，这也是所有存储不可避免的一个机制，包括mysql。而崩溃恢复也是针对session而已，最终核心也是恢复出上一次存储的version信息。\n```\nerr = s.recover()\n```\n首先第一步恢复就是恢复当前的存储基本信息，这也映射到了leveldb中的current文件中对应的Manifest文件\n```\n\tfd, err := s.stor.GetMeta()\n\tif err != nil {\n\t\treturn\n\t}\n\n\treader, err := s.stor.Open(fd)\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer reader.Close()\n```\n得到Current文件后，就会生成一个记事本journal对象，这个对象管理着Log文件内容，而Manifest文件本书也是Log文件格式存储，所以，直接复用即可。\n文件格式本文暂时不仔细描述，而从Manifest文件中，可以解析出，当前数据库使用的对比方法、压缩格式、各层级的文件信息，至此，我们就可以产生出一个新的version对象。\n\n## 数据库对象构建\nsession本身是管理此次底层version的变更，而再上一层则需要一个db层来管理对外接口以及内存和文件的事件管理。所以，这一层更多的是压缩、和写入的管理：\n```\ndb := &DB{\n\t\ts: s,\n\t\t// Initial sequence\n\t\tseq: s.stSeqNum,\n\t\t// MemDB\n\t\tmemPool: make(chan *memdb.DB, 1),\n\t\t// Snapshot\n\t\tsnapsList: list.New(),\n\t\t// Write\n\t\tbatchPool:    sync.Pool{New: newBatch},\n\t\twriteMergeC:  make(chan writeMerge),\n\t\twriteMergedC: make(chan bool),\n\t\twriteLockC:   make(chan struct{}, 1),\n\t\twriteAckC:    make(chan error),\n\t\t// Compaction\n\t\ttcompCmdC:   make(chan cCmd),\n\t\ttcompPauseC: make(chan chan<- struct{}),\n\t\tmcompCmdC:   make(chan cCmd),\n\t\tcompErrC:    make(chan error),\n\t\tcompPerErrC: make(chan error),\n\t\tcompErrSetC: make(chan error),\n\t\t// Close\n\t\tcloseC: make(chan struct{}),\n\t}\n```\n由结构体可见大部分是针对压缩和写入合并使用的管道对象。\n而生成完session后，仅仅只是吧以及落磁盘的level文件加载，而在崩溃前的内存数据还在丢失的，这些数据则需要从Log文件中恢复，这些则是在DB生成后恢复，当然恢复也是直接入memDB中，当做写入执行。中间必然也就触发了压缩和version的变更。\n\n当Log文件恢复后，最终就是启动各类的管道来执行相关的异步操作：\n```\n\tgo db.compactionError()\n\tgo db.mpoolDrain()\n\n\tif readOnly {\n\t\tdb.SetReadOnly()\n\t} else {\n\t\tdb.closeW.Add(2)\n\t\tgo db.tCompaction()\n\t\tgo db.mCompaction()\n\t\t// go db.jWriter()\n\t}\n```\n## 总结\n由此可见，leveldb中，使用了大量的异步逻辑来保证存储的高性能。同时也是利用了AOF原理来提高高可用性。","source":"_posts/level-db-start.md","raw":"---\ntitle: 浅析levelDB流程（打开流程）\n---\n\n## 前言\n核心是逐步学习leveldb的实现，而其中一步步从读写开始学习相关实现\n\n## 打开的方法\n从上文的demo，我们可以看出常见的打开方式是传入一个文件夹目录，方法是`OpenFile`，而针对各种常见，leveldb也提供了多种方法，例如可以自身传入一个存储方式的`Open(stor storage.Storage, o *opt.Options)`、直接从目录中恢复数据的`RecoverFile(path string, o *opt.Options)`等。而此次，我们核心从基础的OpenFile方法中入手，看看在打开leveldb时，是如何进行初始化操作。\n\n## 数据的获取\n```\nstor, err := storage.OpenFile(path, o.GetReadOnly())\n```\n最初引入眼帘的便是通过`storage.OpenFile`去持有一个存储对象。这其中可以使用内存作为存储，当然大部分情况还是使用文件存储。\n在打开文件后，需要开始检查路径是否存在、检查文件锁是否存在。\b检查完这2项后，还有就是确定当前是否只读，如果只读，则不需要新建Log文件，因为Log文件是用于支持AOF能力，否则则需要重建。\n当检查完成后，便会得到以下的结构体：\n```\n\tfs := &fileStorage{\n\t\tpath:     path,\n\t\treadOnly: readOnly,\n\t\tflock:    flock,\n\t\tlogw:     logw,\n\t\tlogSize:  logSize,\n\t}\n```\n结构体中核心包含路径、是否只读、是否锁，以及log文件相关数据\n当然，还有有趣的一行代码是：\n```\nruntime.SetFinalizer(fs, (*fileStorage).Close)\n```\n这行代码的目的和析构函数类似，当对象销毁时，进行善后处理。\n\n## 会话的构建\n当已经持有存储对象时，第一步就开始针对存储对象构建会话session信息。\n```\ns, err := newSession(stor, o)\n\ts = &session{\n\t\tstor:      newIStorage(stor),\n\t\tstorLock:  storLock,\n\t\trefCh:     make(chan *vTask),\n\t\trelCh:     make(chan *vTask),\n\t\tdeltaCh:   make(chan *vDelta),\n\t\tabandon:   make(chan int64),\n\t\tfileRefCh: make(chan chan map[int64]int),\n\t\tcloseC:    make(chan struct{}),\n\t}\n```\n会话中一个大的属性便是管道信息，可以见得session持有了多类管道，中间的能力简单来说就是，当leveldb中文件存在变更，都是通过session来进行异步操作。例如文件的删除和添加。而后会启动一个协程来辅助处理：\n```\ngo s.refLoop()\n```\n得到session对象后，则需要用version对象来管理各个版本的文件信息，这也是保证leveldb中并发安全的基础\n```\ns.setVersion(nil, newVersion(s))\n--- \n\nfunc newVersion(s *session) *version {\n\tid := atomic.AddInt64(&s.ntVersionId, 1)\n\tnv := &version{s: s, id: id - 1}\n\treturn nv\n}\n```\n当在初始化时，仅仅只是将version和session进行绑定。\n\n\n## 奔溃恢复\n初始化完基本信息，leveldb就进入了奔溃恢复流程，这也是所有存储不可避免的一个机制，包括mysql。而崩溃恢复也是针对session而已，最终核心也是恢复出上一次存储的version信息。\n```\nerr = s.recover()\n```\n首先第一步恢复就是恢复当前的存储基本信息，这也映射到了leveldb中的current文件中对应的Manifest文件\n```\n\tfd, err := s.stor.GetMeta()\n\tif err != nil {\n\t\treturn\n\t}\n\n\treader, err := s.stor.Open(fd)\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer reader.Close()\n```\n得到Current文件后，就会生成一个记事本journal对象，这个对象管理着Log文件内容，而Manifest文件本书也是Log文件格式存储，所以，直接复用即可。\n文件格式本文暂时不仔细描述，而从Manifest文件中，可以解析出，当前数据库使用的对比方法、压缩格式、各层级的文件信息，至此，我们就可以产生出一个新的version对象。\n\n## 数据库对象构建\nsession本身是管理此次底层version的变更，而再上一层则需要一个db层来管理对外接口以及内存和文件的事件管理。所以，这一层更多的是压缩、和写入的管理：\n```\ndb := &DB{\n\t\ts: s,\n\t\t// Initial sequence\n\t\tseq: s.stSeqNum,\n\t\t// MemDB\n\t\tmemPool: make(chan *memdb.DB, 1),\n\t\t// Snapshot\n\t\tsnapsList: list.New(),\n\t\t// Write\n\t\tbatchPool:    sync.Pool{New: newBatch},\n\t\twriteMergeC:  make(chan writeMerge),\n\t\twriteMergedC: make(chan bool),\n\t\twriteLockC:   make(chan struct{}, 1),\n\t\twriteAckC:    make(chan error),\n\t\t// Compaction\n\t\ttcompCmdC:   make(chan cCmd),\n\t\ttcompPauseC: make(chan chan<- struct{}),\n\t\tmcompCmdC:   make(chan cCmd),\n\t\tcompErrC:    make(chan error),\n\t\tcompPerErrC: make(chan error),\n\t\tcompErrSetC: make(chan error),\n\t\t// Close\n\t\tcloseC: make(chan struct{}),\n\t}\n```\n由结构体可见大部分是针对压缩和写入合并使用的管道对象。\n而生成完session后，仅仅只是吧以及落磁盘的level文件加载，而在崩溃前的内存数据还在丢失的，这些数据则需要从Log文件中恢复，这些则是在DB生成后恢复，当然恢复也是直接入memDB中，当做写入执行。中间必然也就触发了压缩和version的变更。\n\n当Log文件恢复后，最终就是启动各类的管道来执行相关的异步操作：\n```\n\tgo db.compactionError()\n\tgo db.mpoolDrain()\n\n\tif readOnly {\n\t\tdb.SetReadOnly()\n\t} else {\n\t\tdb.closeW.Add(2)\n\t\tgo db.tCompaction()\n\t\tgo db.mCompaction()\n\t\t// go db.jWriter()\n\t}\n```\n## 总结\n由此可见，leveldb中，使用了大量的异步逻辑来保证存储的高性能。同时也是利用了AOF原理来提高高可用性。","slug":"level-db-start","published":1,"date":"2021-08-13T17:27:47.499Z","updated":"2021-08-13T17:27:47.499Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckti9vicw000c9gtjhzwr7xjn","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>核心是逐步学习leveldb的实现，而其中一步步从读写开始学习相关实现</p>\n<h2 id=\"打开的方法\"><a href=\"#打开的方法\" class=\"headerlink\" title=\"打开的方法\"></a>打开的方法</h2><p>从上文的demo，我们可以看出常见的打开方式是传入一个文件夹目录，方法是<code>OpenFile</code>，而针对各种常见，leveldb也提供了多种方法，例如可以自身传入一个存储方式的<code>Open(stor storage.Storage, o *opt.Options)</code>、直接从目录中恢复数据的<code>RecoverFile(path string, o *opt.Options)</code>等。而此次，我们核心从基础的OpenFile方法中入手，看看在打开leveldb时，是如何进行初始化操作。</p>\n<h2 id=\"数据的获取\"><a href=\"#数据的获取\" class=\"headerlink\" title=\"数据的获取\"></a>数据的获取</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stor, err :&#x3D; storage.OpenFile(path, o.GetReadOnly())</span><br></pre></td></tr></table></figure>\n<p>最初引入眼帘的便是通过<code>storage.OpenFile</code>去持有一个存储对象。这其中可以使用内存作为存储，当然大部分情况还是使用文件存储。<br>在打开文件后，需要开始检查路径是否存在、检查文件锁是否存在。\b检查完这2项后，还有就是确定当前是否只读，如果只读，则不需要新建Log文件，因为Log文件是用于支持AOF能力，否则则需要重建。<br>当检查完成后，便会得到以下的结构体：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fs :&#x3D; &amp;fileStorage&#123;</span><br><span class=\"line\">\tpath:     path,</span><br><span class=\"line\">\treadOnly: readOnly,</span><br><span class=\"line\">\tflock:    flock,</span><br><span class=\"line\">\tlogw:     logw,</span><br><span class=\"line\">\tlogSize:  logSize,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结构体中核心包含路径、是否只读、是否锁，以及log文件相关数据<br>当然，还有有趣的一行代码是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">runtime.SetFinalizer(fs, (*fileStorage).Close)</span><br></pre></td></tr></table></figure>\n<p>这行代码的目的和析构函数类似，当对象销毁时，进行善后处理。</p>\n<h2 id=\"会话的构建\"><a href=\"#会话的构建\" class=\"headerlink\" title=\"会话的构建\"></a>会话的构建</h2><p>当已经持有存储对象时，第一步就开始针对存储对象构建会话session信息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s, err :&#x3D; newSession(stor, o)</span><br><span class=\"line\">\ts &#x3D; &amp;session&#123;</span><br><span class=\"line\">\t\tstor:      newIStorage(stor),</span><br><span class=\"line\">\t\tstorLock:  storLock,</span><br><span class=\"line\">\t\trefCh:     make(chan *vTask),</span><br><span class=\"line\">\t\trelCh:     make(chan *vTask),</span><br><span class=\"line\">\t\tdeltaCh:   make(chan *vDelta),</span><br><span class=\"line\">\t\tabandon:   make(chan int64),</span><br><span class=\"line\">\t\tfileRefCh: make(chan chan map[int64]int),</span><br><span class=\"line\">\t\tcloseC:    make(chan struct&#123;&#125;),</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<p>会话中一个大的属性便是管道信息，可以见得session持有了多类管道，中间的能力简单来说就是，当leveldb中文件存在变更，都是通过session来进行异步操作。例如文件的删除和添加。而后会启动一个协程来辅助处理：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go s.refLoop()</span><br></pre></td></tr></table></figure>\n<p>得到session对象后，则需要用version对象来管理各个版本的文件信息，这也是保证leveldb中并发安全的基础</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s.setVersion(nil, newVersion(s))</span><br><span class=\"line\">--- </span><br><span class=\"line\"></span><br><span class=\"line\">func newVersion(s *session) *version &#123;</span><br><span class=\"line\">\tid :&#x3D; atomic.AddInt64(&amp;s.ntVersionId, 1)</span><br><span class=\"line\">\tnv :&#x3D; &amp;version&#123;s: s, id: id - 1&#125;</span><br><span class=\"line\">\treturn nv</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当在初始化时，仅仅只是将version和session进行绑定。</p>\n<h2 id=\"奔溃恢复\"><a href=\"#奔溃恢复\" class=\"headerlink\" title=\"奔溃恢复\"></a>奔溃恢复</h2><p>初始化完基本信息，leveldb就进入了奔溃恢复流程，这也是所有存储不可避免的一个机制，包括mysql。而崩溃恢复也是针对session而已，最终核心也是恢复出上一次存储的version信息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">err &#x3D; s.recover()</span><br></pre></td></tr></table></figure>\n<p>首先第一步恢复就是恢复当前的存储基本信息，这也映射到了leveldb中的current文件中对应的Manifest文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fd, err :&#x3D; s.stor.GetMeta()</span><br><span class=\"line\">if err !&#x3D; nil &#123;</span><br><span class=\"line\">\treturn</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">reader, err :&#x3D; s.stor.Open(fd)</span><br><span class=\"line\">if err !&#x3D; nil &#123;</span><br><span class=\"line\">\treturn</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">defer reader.Close()</span><br></pre></td></tr></table></figure>\n<p>得到Current文件后，就会生成一个记事本journal对象，这个对象管理着Log文件内容，而Manifest文件本书也是Log文件格式存储，所以，直接复用即可。<br>文件格式本文暂时不仔细描述，而从Manifest文件中，可以解析出，当前数据库使用的对比方法、压缩格式、各层级的文件信息，至此，我们就可以产生出一个新的version对象。</p>\n<h2 id=\"数据库对象构建\"><a href=\"#数据库对象构建\" class=\"headerlink\" title=\"数据库对象构建\"></a>数据库对象构建</h2><p>session本身是管理此次底层version的变更，而再上一层则需要一个db层来管理对外接口以及内存和文件的事件管理。所以，这一层更多的是压缩、和写入的管理：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db :&#x3D; &amp;DB&#123;</span><br><span class=\"line\">\t\ts: s,</span><br><span class=\"line\">\t\t&#x2F;&#x2F; Initial sequence</span><br><span class=\"line\">\t\tseq: s.stSeqNum,</span><br><span class=\"line\">\t\t&#x2F;&#x2F; MemDB</span><br><span class=\"line\">\t\tmemPool: make(chan *memdb.DB, 1),</span><br><span class=\"line\">\t\t&#x2F;&#x2F; Snapshot</span><br><span class=\"line\">\t\tsnapsList: list.New(),</span><br><span class=\"line\">\t\t&#x2F;&#x2F; Write</span><br><span class=\"line\">\t\tbatchPool:    sync.Pool&#123;New: newBatch&#125;,</span><br><span class=\"line\">\t\twriteMergeC:  make(chan writeMerge),</span><br><span class=\"line\">\t\twriteMergedC: make(chan bool),</span><br><span class=\"line\">\t\twriteLockC:   make(chan struct&#123;&#125;, 1),</span><br><span class=\"line\">\t\twriteAckC:    make(chan error),</span><br><span class=\"line\">\t\t&#x2F;&#x2F; Compaction</span><br><span class=\"line\">\t\ttcompCmdC:   make(chan cCmd),</span><br><span class=\"line\">\t\ttcompPauseC: make(chan chan&lt;- struct&#123;&#125;),</span><br><span class=\"line\">\t\tmcompCmdC:   make(chan cCmd),</span><br><span class=\"line\">\t\tcompErrC:    make(chan error),</span><br><span class=\"line\">\t\tcompPerErrC: make(chan error),</span><br><span class=\"line\">\t\tcompErrSetC: make(chan error),</span><br><span class=\"line\">\t\t&#x2F;&#x2F; Close</span><br><span class=\"line\">\t\tcloseC: make(chan struct&#123;&#125;),</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<p>由结构体可见大部分是针对压缩和写入合并使用的管道对象。<br>而生成完session后，仅仅只是吧以及落磁盘的level文件加载，而在崩溃前的内存数据还在丢失的，这些数据则需要从Log文件中恢复，这些则是在DB生成后恢复，当然恢复也是直接入memDB中，当做写入执行。中间必然也就触发了压缩和version的变更。</p>\n<p>当Log文件恢复后，最终就是启动各类的管道来执行相关的异步操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go db.compactionError()</span><br><span class=\"line\">go db.mpoolDrain()</span><br><span class=\"line\"></span><br><span class=\"line\">if readOnly &#123;</span><br><span class=\"line\">\tdb.SetReadOnly()</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">\tdb.closeW.Add(2)</span><br><span class=\"line\">\tgo db.tCompaction()</span><br><span class=\"line\">\tgo db.mCompaction()</span><br><span class=\"line\">\t&#x2F;&#x2F; go db.jWriter()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>由此可见，leveldb中，使用了大量的异步逻辑来保证存储的高性能。同时也是利用了AOF原理来提高高可用性。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>核心是逐步学习leveldb的实现，而其中一步步从读写开始学习相关实现</p>\n<h2 id=\"打开的方法\"><a href=\"#打开的方法\" class=\"headerlink\" title=\"打开的方法\"></a>打开的方法</h2><p>从上文的demo，我们可以看出常见的打开方式是传入一个文件夹目录，方法是<code>OpenFile</code>，而针对各种常见，leveldb也提供了多种方法，例如可以自身传入一个存储方式的<code>Open(stor storage.Storage, o *opt.Options)</code>、直接从目录中恢复数据的<code>RecoverFile(path string, o *opt.Options)</code>等。而此次，我们核心从基础的OpenFile方法中入手，看看在打开leveldb时，是如何进行初始化操作。</p>\n<h2 id=\"数据的获取\"><a href=\"#数据的获取\" class=\"headerlink\" title=\"数据的获取\"></a>数据的获取</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">stor, err :&#x3D; storage.OpenFile(path, o.GetReadOnly())</span><br></pre></td></tr></table></figure>\n<p>最初引入眼帘的便是通过<code>storage.OpenFile</code>去持有一个存储对象。这其中可以使用内存作为存储，当然大部分情况还是使用文件存储。<br>在打开文件后，需要开始检查路径是否存在、检查文件锁是否存在。\b检查完这2项后，还有就是确定当前是否只读，如果只读，则不需要新建Log文件，因为Log文件是用于支持AOF能力，否则则需要重建。<br>当检查完成后，便会得到以下的结构体：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fs :&#x3D; &amp;fileStorage&#123;</span><br><span class=\"line\">\tpath:     path,</span><br><span class=\"line\">\treadOnly: readOnly,</span><br><span class=\"line\">\tflock:    flock,</span><br><span class=\"line\">\tlogw:     logw,</span><br><span class=\"line\">\tlogSize:  logSize,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结构体中核心包含路径、是否只读、是否锁，以及log文件相关数据<br>当然，还有有趣的一行代码是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">runtime.SetFinalizer(fs, (*fileStorage).Close)</span><br></pre></td></tr></table></figure>\n<p>这行代码的目的和析构函数类似，当对象销毁时，进行善后处理。</p>\n<h2 id=\"会话的构建\"><a href=\"#会话的构建\" class=\"headerlink\" title=\"会话的构建\"></a>会话的构建</h2><p>当已经持有存储对象时，第一步就开始针对存储对象构建会话session信息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s, err :&#x3D; newSession(stor, o)</span><br><span class=\"line\">\ts &#x3D; &amp;session&#123;</span><br><span class=\"line\">\t\tstor:      newIStorage(stor),</span><br><span class=\"line\">\t\tstorLock:  storLock,</span><br><span class=\"line\">\t\trefCh:     make(chan *vTask),</span><br><span class=\"line\">\t\trelCh:     make(chan *vTask),</span><br><span class=\"line\">\t\tdeltaCh:   make(chan *vDelta),</span><br><span class=\"line\">\t\tabandon:   make(chan int64),</span><br><span class=\"line\">\t\tfileRefCh: make(chan chan map[int64]int),</span><br><span class=\"line\">\t\tcloseC:    make(chan struct&#123;&#125;),</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<p>会话中一个大的属性便是管道信息，可以见得session持有了多类管道，中间的能力简单来说就是，当leveldb中文件存在变更，都是通过session来进行异步操作。例如文件的删除和添加。而后会启动一个协程来辅助处理：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go s.refLoop()</span><br></pre></td></tr></table></figure>\n<p>得到session对象后，则需要用version对象来管理各个版本的文件信息，这也是保证leveldb中并发安全的基础</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s.setVersion(nil, newVersion(s))</span><br><span class=\"line\">--- </span><br><span class=\"line\"></span><br><span class=\"line\">func newVersion(s *session) *version &#123;</span><br><span class=\"line\">\tid :&#x3D; atomic.AddInt64(&amp;s.ntVersionId, 1)</span><br><span class=\"line\">\tnv :&#x3D; &amp;version&#123;s: s, id: id - 1&#125;</span><br><span class=\"line\">\treturn nv</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当在初始化时，仅仅只是将version和session进行绑定。</p>\n<h2 id=\"奔溃恢复\"><a href=\"#奔溃恢复\" class=\"headerlink\" title=\"奔溃恢复\"></a>奔溃恢复</h2><p>初始化完基本信息，leveldb就进入了奔溃恢复流程，这也是所有存储不可避免的一个机制，包括mysql。而崩溃恢复也是针对session而已，最终核心也是恢复出上一次存储的version信息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">err &#x3D; s.recover()</span><br></pre></td></tr></table></figure>\n<p>首先第一步恢复就是恢复当前的存储基本信息，这也映射到了leveldb中的current文件中对应的Manifest文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fd, err :&#x3D; s.stor.GetMeta()</span><br><span class=\"line\">if err !&#x3D; nil &#123;</span><br><span class=\"line\">\treturn</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">reader, err :&#x3D; s.stor.Open(fd)</span><br><span class=\"line\">if err !&#x3D; nil &#123;</span><br><span class=\"line\">\treturn</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">defer reader.Close()</span><br></pre></td></tr></table></figure>\n<p>得到Current文件后，就会生成一个记事本journal对象，这个对象管理着Log文件内容，而Manifest文件本书也是Log文件格式存储，所以，直接复用即可。<br>文件格式本文暂时不仔细描述，而从Manifest文件中，可以解析出，当前数据库使用的对比方法、压缩格式、各层级的文件信息，至此，我们就可以产生出一个新的version对象。</p>\n<h2 id=\"数据库对象构建\"><a href=\"#数据库对象构建\" class=\"headerlink\" title=\"数据库对象构建\"></a>数据库对象构建</h2><p>session本身是管理此次底层version的变更，而再上一层则需要一个db层来管理对外接口以及内存和文件的事件管理。所以，这一层更多的是压缩、和写入的管理：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db :&#x3D; &amp;DB&#123;</span><br><span class=\"line\">\t\ts: s,</span><br><span class=\"line\">\t\t&#x2F;&#x2F; Initial sequence</span><br><span class=\"line\">\t\tseq: s.stSeqNum,</span><br><span class=\"line\">\t\t&#x2F;&#x2F; MemDB</span><br><span class=\"line\">\t\tmemPool: make(chan *memdb.DB, 1),</span><br><span class=\"line\">\t\t&#x2F;&#x2F; Snapshot</span><br><span class=\"line\">\t\tsnapsList: list.New(),</span><br><span class=\"line\">\t\t&#x2F;&#x2F; Write</span><br><span class=\"line\">\t\tbatchPool:    sync.Pool&#123;New: newBatch&#125;,</span><br><span class=\"line\">\t\twriteMergeC:  make(chan writeMerge),</span><br><span class=\"line\">\t\twriteMergedC: make(chan bool),</span><br><span class=\"line\">\t\twriteLockC:   make(chan struct&#123;&#125;, 1),</span><br><span class=\"line\">\t\twriteAckC:    make(chan error),</span><br><span class=\"line\">\t\t&#x2F;&#x2F; Compaction</span><br><span class=\"line\">\t\ttcompCmdC:   make(chan cCmd),</span><br><span class=\"line\">\t\ttcompPauseC: make(chan chan&lt;- struct&#123;&#125;),</span><br><span class=\"line\">\t\tmcompCmdC:   make(chan cCmd),</span><br><span class=\"line\">\t\tcompErrC:    make(chan error),</span><br><span class=\"line\">\t\tcompPerErrC: make(chan error),</span><br><span class=\"line\">\t\tcompErrSetC: make(chan error),</span><br><span class=\"line\">\t\t&#x2F;&#x2F; Close</span><br><span class=\"line\">\t\tcloseC: make(chan struct&#123;&#125;),</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<p>由结构体可见大部分是针对压缩和写入合并使用的管道对象。<br>而生成完session后，仅仅只是吧以及落磁盘的level文件加载，而在崩溃前的内存数据还在丢失的，这些数据则需要从Log文件中恢复，这些则是在DB生成后恢复，当然恢复也是直接入memDB中，当做写入执行。中间必然也就触发了压缩和version的变更。</p>\n<p>当Log文件恢复后，最终就是启动各类的管道来执行相关的异步操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go db.compactionError()</span><br><span class=\"line\">go db.mpoolDrain()</span><br><span class=\"line\"></span><br><span class=\"line\">if readOnly &#123;</span><br><span class=\"line\">\tdb.SetReadOnly()</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">\tdb.closeW.Add(2)</span><br><span class=\"line\">\tgo db.tCompaction()</span><br><span class=\"line\">\tgo db.mCompaction()</span><br><span class=\"line\">\t&#x2F;&#x2F; go db.jWriter()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>由此可见，leveldb中，使用了大量的异步逻辑来保证存储的高性能。同时也是利用了AOF原理来提高高可用性。</p>\n"},{"title":"总结RPC高可用实践之路","_content":"\nRPC的高可用存在几个方向：Load Balancing负载均衡、Rate Limiting限流、Load Shedding熔断、Graceful Degradation优雅退化、Latency and Deadlines延迟和死线\n\n### Load Balancing负载均衡 \n\n负载均衡核心目标其实主要是俩类：首先是减少负载、其次是提高可用性。\n\n减少负载首先是分摊流量、并做到均匀分发，而可用性则是减少错误数、更低的延迟、并支持弹性。\n\n而在这目标背后有很多障碍，对于每个请求的处理成本不同，第二是物理环境有差异，包括CPU性能差异以及邻居间互相影响。包括性能因素，中间例如JIT的预热、批量任务、大型GC导致性能出现问题。\n\n在解决这些背景的核心问题是活跃的请求数量不代表后端容量，CPU更好的处理的更多，而大集群最终退化成随机选择。而每个客户端的活跃请求不包括其他客户端发完一个后端的请求，导致容易缺少全局视角，且最闲的轮询容易引发惊群效应。\n\n### 方案\n\n用于解决负载均衡有各种各样的方案设计\n\nP2C方案，作为一个实现简单、负载均衡器的CPU成本低、请求分布好、O(1)的复杂度。**Power of Two Choices**方式是我们常见的做法。比如说现在有多个机房，因为线上的集群是多个，比如100个机器一个集群，我们正常把20个放到一个机房，一般要5个机房，就可以做到同城的多机房容灾。\n\n对于这种情况以前的做法是需要在配置里面加zone，弄清楚这个机器的节点属于哪个zone，做一些复杂的配置去管理这个请求该去哪儿访问，通过这种方式就能比较好的进行规避。\n\n比如说图里的A节点访问其它节点模拟了2ms的延迟，它可以比较好的把更多的请求放到本机房里，同时也确保本机房请求过多或延迟过高时会动态调度到其他的机房，这是一个动态的平衡。这里放了三个节点演示，通过数学的方式比较好的把多机房balance解决掉，而不需要用复杂的配置来完成这件事。\n\n基于client统计指标调度\n\n在client侧可以通过采集三类信息来进行均衡判断：Health、连接或特定的错误比率，Latency：请求的耗时，Inflight：当前正在运行的请求数量。通过三者来判断当前的server端是否正常已经进行相关的权重调节。\n\n同时还存在基于server统计指标进行调度，其中利用类似于Actively：利用healthcheck同步；Passively：每次rpc response同步，CPU：百ms内的Moving Average 这类指标供均衡判断。\n\n同时，为了保证数据的可用性，需要对相关计算分数进行衰减处理。\n\n### 影响\n\n负载均衡的策略执行后，很容易出现的影响是服务器之间的流量差异逐步放大，较慢的服务器接收的流量更少，从而容易导致abtest实验准确性，同时问题机器更难被监控发现\n\n## 相关链接\n\n[流量洪峰中如何设计弹性微服务架构 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/354401594)","source":"_posts/rpc-monitor.md","raw":"---\ntitle: 总结RPC高可用实践之路\n---\n\nRPC的高可用存在几个方向：Load Balancing负载均衡、Rate Limiting限流、Load Shedding熔断、Graceful Degradation优雅退化、Latency and Deadlines延迟和死线\n\n### Load Balancing负载均衡 \n\n负载均衡核心目标其实主要是俩类：首先是减少负载、其次是提高可用性。\n\n减少负载首先是分摊流量、并做到均匀分发，而可用性则是减少错误数、更低的延迟、并支持弹性。\n\n而在这目标背后有很多障碍，对于每个请求的处理成本不同，第二是物理环境有差异，包括CPU性能差异以及邻居间互相影响。包括性能因素，中间例如JIT的预热、批量任务、大型GC导致性能出现问题。\n\n在解决这些背景的核心问题是活跃的请求数量不代表后端容量，CPU更好的处理的更多，而大集群最终退化成随机选择。而每个客户端的活跃请求不包括其他客户端发完一个后端的请求，导致容易缺少全局视角，且最闲的轮询容易引发惊群效应。\n\n### 方案\n\n用于解决负载均衡有各种各样的方案设计\n\nP2C方案，作为一个实现简单、负载均衡器的CPU成本低、请求分布好、O(1)的复杂度。**Power of Two Choices**方式是我们常见的做法。比如说现在有多个机房，因为线上的集群是多个，比如100个机器一个集群，我们正常把20个放到一个机房，一般要5个机房，就可以做到同城的多机房容灾。\n\n对于这种情况以前的做法是需要在配置里面加zone，弄清楚这个机器的节点属于哪个zone，做一些复杂的配置去管理这个请求该去哪儿访问，通过这种方式就能比较好的进行规避。\n\n比如说图里的A节点访问其它节点模拟了2ms的延迟，它可以比较好的把更多的请求放到本机房里，同时也确保本机房请求过多或延迟过高时会动态调度到其他的机房，这是一个动态的平衡。这里放了三个节点演示，通过数学的方式比较好的把多机房balance解决掉，而不需要用复杂的配置来完成这件事。\n\n基于client统计指标调度\n\n在client侧可以通过采集三类信息来进行均衡判断：Health、连接或特定的错误比率，Latency：请求的耗时，Inflight：当前正在运行的请求数量。通过三者来判断当前的server端是否正常已经进行相关的权重调节。\n\n同时还存在基于server统计指标进行调度，其中利用类似于Actively：利用healthcheck同步；Passively：每次rpc response同步，CPU：百ms内的Moving Average 这类指标供均衡判断。\n\n同时，为了保证数据的可用性，需要对相关计算分数进行衰减处理。\n\n### 影响\n\n负载均衡的策略执行后，很容易出现的影响是服务器之间的流量差异逐步放大，较慢的服务器接收的流量更少，从而容易导致abtest实验准确性，同时问题机器更难被监控发现\n\n## 相关链接\n\n[流量洪峰中如何设计弹性微服务架构 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/354401594)","slug":"rpc-monitor","published":1,"date":"2021-08-13T17:27:47.499Z","updated":"2021-08-13T17:27:47.499Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckti9vicx000d9gtj8tjygxjn","content":"<p>RPC的高可用存在几个方向：Load Balancing负载均衡、Rate Limiting限流、Load Shedding熔断、Graceful Degradation优雅退化、Latency and Deadlines延迟和死线</p>\n<h3 id=\"Load-Balancing负载均衡\"><a href=\"#Load-Balancing负载均衡\" class=\"headerlink\" title=\"Load Balancing负载均衡\"></a>Load Balancing负载均衡</h3><p>负载均衡核心目标其实主要是俩类：首先是减少负载、其次是提高可用性。</p>\n<p>减少负载首先是分摊流量、并做到均匀分发，而可用性则是减少错误数、更低的延迟、并支持弹性。</p>\n<p>而在这目标背后有很多障碍，对于每个请求的处理成本不同，第二是物理环境有差异，包括CPU性能差异以及邻居间互相影响。包括性能因素，中间例如JIT的预热、批量任务、大型GC导致性能出现问题。</p>\n<p>在解决这些背景的核心问题是活跃的请求数量不代表后端容量，CPU更好的处理的更多，而大集群最终退化成随机选择。而每个客户端的活跃请求不包括其他客户端发完一个后端的请求，导致容易缺少全局视角，且最闲的轮询容易引发惊群效应。</p>\n<h3 id=\"方案\"><a href=\"#方案\" class=\"headerlink\" title=\"方案\"></a>方案</h3><p>用于解决负载均衡有各种各样的方案设计</p>\n<p>P2C方案，作为一个实现简单、负载均衡器的CPU成本低、请求分布好、O(1)的复杂度。<strong>Power of Two Choices</strong>方式是我们常见的做法。比如说现在有多个机房，因为线上的集群是多个，比如100个机器一个集群，我们正常把20个放到一个机房，一般要5个机房，就可以做到同城的多机房容灾。</p>\n<p>对于这种情况以前的做法是需要在配置里面加zone，弄清楚这个机器的节点属于哪个zone，做一些复杂的配置去管理这个请求该去哪儿访问，通过这种方式就能比较好的进行规避。</p>\n<p>比如说图里的A节点访问其它节点模拟了2ms的延迟，它可以比较好的把更多的请求放到本机房里，同时也确保本机房请求过多或延迟过高时会动态调度到其他的机房，这是一个动态的平衡。这里放了三个节点演示，通过数学的方式比较好的把多机房balance解决掉，而不需要用复杂的配置来完成这件事。</p>\n<p>基于client统计指标调度</p>\n<p>在client侧可以通过采集三类信息来进行均衡判断：Health、连接或特定的错误比率，Latency：请求的耗时，Inflight：当前正在运行的请求数量。通过三者来判断当前的server端是否正常已经进行相关的权重调节。</p>\n<p>同时还存在基于server统计指标进行调度，其中利用类似于Actively：利用healthcheck同步；Passively：每次rpc response同步，CPU：百ms内的Moving Average 这类指标供均衡判断。</p>\n<p>同时，为了保证数据的可用性，需要对相关计算分数进行衰减处理。</p>\n<h3 id=\"影响\"><a href=\"#影响\" class=\"headerlink\" title=\"影响\"></a>影响</h3><p>负载均衡的策略执行后，很容易出现的影响是服务器之间的流量差异逐步放大，较慢的服务器接收的流量更少，从而容易导致abtest实验准确性，同时问题机器更难被监控发现</p>\n<h2 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h2><p><a href=\"https://zhuanlan.zhihu.com/p/354401594\" target=\"_blank\" rel=\"noopener\">流量洪峰中如何设计弹性微服务架构 - 知乎 (zhihu.com)</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>RPC的高可用存在几个方向：Load Balancing负载均衡、Rate Limiting限流、Load Shedding熔断、Graceful Degradation优雅退化、Latency and Deadlines延迟和死线</p>\n<h3 id=\"Load-Balancing负载均衡\"><a href=\"#Load-Balancing负载均衡\" class=\"headerlink\" title=\"Load Balancing负载均衡\"></a>Load Balancing负载均衡</h3><p>负载均衡核心目标其实主要是俩类：首先是减少负载、其次是提高可用性。</p>\n<p>减少负载首先是分摊流量、并做到均匀分发，而可用性则是减少错误数、更低的延迟、并支持弹性。</p>\n<p>而在这目标背后有很多障碍，对于每个请求的处理成本不同，第二是物理环境有差异，包括CPU性能差异以及邻居间互相影响。包括性能因素，中间例如JIT的预热、批量任务、大型GC导致性能出现问题。</p>\n<p>在解决这些背景的核心问题是活跃的请求数量不代表后端容量，CPU更好的处理的更多，而大集群最终退化成随机选择。而每个客户端的活跃请求不包括其他客户端发完一个后端的请求，导致容易缺少全局视角，且最闲的轮询容易引发惊群效应。</p>\n<h3 id=\"方案\"><a href=\"#方案\" class=\"headerlink\" title=\"方案\"></a>方案</h3><p>用于解决负载均衡有各种各样的方案设计</p>\n<p>P2C方案，作为一个实现简单、负载均衡器的CPU成本低、请求分布好、O(1)的复杂度。<strong>Power of Two Choices</strong>方式是我们常见的做法。比如说现在有多个机房，因为线上的集群是多个，比如100个机器一个集群，我们正常把20个放到一个机房，一般要5个机房，就可以做到同城的多机房容灾。</p>\n<p>对于这种情况以前的做法是需要在配置里面加zone，弄清楚这个机器的节点属于哪个zone，做一些复杂的配置去管理这个请求该去哪儿访问，通过这种方式就能比较好的进行规避。</p>\n<p>比如说图里的A节点访问其它节点模拟了2ms的延迟，它可以比较好的把更多的请求放到本机房里，同时也确保本机房请求过多或延迟过高时会动态调度到其他的机房，这是一个动态的平衡。这里放了三个节点演示，通过数学的方式比较好的把多机房balance解决掉，而不需要用复杂的配置来完成这件事。</p>\n<p>基于client统计指标调度</p>\n<p>在client侧可以通过采集三类信息来进行均衡判断：Health、连接或特定的错误比率，Latency：请求的耗时，Inflight：当前正在运行的请求数量。通过三者来判断当前的server端是否正常已经进行相关的权重调节。</p>\n<p>同时还存在基于server统计指标进行调度，其中利用类似于Actively：利用healthcheck同步；Passively：每次rpc response同步，CPU：百ms内的Moving Average 这类指标供均衡判断。</p>\n<p>同时，为了保证数据的可用性，需要对相关计算分数进行衰减处理。</p>\n<h3 id=\"影响\"><a href=\"#影响\" class=\"headerlink\" title=\"影响\"></a>影响</h3><p>负载均衡的策略执行后，很容易出现的影响是服务器之间的流量差异逐步放大，较慢的服务器接收的流量更少，从而容易导致abtest实验准确性，同时问题机器更难被监控发现</p>\n<h2 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h2><p><a href=\"https://zhuanlan.zhihu.com/p/354401594\" target=\"_blank\" rel=\"noopener\">流量洪峰中如何设计弹性微服务架构 - 知乎 (zhihu.com)</a></p>\n"}],"PostAsset":[{"_id":"source/_posts/golang-gmp/1767848-9c4b06362907280d.webp","post":"ckti9vicq00059gtj0vjf9lt8","slug":"1767848-9c4b06362907280d.webp","modified":1,"renderable":1},{"_id":"source/_posts/golang-gmp/3184f3.jpg","post":"ckti9vicq00059gtj0vjf9lt8","slug":"3184f3.jpg","modified":1,"renderable":1},{"_id":"source/_posts/golang-gmp/567399-d400f4b192f3dc48.webp","post":"ckti9vicq00059gtj0vjf9lt8","slug":"567399-d400f4b192f3dc48.webp","modified":1,"renderable":1}],"PostCategory":[],"PostTag":[],"Tag":[]}}