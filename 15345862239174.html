<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  Redis 主流程学习 - artikell
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="artikell" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:artikell.github.io ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="_self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        <li id=""><a target="_blank" href="https://github.com/zhangyachen/zhangyachen.github.io/issues">Zyc的博客</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="http://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; artikell</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="_self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        
        <li><a target="_blank" href="https://github.com/zhangyachen/zhangyachen.github.io/issues">Zyc的博客</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Optimize.html">Optimize</a></li>
        
            <li><a href="Redis.html">Redis</a></li>
        
            <li><a href="Docker.html">Docker</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
  $(function(){
    $('#menu_item_index').addClass('is_active');
  });
</script>
<div class="row">
  <div class="large-8 medium-8 columns">
      <div class="markdown-body article-wrap">
       <div class="article">
          
          <h1>Redis 主流程学习</h1>
     
        <div class="read-more clearfix">
          <span class="date">2018/8/18</span>

          <span>posted in&nbsp;</span> 
          
              <span class="posted-in"><a href='Redis.html'>Redis</a></span>
           
         
          <span class="comments">
            

            
          </span>

        </div>
      </div><!-- article -->

      <div class="article-content">
      <h2 id="toc_0">前言</h2>

<p>本文主要介绍Redis主流程的过程，包括<em>启动初始化，事件，命令处理，异常处理</em>4大块，尽可能覆盖全面。</p>

<h2 id="toc_1">启动初始化</h2>

<p>启动初始化一般都有3个流程：<em>环境设置、配置解析、模块初始化</em>。三者主要是为了后续持续的运行做准备。</p>

<h3 id="toc_2">环境设置</h3>

<p>环境设置大部分都是一些与系统相关的设置，例如不同的系统会使用不同的事件模型</p>

<table>
<thead>
<tr>
<th>事件模型</th>
<th>系统</th>
</tr>
</thead>

<tbody>
<tr>
<td>Evport</td>
<td>sun系统</td>
</tr>
<tr>
<td>Epoll</td>
<td>linux系统</td>
</tr>
<tr>
<td>Kqueue</td>
<td>unix系统</td>
</tr>
<tr>
<td>Select</td>
<td>兜底</td>
</tr>
</tbody>
</table>

<p>对于四种模型，select是最简单的，也是性能较差的一个，所以是用于兜底方案，而关于epoll和kqueue都是主动触发的事件模型。2者其实是用于解决C10K问题而从select中衍生出来的模型，同时是分别针对linux系统和Unix系统设计。</p>

<pre><code>#ifdef HAVE_EVPORT
#include &quot;ae_evport.c&quot;
#else
    #ifdef HAVE_EPOLL
    #include &quot;ae_epoll.c&quot;
    #else
        #ifdef HAVE_KQUEUE
        #include &quot;ae_kqueue.c&quot;
        #else
        #include &quot;ae_select.c&quot;
        #endif
    #endif
#endif
</code></pre>

<p>同时还有类似内存池的选择，是zmalloc,还是jmalloc，都是在编译时候设置好。</p>

<p>在启动的时候，能做的事情不多，主要就是：语言环境、标题、随机种子、监督。</p>

<h3 id="toc_3">配置解析</h3>

<p>配置主要都是从命令行参数列表中获取，而针对一下特殊的参数例如<em>version、help、test-memory</em>就有特殊处理。</p>

<pre><code>if (strcmp(argv[1], &quot;-v&quot;) == 0 ||
    strcmp(argv[1], &quot;--version&quot;) == 0) version();
if (strcmp(argv[1], &quot;--help&quot;) == 0 ||
    strcmp(argv[1], &quot;-h&quot;) == 0) usage();
if (strcmp(argv[1], &quot;--test-memory&quot;) == 0) {
    if (argc == 3) {
        memtest(atoi(argv[2]),50);
        exit(0);
    } else {
        fprintf(stderr,&quot;Please specify the amount of memory to test in megabytes.\n&quot;);
        fprintf(stderr,&quot;Example: ./redis-server --test-memory 4096\n\n&quot;);
        exit(1);
    }
}
</code></pre>

<p>配置检查第一个参数，如果不是以双减号开头，则作为配置文件，同时会补全configfile为绝对路径，这样的话，后续debug模式下重启服务可以正常启动。</p>

<pre><code>if (argv[j][0] != &#39;-&#39; || argv[j][1] != &#39;-&#39;) {
    configfile = argv[j];
    server.configfile = getAbsolutePath(configfile);
    /* Replace the config file in server.exec_argv with
     * its absoulte path. */
    zfree(server.exec_argv[j]);
    server.exec_argv[j] = zstrdup(server.configfile);
    j++;
}
</code></pre>

<p>后续的配置设置，都是以<code>--</code>开头，例如：<code>--port 6379</code>，都作为配置信息。<br/>
例如： <code>redis-server --port 6379 --save 900 1 --save 300 1</code> ，会被解析为：</p>

<pre><code>port 6379
save 900 1
save 300 1
</code></pre>

<p>这样的好处就是可以和配置文件复用同一套的解析方法。</p>

<p>其中有个有趣的模式是支持从输入流中获取配置信息，开启方法则是在配置文件的时候输入一个减号，例如：<code>redis-server -</code>，后续通过<code>ctrl+c</code>退出模式。当然，格式将和配置文件是相同。</p>

<p>后续的配置解析是将整个配置信息通过<code>\n\t\r</code>，进行分隔成多行，并针对每一行的第一个元素小写，找到相应的变量设置。若设置错误，则直接会报错并退出进程。</p>

<h3 id="toc_4">模块初始化</h3>

<p>初始化流程中，大部分模块都进行了初始化处理，例如：bio，lua，模块module，cluster，信号，慢日志等。</p>

<p>初始化的时候，主要功能都是在做对象内存的申请，端口的监听。其中当然包括多个数据库的申请，以及持久化数据的导入。</p>

<h2 id="toc_5">事件</h2>

<p>Redis事件分为2类：<em>时间事件和文件事件</em>，事件可以和Nginx的事件模型对齐，文件事件和定时事件交替执行。而和Nginx不一样的是，Redis对时间要求比Nginx严格，所以Redis会搜索最近的一个时间事件，并计算文件事件获取的超时时间。</p>

<h3 id="toc_6">时间事件</h3>

<p>在Redis中，时间事件记录就是通过链条来记录：</p>

<pre><code>typedef struct aeTimeEvent {
    long long id; /* time event identifier. */
    long when_sec; /* seconds */
    long when_ms; /* milliseconds */
    aeTimeProc *timeProc;
    aeEventFinalizerProc *finalizerProc;
    void *clientData;
    struct aeTimeEvent *next;
} aeTimeEvent;
</code></pre>

<p>所以，每次找最近的时间事件，都是直接遍历来获取。<br/>
从整个的Redis源码中，只有一个地方使用到了时间事件，那就是ServerCron方法，</p>

<pre><code>aeCreateTimeEvent(server.el, 1, serverCron, NULL, NULL)
</code></pre>

<p>这个方法主要用于维护Redis服务器的日常，可以看见的是，该方法是1ms执行一次，所以，所有的文件事件间隔不会大于1ms，这也是为啥Redis高效的原因。</p>

<h4 id="toc_7">ServerCron 函数</h4>

<p>作为主要的定时函数，ServerCron函数功能主要用于维护整个Redis的稳定。常见的操作有：数据库的重哈希、数据持久化、内存清理、删除超时客户端等。</p>

<p>与此同时，ServerCron函数也会调用其他的定时函数，例如：ClientCron、DatabaseCron函数，这些原本都是在ServerCron函数中，后来为了便于维护，所以，移出去了。</p>

<p>与ServerCron函数有关系的配置就是hz配置，官方解释是：<code>Time interrupt calls/sec</code>，默认是10，也就是说，默认是每100ms执行一次。</p>

<p><em>那如果对于有些定时任务需要1s执行一次，怎么实现？</em>有2种办法，一是新建一个定时任务来做这个操作，二是在ServerCron中来做调用这个函数。</p>

<p>而在类似ClientCron函数，Redis就采用的是第二种方法，其中会设置cronloops方法来记录当前是第几次循环，并判断是否需要调用：</p>

<pre><code>#define run_with_period(_ms_) if ((_ms_ &lt;= 1000/server.hz) || !(server.cronloops%((_ms_)/(1000/server.hz))))
</code></pre>

<p>这个宏类似于条件判断，每ms时间执行一次后续的操作。如:</p>

<pre><code>run_with_period(100) trackOperationsPerSecond();
</code></pre>

<p>每百微秒，执行一次跟踪操作函数，记录这段时间的命令执行情况</p>

<h3 id="toc_8">文件事件</h3>

<p>对于文件事件，是整个Redis异步处理的关键，在各个模块，例如AOF，集群，脚本等模块都需要文件事件来支撑。不过和时间事件不同，文件事件是根据不同的模型实现的，其中包含：select\epoll\evport\kqueue四种模型，每个模型都抽象出了7个方法：<br/>
1. aeApiCreate - 创建事件对象，类似初始化<br/>
2. aeApiResize - 重置事件对象<br/>
3. aeApiFree - 删除事件对象<br/>
4. aeApiAddEvent - 添加事件<br/>
5. aeApiDelEvent - 删除事件<br/>
6. aeApiPoll - 获取事件列表<br/>
7. aeApiName - 获取事件名称</p>

<!-- 而四个文件模型各自的优缺点如下： -->

<p>在端口监听的时候，使用到了文件模型来处理socket信息：</p>

<pre><code>(aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE, acceptTcpHandler,NULL)
</code></pre>

<h3 id="toc_9">循环前置</h3>

<p>对于一些需要频繁的操作，需要有一个地方来执行，如果使用时间模型来做的话，那容易导致间隔过长，于是在Redis的事件模型中，存在beforeSleep函数，在每次执行事件的时候，会先调用该函数，主要功能一般都是用于清理无用数据以及持久化数据落盘等简单动作。</p>

<h2 id="toc_10">命令处理</h2>

<p>命令处理可以划分3个部分：<em>连接建立、请求处理、返回数据</em>。</p>

<h3 id="toc_11">接收请求</h3>

<p>连接的建立在文件事件里面已经有提过，就是通过将socke绑定在文件事件中执行。</p>

<p>在建立连接的时候，redis都会循环1000次，尽可能多的接收请求。</p>

<p>获得了socket后，redis会创建客户端对象，其中需要检查2个事情：是否超过最大连接数、是否是无密码远程登录。对应配置为：<code>maxclients</code>和<code>protected-mode</code>。</p>

<p>后续再建立client的时候，会将socket设置为noblock和TcpNoDelay模式，加快数据的传输，同时还会设置keepalive模式。</p>

<p>请求处理的时候，在接收请求，redis进行了协议的处理，redis每次会申请16k的大小来获取数据，同时根据是否知道长度来调整缓存区<br/>
同时，redis后续会根据，是否成功，或缓存数据是否过多来中的客户端请求<br/>
之后，会根据是否为master来做一些广播的处理</p>

<h3 id="toc_12">请求处理</h3>

<p>当获取到请求的时候，redis会解析请求的第一个参数，找到相应的命令对象</p>

<pre><code>struct redisCommand redisCommandTable[] = {
    {&quot;module&quot;,moduleCommand,-2,&quot;as&quot;,0,NULL,1,1,1,0,0},
    {&quot;get&quot;,getCommand,2,&quot;rF&quot;,0,NULL,1,1,1,0,0},
    {&quot;set&quot;,setCommand,-3,&quot;wm&quot;,0,NULL,1,1,1,0,0},
</code></pre>

<p>以get命令来看，命令列表其实是通过一个枚举的过程来做的，到最后会变成一个字典，所以查询的效率很高。</p>

<p>在执行的过程中，命令需要做一系列的检查，包括各种情况：</p>

<ol>
<li>命令不存在</li>
<li>命令不合法</li>
<li>需要登录，却不是auth命令</li>
<li>若命令对内存严格要求，且服务器无内存</li>
<li>如果磁盘上存在问题，请不要接受写命令</li>
<li>如果不满足最低正常从服务器要求，不接受写操作</li>
<li>如果只是一个只读的从服务器，不接受写操作</li>
<li>在订阅模式下，只允许一部分命令</li>
<li>当连接断开时，是否接受请求</li>
<li>若正在加载，接受一部分请求</li>
<li>如果lua命令太慢，则只允许一部分请求</li>
<li>如果是事务命令，则加入事务列表</li>
<li>否则就执行</li>
</ol>

<h4 id="toc_13">事务操作</h4>

<p>对于事务类操作，有 MULTI、DISCARD、EXEC和WATCH四个命令。而参考mysql中的事务，有begin、rollback、commit三个命令。多了一个命令，而其实原理上已经完全不一样。<br/>
对于事务的实现，数据结构如下：</p>

<pre><code>typedef struct multiCmd {
    robj **argv;
    int argc;
    struct redisCommand *cmd;
} multiCmd;

typedef struct multiState {
    multiCmd *commands;     /* 事务命令数组 */
    int count;              /* 命令个数 */
    int minreplicas;        /* MINREPLICAS for synchronous replication */
    time_t minreplicas_timeout; /* MINREPLICAS timeout as unixtime. */
} multiState;
</code></pre>

<p>其中，主要是commands属性用于存储事务的命令列表，以及一些参数。</p>

<p>首先，watch命令是一个有趣的命令，它会监听一些数据是否变化，首先，对于每个数据库和每个客户端对象，都会有一个<code>watched_keys</code>属性：对于客户端对象而言，<code>watched_keys</code>是一个list列表，主要用于记录当前监听的键，而对于数据库对象而言，<code>watched_keys</code>则是一个以<code>watch</code>的变量名键的字典，用于记录当前键被监听的客户端列表。</p>

<p>如果每次数据库中有变化，其中包括列表排序、过期清空等操作，都会将相关的客户端状态置为<code>CLIENT_DIRTY_CAS</code>状态</p>

<p>MULTI命令和DISCARD命令则相对比较简单，前者只需要将客户端属性设置为事务态，而后者则相反，移除客户端的事务态标记，同时清空命令数组等。</p>

<p>而对于EXEC命令，则是极其复杂的，因为它需要检查异常情况，同时运行命令：</p>

<ol>
<li>检查客户端是否在事务态</li>
<li>检查命令是否正常以及键是否被改变</li>
<li>取消所有监听的键</li>
<li>广播事务命令</li>
<li>循环执行所有命令，并返回</li>
</ol>

<p>回顾一下事务的4个条件（ACID）：原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。</p>

<p>Redis对于原子性是没有特别严格的保证，正常运行时，操作失败的时候，可能是语法错误或者错误的数据库类型操作，这种操作一般都可以避免。<br/>
由于Redis单线程来保证，由于命令只能串行运行，所以，隔离性和一致性，Redis完全没问题。<br/>
而关于持久性，Redis通过AOF和快照2中模式来实现，不过，并不是完全能持久化。</p>

<p>所以，对于Redis事务而言，实现了隔离性和一致性，但无法保证原子性和持久性</p>

<blockquote>
<p>待补充，事务中的异常处理以及广播</p>
</blockquote>

<h4 id="toc_14">阻塞操作</h4>

<p>阻塞命令在Redis中，其中是比较关键的一系列命令，很多工具都是通过它来实现，例如消息队列等。而核心命令则是：blpop和brpop。</p>

<p>关于阻塞，本身和事务的watch命令类似，在数据库对象中都存在一个<code>blocking_keys</code>字典，它的键为相关的键名，值则是客户端对象列表。</p>

<p>而在客户端对象这边是存在一个bpop属性，结构体如下：</p>

<pre><code>typedef struct blockingState {
    /* Generic fields. */
    mstime_t timeout;       /* Blocking operation timeout. If UNIX current time
                             * is &gt; timeout then the operation timed out. */

    /* BLOCKED_LIST */
    dict *keys;             /* The keys we are waiting to terminate a blocking
                             * operation such as BLPOP. Otherwise NULL. */
    robj *target;           /* The key that should receive the element,
                             * for BRPOPLPUSH. */

    /* BLOCKED_WAIT */
    int numreplicas;        /* Number of replicas we are waiting for ACK. */
    long long reploffset;   /* Replication offset to reach. */

    /* BLOCKED_MODULE */
    void *module_blocked_handle; /* RedisModuleBlockedClient structure.
                                    which is opaque for the Redis core, only
                                    handled in module.c. */
} blockingState;
</code></pre>

<p>其中需要关注的主要是keys、timeout、target三个属性，其中keys主要用于记录阻塞的列表名称，timeout则用于表示阻塞超时时间，target则用于特殊命令<code>BRPOPLPUSH</code>来标记转移的列表对象。</p>

<p>对于已阻塞的客户端而言，其实只有在增加键的时候才会结束阻塞，所以，每个新增列表的时候，都会将列表名加入<code>ready_keys</code>列表中，但命令执行的时候，会检查该列表是否为空，若不为空，则代表有新的列表变动，所以需要修改阻塞状态。</p>

<h4 id="toc_15">订阅操作</h4>

<p>对于订阅功能，其实包含的命令只有 PUBLISH、SUBSCRIBE 2个命令。一个用于订阅管道，一个用于推送消息。其中的中间键叫channel。这与阻塞操作不同的在于，订阅发布是一个1对n的模型，而pop操作是一个1对1的模型。这其中的难度就在于发布给多个客户端以及模式订阅的功能。</p>

<h2 id="toc_16">相关链接</h2>

<ul>
<li><a href="https://blog.csdn.net/guodongxiaren/article/details/44747719">https://blog.csdn.net/guodongxiaren/article/details/44747719</a></li>
<li><a href="http://www.spongeliu.com/415.html">http://www.spongeliu.com/415.html</a></li>
<li><a href="https://github.com/huangz1990/blog/blob/master/diary/2013/how-redis-fix-invalid-aof-file.rst">https://github.com/huangz1990/blog/blob/master/diary/2013/how-redis-fix-invalid-aof-file.rst</a></li>
<li><a href="https://www.cnblogs.com/frank-yxs/p/5925838.html">https://www.cnblogs.com/frank-yxs/p/5925838.html</a></li>
<li><a href="https://people.eecs.berkeley.edu/%7Esangjin/2012/12/21/epoll-vs-kqueue.html">https://people.eecs.berkeley.edu/~sangjin/2012/12/21/epoll-vs-kqueue.html</a></li>
<li><a href="https://www.cnblogs.com/moonz-wu/p/4740908.html">https://www.cnblogs.com/moonz-wu/p/4740908.html</a></li>
</ul>

<h2 id="toc_17">总结</h2>

<p>贼累，准备做PPT，思考怎么写</p>


    

      </div>

      <div class="row">
        <div class="large-6 columns">
        <p class="text-left" style="padding:15px 0px;">
      
          <a href="15390880867263.html" 
          title="Previous Post: 总结docker搭建服务过程">&laquo; 总结docker搭建服务过程</a>
      
        </p>
        </div>
        <div class="large-6 columns">
      <p class="text-right" style="padding:15px 0px;">
      
          <a  href="15319770094977.html" 
          title="Next Post: Redis 集群管理学习">Redis 集群管理学习 &raquo;</a>
      
      </p>
        </div>
      </div>
      <div class="comments-wrap">
        <div class="share-comments">
          

          

          
        </div>
      </div>
    </div><!-- article-wrap -->
  </div><!-- large 8 -->




 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <div class="site-a-logo"><img src="https://avatars3.githubusercontent.com/u/8474552?s=240" /></div>
            
                <h1>artikell</h1>
                <div class="site-des">The royal family never give up</div>
                <div class="social">







<a target="_blank" class="weibo" href="https://weibo.com/skyfirelee" title="weibo">Weibo</a>

<a target="_blank" class="github" target="_blank" href="https://github.com/artikell" title="GitHub">GitHub</a>
<a target="_blank" class="email" href="mailto:739609084@qq.com" title="Email">Email</a>
  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Optimize.html"><strong>Optimize</strong></a>
        
            <a href="Redis.html"><strong>Redis</strong></a>
        
            <a href="Docker.html"><strong>Docker</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15602214770128.html">MYSQL技术内幕学习</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15601369361254.html">红黑树学习纪要</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15526053026851.html">优化专栏</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15444908356391.html">Golang启动流程</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15416610621281.html">Golang版本对比以及选择</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    <script src="asset/chart/all-min.js"></script><script type="text/javascript">$(function(){    var mwebii=0;    var mwebChartEleId = 'mweb-chart-ele-';    $('pre>code').each(function(){        mwebii++;        var eleiid = mwebChartEleId+mwebii;        if($(this).hasClass('language-sequence')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = Diagram.parse($(this).text());            diagram.drawSVG(eleiid,{theme: 'simple'});        }else if($(this).hasClass('language-flow')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = flowchart.parse($(this).text());            diagram.drawSVG(eleiid);        }    });});</script>

<script type="text/javascript" id="clustrmaps" src="//cdn.clustrmaps.com/map_v2.js?d=AuPEZ-c53o0H60BOXU24K2rdNJKSXVErzoVhvbmRhrs&cl=ffffff&w=a"></script>

  </body>
</html>
