<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  Redis - artikell
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="artikell" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:artikell.github.io ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="http://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; artikell</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
        
        <li><a target="self" href="index.html">Home</a></li>
        
        <li><a target="_self" href="archives.html">Archives</a></li>
        

    <li><label>Categories</label></li>

        
            <li><a href="Optimize.html">Optimize</a></li>
        
            <li><a href="Redis.html">Redis</a></li>
        
            <li><a href="Hobby.html">Hobby</a></li>
        
            <li><a href="Docker.html">Docker</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15345862239174.html">
                
                  <h1>Redis 主流程学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>本文主要介绍Redis主流程的过程，包括<em>启动初始化，事件，命令处理，异常处理</em>4大块，尽可能覆盖全面。</p>

<h2 id="toc_1">启动初始化</h2>

<p>启动初始化一般都有3个流程：<em>环境设置、配置解析、模块初始化</em>。三者主要是为了后续持续的运行做准备。</p>

<h3 id="toc_2">环境设置</h3>

<p>环境设置大部分都是一些与系统相关的设置，例如不同的系统会使用不同的事件模型</p>

<table>
<thead>
<tr>
<th>事件模型</th>
<th>系统</th>
</tr>
</thead>

<tbody>
<tr>
<td>Evport</td>
<td>sun系统</td>
</tr>
<tr>
<td>Epoll</td>
<td>linux系统</td>
</tr>
<tr>
<td>Kqueue</td>
<td>unix系统</td>
</tr>
<tr>
<td>Select</td>
<td>兜底</td>
</tr>
</tbody>
</table>

<p>对于四种模型，select是最简单的，也是性能较差的一个，所以是用于兜底方案，而关于epoll和kqueue都是主动触发的事件模型。2者其实是用于解决C10K问题而从select中衍生出来的模型，同时是分别针对linux系统和Unix系统设计。</p>

<pre><code>#ifdef HAVE_EVPORT
#include &quot;ae_evport.c&quot;
#else
    #ifdef HAVE_EPOLL
    #include &quot;ae_epoll.c&quot;
    #else
        #ifdef HAVE_KQUEUE
        #include &quot;ae_kqueue.c&quot;
        #else
        #include &quot;ae_select.c&quot;
        #endif
    #endif
#endif
</code></pre>

<p>同时还有类似内存池的选择，是zmalloc,还是jmalloc，都是在编译时候设置好。</p>

<p>在启动的时候，能做的事情不多，主要就是：语言环境、标题、随机种子、监督。</p>

<h3 id="toc_3">配置解析</h3>

<p>配置主要都是从命令行参数列表中获取，而针对一下特殊的参数例如<em>version、help、test-memory</em>就有特殊处理。</p>

<pre><code>if (strcmp(argv[1], &quot;-v&quot;) == 0 ||
    strcmp(argv[1], &quot;--version&quot;) == 0) version();
if (strcmp(argv[1], &quot;--help&quot;) == 0 ||
    strcmp(argv[1], &quot;-h&quot;) == 0) usage();
if (strcmp(argv[1], &quot;--test-memory&quot;) == 0) {
    if (argc == 3) {
        memtest(atoi(argv[2]),50);
        exit(0);
    } else {
        fprintf(stderr,&quot;Please specify the amount of memory to test in megabytes.\n&quot;);
        fprintf(stderr,&quot;Example: ./redis-server --test-memory 4096\n\n&quot;);
        exit(1);
    }
}
</code></pre>

<p>配置检查第一个参数，如果不是以双减号开头，则作为配置文件，同时会补全configfile为绝对路径，这样的话，后续debug模式下重启服务可以正常启动。</p>

<pre><code>if (argv[j][0] != &#39;-&#39; || argv[j][1] != &#39;-&#39;) {
    configfile = argv[j];
    server.configfile = getAbsolutePath(configfile);
    /* Replace the config file in server.exec_argv with
     * its absoulte path. */
    zfree(server.exec_argv[j]);
    server.exec_argv[j] = zstrdup(server.configfile);
    j++;
}
</code></pre>

<p>后续的配置设置，都是以<code>--</code>开头，例如：<code>--port 6379</code>，都作为配置信息。<br/>
例如： <code>redis-server --port 6379 --save 900 1 --save 300 1</code> ，会被解析为：</p>

<pre><code>port 6379
save 900 1
save 300 1
</code></pre>

<p>这样的好处就是可以和配置文件复用同一套的解析方法。</p>

<p>其中有个有趣的模式是支持从输入流中获取配置信息，开启方法则是在配置文件的时候输入一个减号，例如：<code>redis-server -</code>，后续通过<code>ctrl+c</code>退出模式。当然，格式将和配置文件是相同。</p>

<p>后续的配置解析是将整个配置信息通过<code>\n\t\r</code>，进行分隔成多行，并针对每一行的第一个元素小写，找到相应的变量设置。若设置错误，则直接会报错并退出进程。</p>

<h3 id="toc_4">模块初始化</h3>

<p>初始化流程中，大部分模块都进行了初始化处理，例如：bio，lua，模块module，cluster，信号，慢日志等。</p>

<p>初始化的时候，主要功能都是在做对象内存的申请，端口的监听。其中当然包括多个数据库的申请，以及持久化数据的导入。</p>

<h2 id="toc_5">事件</h2>

<p>Redis事件分为2类：<em>时间事件和文件事件</em>，事件可以和Nginx的事件模型对齐，文件事件和定时事件交替执行。而和Nginx不一样的是，Redis对时间要求比Nginx严格，所以Redis会搜索最近的一个时间事件，并计算文件事件获取的超时时间。</p>

<h3 id="toc_6">时间事件</h3>

<p>在Redis中，时间事件记录就是通过链条来记录：</p>

<pre><code>typedef struct aeTimeEvent {
    long long id; /* time event identifier. */
    long when_sec; /* seconds */
    long when_ms; /* milliseconds */
    aeTimeProc *timeProc;
    aeEventFinalizerProc *finalizerProc;
    void *clientData;
    struct aeTimeEvent *next;
} aeTimeEvent;
</code></pre>

<p>所以，每次找最近的时间事件，都是直接遍历来获取。<br/>
从整个的Redis源码中，只有一个地方使用到了时间事件，那就是ServerCron方法，</p>

<pre><code>aeCreateTimeEvent(server.el, 1, serverCron, NULL, NULL)
</code></pre>

<p>这个方法主要用于维护Redis服务器的日常，可以看见的是，该方法是1ms执行一次，所以，所有的文件事件间隔不会大于1ms，这也是为啥Redis高效的原因。</p>

<h4 id="toc_7">ServerCron 函数</h4>

<p>作为主要的定时函数，ServerCron函数功能主要用于维护整个Redis的稳定。常见的操作有：数据库的重哈希、数据持久化、内存清理、删除超时客户端等。</p>

<p>与此同时，ServerCron函数也会调用其他的定时函数，例如：ClientCron、DatabaseCron函数，这些原本都是在ServerCron函数中，后来为了便于维护，所以，移出去了。</p>

<p>与ServerCron函数有关系的配置就是hz配置，官方解释是：<code>Time interrupt calls/sec</code>，默认是10，也就是说，默认是每100ms执行一次。</p>

<p><em>那如果对于有些定时任务需要1s执行一次，怎么实现？</em>有2种办法，一是新建一个定时任务来做这个操作，二是在ServerCron中来做调用这个函数。</p>

<p>而在类似ClientCron函数，Redis就采用的是第二种方法，其中会设置cronloops方法来记录当前是第几次循环，并判断是否需要调用：</p>

<pre><code>#define run_with_period(_ms_) if ((_ms_ &lt;= 1000/server.hz) || !(server.cronloops%((_ms_)/(1000/server.hz))))
</code></pre>

<p>这个宏类似于条件判断，每ms时间执行一次后续的操作。如:</p>

<pre><code>run_with_period(100) trackOperationsPerSecond();
</code></pre>

<p>每百微秒，执行一次跟踪操作函数，记录这段时间的命令执行情况</p>

<h3 id="toc_8">文件事件</h3>

<p>对于文件事件，是整个Redis异步处理的关键，在各个模块，例如AOF，集群，脚本等模块都需要文件事件来支撑。不过和时间事件不同，文件事件是根据不同的模型实现的，其中包含：select\epoll\evport\kqueue四种模型，每个模型都抽象出了7个方法：<br/>
1. aeApiCreate - 创建事件对象，类似初始化<br/>
2. aeApiResize - 重置事件对象<br/>
3. aeApiFree - 删除事件对象<br/>
4. aeApiAddEvent - 添加事件<br/>
5. aeApiDelEvent - 删除事件<br/>
6. aeApiPoll - 获取事件列表<br/>
7. aeApiName - 获取事件名称</p>

<!-- 而四个文件模型各自的优缺点如下： -->

<p>在端口监听的时候，使用到了文件模型来处理socket信息：</p>

<pre><code>(aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE, acceptTcpHandler,NULL)
</code></pre>

<h3 id="toc_9">循环前置</h3>

<p>对于一些需要频繁的操作，需要有一个地方来执行，如果使用时间模型来做的话，那容易导致间隔过长，于是在Redis的事件模型中，存在beforeSleep函数，在每次执行事件的时候，会先调用该函数，主要功能一般都是用于清理无用数据以及持久化数据落盘等简单动作。</p>

<h2 id="toc_10">命令处理</h2>

<p>命令处理可以划分3个部分：<em>连接建立、请求处理、返回数据</em>。</p>

<h3 id="toc_11">接收请求</h3>

<p>连接的建立在文件事件里面已经有提过，就是通过将socke绑定在文件事件中执行。</p>

<p>在建立连接的时候，redis都会循环1000次，尽可能多的接收请求。</p>

<p>获得了socket后，redis会创建客户端对象，其中需要检查2个事情：是否超过最大连接数、是否是无密码远程登录。对应配置为：<code>maxclients</code>和<code>protected-mode</code>。</p>

<p>后续再建立client的时候，会将socket设置为noblock和TcpNoDelay模式，加快数据的传输，同时还会设置keepalive模式。</p>

<p>请求处理的时候，在接收请求，redis进行了协议的处理，redis每次会申请16k的大小来获取数据，同时根据是否知道长度来调整缓存区<br/>
同时，redis后续会根据，是否成功，或缓存数据是否过多来中的客户端请求<br/>
之后，会根据是否为master来做一些广播的处理</p>

<h3 id="toc_12">请求处理</h3>

<p>当获取到请求的时候，redis会解析请求的第一个参数，找到相应的命令对象</p>

<pre><code>struct redisCommand redisCommandTable[] = {
    {&quot;module&quot;,moduleCommand,-2,&quot;as&quot;,0,NULL,1,1,1,0,0},
    {&quot;get&quot;,getCommand,2,&quot;rF&quot;,0,NULL,1,1,1,0,0},
    {&quot;set&quot;,setCommand,-3,&quot;wm&quot;,0,NULL,1,1,1,0,0},
</code></pre>

<p>以get命令来看，命令列表其实是通过一个枚举的过程来做的，到最后会变成一个字典，所以查询的效率很高。</p>

<p>在执行的过程中，命令需要做一系列的检查，包括各种情况：</p>

<ol>
<li>命令不存在</li>
<li>命令不合法</li>
<li>需要登录，却不是auth命令</li>
<li>若命令对内存严格要求，且服务器无内存</li>
<li>如果磁盘上存在问题，请不要接受写命令</li>
<li>如果不满足最低正常从服务器要求，不接受写操作</li>
<li>如果只是一个只读的从服务器，不接受写操作</li>
<li>在订阅模式下，只允许一部分命令</li>
<li>当连接断开时，是否接受请求</li>
<li>若正在加载，接受一部分请求</li>
<li>如果lua命令太慢，则只允许一部分请求</li>
<li>如果是事务命令，则加入事务列表</li>
<li>否则就执行</li>
</ol>

<h4 id="toc_13">事务操作</h4>

<p>对于事务类操作，有 MULTI、DISCARD、EXEC和WATCH四个命令。而参考mysql中的事务，有begin、rollback、commit三个命令。多了一个命令，而其实原理上已经完全不一样。<br/>
对于事务的实现，数据结构如下：</p>

<pre><code>typedef struct multiCmd {
    robj **argv;
    int argc;
    struct redisCommand *cmd;
} multiCmd;

typedef struct multiState {
    multiCmd *commands;     /* 事务命令数组 */
    int count;              /* 命令个数 */
    int minreplicas;        /* MINREPLICAS for synchronous replication */
    time_t minreplicas_timeout; /* MINREPLICAS timeout as unixtime. */
} multiState;
</code></pre>

<p>其中，主要是commands属性用于存储事务的命令列表，以及一些参数。</p>

<p>首先，watch命令是一个有趣的命令，它会监听一些数据是否变化，首先，对于每个数据库和每个客户端对象，都会有一个<code>watched_keys</code>属性：对于客户端对象而言，<code>watched_keys</code>是一个list列表，主要用于记录当前监听的键，而对于数据库对象而言，<code>watched_keys</code>则是一个以<code>watch</code>的变量名键的字典，用于记录当前键被监听的客户端列表。</p>

<p>如果每次数据库中有变化，其中包括列表排序、过期清空等操作，都会将相关的客户端状态置为<code>CLIENT_DIRTY_CAS</code>状态</p>

<p>MULTI命令和DISCARD命令则相对比较简单，前者只需要将客户端属性设置为事务态，而后者则相反，移除客户端的事务态标记，同时清空命令数组等。</p>

<p>而对于EXEC命令，则是极其复杂的，因为它需要检查异常情况，同时运行命令：</p>

<ol>
<li>检查客户端是否在事务态</li>
<li>检查命令是否正常以及键是否被改变</li>
<li>取消所有监听的键</li>
<li>广播事务命令</li>
<li>循环执行所有命令，并返回</li>
</ol>

<p>回顾一下事务的4个条件（ACID）：原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。</p>

<p>Redis对于原子性是没有特别严格的保证，正常运行时，操作失败的时候，可能是语法错误或者错误的数据库类型操作，这种操作一般都可以避免。<br/>
由于Redis单线程来保证，由于命令只能串行运行，所以，隔离性和一致性，Redis完全没问题。<br/>
而关于持久性，Redis通过AOF和快照2中模式来实现，不过，并不是完全能持久化。</p>

<p>所以，对于Redis事务而言，实现了隔离性和一致性，但无法保证原子性和持久性</p>

<blockquote>
<p>待补充，事务中的异常处理以及广播</p>
</blockquote>

<h4 id="toc_14">阻塞操作</h4>

<p>阻塞命令在Redis中，其中是比较关键的一系列命令，很多工具都是通过它来实现，例如消息队列等。而核心命令则是：blpop和brpop。</p>

<p>关于阻塞，本身和事务的watch命令类似，在数据库对象中都存在一个<code>blocking_keys</code>字典，它的键为相关的键名，值则是客户端对象列表。</p>

<p>而在客户端对象这边是存在一个bpop属性，结构体如下：</p>

<pre><code>typedef struct blockingState {
    /* Generic fields. */
    mstime_t timeout;       /* Blocking operation timeout. If UNIX current time
                             * is &gt; timeout then the operation timed out. */

    /* BLOCKED_LIST */
    dict *keys;             /* The keys we are waiting to terminate a blocking
                             * operation such as BLPOP. Otherwise NULL. */
    robj *target;           /* The key that should receive the element,
                             * for BRPOPLPUSH. */

    /* BLOCKED_WAIT */
    int numreplicas;        /* Number of replicas we are waiting for ACK. */
    long long reploffset;   /* Replication offset to reach. */

    /* BLOCKED_MODULE */
    void *module_blocked_handle; /* RedisModuleBlockedClient structure.
                                    which is opaque for the Redis core, only
                                    handled in module.c. */
} blockingState;
</code></pre>

<p>其中需要关注的主要是keys、timeout、target三个属性，其中keys主要用于记录阻塞的列表名称，timeout则用于表示阻塞超时时间，target则用于特殊命令<code>BRPOPLPUSH</code>来标记转移的列表对象。</p>

<p>对于已阻塞的客户端而言，其实只有在增加键的时候才会结束阻塞，所以，每个新增列表的时候，都会将列表名加入<code>ready_keys</code>列表中，但命令执行的时候，会检查该列表是否为空，若不为空，则代表有新的列表变动，所以需要修改阻塞状态。</p>

<h4 id="toc_15">订阅操作</h4>

<p>对于订阅功能，其实包含的命令只有 PUBLISH、SUBSCRIBE 2个命令。一个用于订阅管道，一个用于推送消息。其中的中间键叫channel。这与阻塞操作不同的在于，订阅发布是一个1对n的模型，而pop操作是一个1对1的模型。这其中的难度就在于发布给多个客户端以及模式订阅的功能。</p>

<h2 id="toc_16">相关链接</h2>

<ul>
<li><a href="https://blog.csdn.net/guodongxiaren/article/details/44747719">https://blog.csdn.net/guodongxiaren/article/details/44747719</a></li>
<li><a href="http://www.spongeliu.com/415.html">http://www.spongeliu.com/415.html</a></li>
<li><a href="https://github.com/huangz1990/blog/blob/master/diary/2013/how-redis-fix-invalid-aof-file.rst">https://github.com/huangz1990/blog/blob/master/diary/2013/how-redis-fix-invalid-aof-file.rst</a></li>
<li><a href="https://www.cnblogs.com/frank-yxs/p/5925838.html">https://www.cnblogs.com/frank-yxs/p/5925838.html</a></li>
<li><a href="https://people.eecs.berkeley.edu/%7Esangjin/2012/12/21/epoll-vs-kqueue.html">https://people.eecs.berkeley.edu/~sangjin/2012/12/21/epoll-vs-kqueue.html</a></li>
<li><a href="https://www.cnblogs.com/moonz-wu/p/4740908.html">https://www.cnblogs.com/moonz-wu/p/4740908.html</a></li>
</ul>

<h2 id="toc_17">总结</h2>

<p>贼累，准备做PPT，思考怎么写</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/8/18</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Redis.html'>Redis</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15319770094977.html">
                
                  <h1>Redis 集群管理学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>Redis集群管理包括哨兵模式、分片、以及主从同步3大块。外部扩展包括codis以及kedis2个项目，顺带zookeeper的集群解决方案。<br/>
本文主要从主从和分片模块收集并解析。</p>


                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                   <a href="15319770094977.html">Read more</a>&nbsp;&nbsp; 
                    <span class="date">2018/7/19</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Redis.html'>Redis</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15304363559324.html">
                
                  <h1>Redis 慢日志</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>慢日志是一个比较简短的模块，先来看看</p>

<h2 id="toc_1">慢日志条件</h2>

<p>说的慢日志，我们可以先看看call调用函数的flags分类：</p>

<pre><code>#define CMD_CALL_NONE 0
#define CMD_CALL_SLOWLOG (1&lt;&lt;0)
#define CMD_CALL_STATS (1&lt;&lt;1)
#define CMD_CALL_PROPAGATE_AOF (1&lt;&lt;2)
#define CMD_CALL_PROPAGATE_REPL (1&lt;&lt;3)
#define CMD_CALL_PROPAGATE (CMD_CALL_PROPAGATE_AOF|CMD_CALL_PROPAGATE_REPL)
#define CMD_CALL_FULL (CMD_CALL_SLOWLOG | CMD_CALL_STATS | CMD_CALL_PROPAGATE)
</code></pre>

<p>包括四类：添加慢日志、进入命令统计、AOF传播和REPL传播<br/>
正常命令都会包含所有<em>flags</em>，所以默认会进行慢日志统计。</p>

<pre><code>    if (flags &amp; CMD_CALL_SLOWLOG &amp;&amp; c-&gt;cmd-&gt;proc != execCommand) {  // 慢日志写入
        char *latency_event = (c-&gt;cmd-&gt;flags &amp; CMD_FAST) ?
                              &quot;fast-command&quot; : &quot;command&quot;;
        latencyAddSampleIfNeeded(latency_event,duration/1000);
        slowlogPushEntryIfNeeded(c,c-&gt;argv,c-&gt;argc,duration);
    }
</code></pre>

<p>慢日志入口的判断就比较简单，判断是否有标记以及命令是否为<em>execCommand</em>，事务处理不计入统计。</p>

<h2 id="toc_2">慢日志源码剖析</h2>

<h3 id="toc_3">主要结构体</h3>

<p><em>slowlogEntry</em>是慢日志的唯一结构体</p>

<pre><code>typedef struct slowlogEntry {
    robj **argv;        /* 参数列表 */   
    int argc;           /* 参数个数 */   
    long long id;       /* 唯一编号 */
    long long duration; /* 处理时长，毫秒 */
    time_t time;        /* 执行时间 */
    sds cname;          /* 客户端名称 */
    sds peerid;         /* 客户端地址 */
} slowlogEntry;
</code></pre>

<h3 id="toc_4">主要函数</h3>

<p><em>slowlogPushEntryIfNeeded</em> 函数是整个慢日志的触发入口：</p>

<pre><code>void slowlogPushEntryIfNeeded(client *c, robj **argv, int argc, long long duration) {
    if (server.slowlog_log_slower_than &lt; 0) return; /* 未开启慢日志记录 */
    if (duration &gt;= server.slowlog_log_slower_than) /* 耗时足够 */
        /* 将慢日志插入列表中 */
        listAddNodeHead(server.slowlog,
                        slowlogCreateEntry(c,argv,argc,duration));

        
    while (listLength(server.slowlog) &gt; server.slowlog_max_len)
        listDelNode(server.slowlog,listLast(server.slowlog));
}
</code></pre>

<p><em>slowlogCreateEntry</em>函数，则是创建一个慢日志元素的方法：</p>

<pre><code>slowlogEntry *slowlogCreateEntry(client *c, robj **argv, int argc, long long duration) {
    slowlogEntry *se = zmalloc(sizeof(*se));
    int j, slargc = argc;

    /* 参数不允许超过32个，否则就截取前32个 */
    if (slargc &gt; SLOWLOG_ENTRY_MAX_ARGC) slargc = SLOWLOG_ENTRY_MAX_ARGC;
    se-&gt;argc = slargc;
    se-&gt;argv = zmalloc(sizeof(robj*)*slargc);
    for (j = 0; j &lt; slargc; j++) {
        /* 如果是最后一个元素时，则添加一个省略号来标记 */
        if (slargc != argc &amp;&amp; j == slargc-1) {
            se-&gt;argv[j] = createObject(OBJ_STRING,
                sdscatprintf(sdsempty(),&quot;... (%d more arguments)&quot;,
                argc-slargc+1));
        } else {
            /* 处理长度大于128的参数信息 */
            if (argv[j]-&gt;type == OBJ_STRING &amp;&amp;
                sdsEncodedObject(argv[j]) &amp;&amp;
                sdslen(argv[j]-&gt;ptr) &gt; SLOWLOG_ENTRY_MAX_STRING)
            {
                sds s = sdsnewlen(argv[j]-&gt;ptr, SLOWLOG_ENTRY_MAX_STRING);

                s = sdscatprintf(s,&quot;... (%lu more bytes)&quot;,
                    (unsigned long)
                    sdslen(argv[j]-&gt;ptr) - SLOWLOG_ENTRY_MAX_STRING);
                se-&gt;argv[j] = createObject(OBJ_STRING,s);
            } else if (argv[j]-&gt;refcount == OBJ_SHARED_REFCOUNT) {
                /* 如果是共享的变量，则直接复制 */
                se-&gt;argv[j] = argv[j];
            } else {
                /* 重新开辟内存 */
                se-&gt;argv[j] = dupStringObject(argv[j]);
            }
        }
    }
    se-&gt;time = time(NULL);
    se-&gt;duration = duration;
    se-&gt;id = server.slowlog_entry_id++;     /* 自增编号 */
    se-&gt;peerid = sdsnew(getClientPeerId(c));
    se-&gt;cname = c-&gt;name ? sdsnew(c-&gt;name-&gt;ptr) : sdsempty();
    return se;
}
</code></pre>

<p><em>slowlogReset</em>函数是用于重置慢日志的函数，方法就行遍历并删除节点</p>

<pre><code>void slowlogReset(void) {
    while (listLength(server.slowlog) &gt; 0)
        listDelNode(server.slowlog,listLast(server.slowlog));
}
</code></pre>

<h3 id="toc_5">结语</h3>

<p>看看比较简单的慢日志模块而已。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/7/1</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Redis.html'>Redis</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15298493212536.html">
                
                  <h1>Redis启动过程分析</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>一个优秀的软件都有一个优秀的启动过程来保证整个流程的高可用性。</p>

<h2 id="toc_1">Redis的各个模式</h2>

<p>要说起redis本身的启动的话，就要先区分redis本身的3个模式：</p>

<ol>
<li>主从模式</li>
<li>哨兵模式</li>
<li>集群模式</li>
</ol>

<h3 id="toc_2">主从模式</h3>

<ol>
<li><p>redis的复制功能是支持多个数据库之间的数据同步。一类是主数据库（master）一类是从数据库（slave），主数据库可以进行读写操作，当发生写操作的时候自动将数据同步到从数据库，而从数据库一般是只读的，并接收主数据库同步过来的数据，一个主数据库可以有多个从数据库，而一个从数据库只能有一个主数据库。</p></li>
<li><p>通过redis的复制功能可以很好的实现数据库的读写分离，提高服务器的负载能力。主数据库主要进行写操作，而从数据库负责读操作。</p></li>
</ol>

<h3 id="toc_3">哨兵模式</h3>

<p>redis的sentinel系统用于管理多个redis服务器，该系统主要执行三个任务：监控、提醒、自动故障转移。</p>

<ol>
<li>监控（Monitoring）： Redis Sentinel实时监控主服务器和从服务器运行状态，并且实现自动切换。</li>
<li>提醒（Notification）：当被监控的某个 Redis 服务器出现问题时， Redis Sentinel 可以向系统管理员发送通知， 也可以通过 API 向其他程序发送通知。</li>
<li>自动故障转移（Automatic failover）： 当一个主服务器不能正常工作时，Redis Sentinel 可以将一个从服务器升级为主服务器， 并对其他从服务器进行配置，让它们使用新的主服务器。当应用程序连接Redis 服务器时， Redis Sentinel会告之新的主服务器地址和端口。</li>
</ol>

<h3 id="toc_4">集群模式</h3>

<p>redis集群是一个无中心的分布式Redis存储架构，可以在多个节点之间进行数据共享，解决了Redis高可用、可扩展等问题。redis集群提供了以下两个好处</p>

<ol>
<li>将数据自动切分(split)到多个节点</li>
<li>当集群中的某一个节点故障时，redis还可以继续处理客户端的请求。</li>
</ol>

<p>一个 Redis 集群包含 16384 个哈希槽（hash slot），数据库中的每个数据都属于这16384个哈希槽中的一个。集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽。集群中的每一个节点负责处理一部分哈希槽。</p>

<h2 id="toc_5">启动解析</h2>

<h3 id="toc_6">环境初始化</h3>

<h3 id="toc_7">命令获取并处理</h3>

<h2 id="toc_8">相关链接</h2>

<ul>
<li><a href="https://www.cnblogs.com/davidwang456/p/3539721.html">深入redis内部之redis启动过程之一</a></li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/6/24</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Redis.html'>Redis</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15287304018827.html">
                
                  <h1>Redis 有序列表zset源码解析</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>有序列表底层使用了<em>ziplist</em>和<em>skiplist</em>2种数据结构，2者都是redis中相对比较复杂的数据结构，此次，我们来通过主要的命令来解析相关的核心操作。</p>

<h2 id="toc_1">相关命令</h2>

<table>
<thead>
<tr>
<th>参数</th>
<th>类型</th>
<th>解释</th>
</tr>
</thead>

<tbody>
<tr>
<td>Zadd</td>
<td>创建</td>
<td>将带有给定分值的成员添加到有序列表里面</td>
</tr>
<tr>
<td>Zrem</td>
<td>删除</td>
<td>从有序集合里面移除给定的成员，并返回被移除成员的数量</td>
</tr>
<tr>
<td>Zcard</td>
<td>查询</td>
<td>返回有序集合包含的成员数量</td>
</tr>
<tr>
<td>Zincrby</td>
<td>修改</td>
<td>将member成员的分值加上increment</td>
</tr>
<tr>
<td>Zcount</td>
<td>查询</td>
<td>返回分值介于min和max之间的成员数量，包括min和max在内</td>
</tr>
<tr>
<td>Zrank</td>
<td>查询</td>
<td>返回成员member在有序集合中的排名，成员按照分值从小到大排列</td>
</tr>
<tr>
<td>Zrevrank</td>
<td>查询</td>
<td>返回成员member在有序集合中的排名 ，成员按照分值从大到小排列</td>
</tr>
<tr>
<td>Zscore</td>
<td>查询</td>
<td>返回成员member的分值</td>
</tr>
<tr>
<td>Zrange</td>
<td>查询</td>
<td>返回有序集合中排名介于start和stop之间的成员，包括start和stop在内，如果给定了可选的WITHSCORES选项，那么命令会将成员的分值一并返回，成员按照分值从小到大排列</td>
</tr>
<tr>
<td>Zrevrange</td>
<td>查询</td>
<td>返回有序集合中排名介于start和stop之间的成员，包括start和stop在内，如果给定了可选的WITHSCORES选项，那么命令会将成员的分值一并返回，成员按照分值从大到小排列</td>
</tr>
<tr>
<td>Zrangebyscore</td>
<td>查询</td>
<td>返回有序集合中分值介于min和max之间的所有成员，包括min和max在内，并按照分值从小到大的排序来返回他们</td>
</tr>
<tr>
<td>Zrevrangebyscore</td>
<td>查询</td>
<td>返回有序集合中分值介于min和max之间的所有成员，包括min和max在内，并按照分值从大到小的排序来返回他们</td>
</tr>
<tr>
<td>Zremrangebyrank</td>
<td>删除</td>
<td>移除有序集合中排名介于start和stop之间的所有成员，包括start和stop在内</td>
</tr>
<tr>
<td>Zremrangebyscore</td>
<td>删除</td>
<td>移除有序集合中分值介于min和max之间的所有成员，包括min和max在内</td>
</tr>
<tr>
<td>Zinterstore</td>
<td>合并</td>
<td>对给定的有序集合执行类似于集合的交集运算</td>
</tr>
<tr>
<td>Zunionstore</td>
<td>合并</td>
<td>对给定的有序集合执行类似于集合的并集运算</td>
</tr>
</tbody>
</table>

<p>其中 <em>查询操作</em> 包含 9个命令，<em>增加或更新</em>只有2个，而<em>删除类命令</em>包括了3个。</p>

<p>这么一看，核心操作主要在于如何高效查询，以及如何进行底层数据结构的升级。</p>

<h2 id="toc_2">高效查询</h2>

<p>查询本身也分为2类：单元素查询、范围查询。</p>

<h3 id="toc_3">单元素查询</h3>

<p>单元素查询相对比较简单，一般都是某个成员的分值、排名等信息。2者之间的核心就是在于：如何快速查询到所需的成员。</p>

<h4 id="toc_4">对于ziplist</h4>

<p>ziplist最多也就512个元素，所以，不需要什么算法，暴力就行！！！</p>

<pre><code>while(eptr != NULL) {
    if (ziplistCompare(eptr,(unsigned char*)ele,sdslen(ele)))
        break;
    rank++;
    zzlNext(zl,&amp;eptr,&amp;sptr);
}
</code></pre>

<h4 id="toc_5">对于skiplist</h4>

<p><em>skiplist</em>本身可能会有很多元素，所以，本身的设计也是为了高效设计，所以，本身按照跳跃表的特性，我们只需要从最大的元素开始不断往下寻找元素即可。</p>

<pre><code>for (i = zsl-&gt;level-1; i &gt;= 0; i--) {
    while (x-&gt;level[i].forward &amp;&amp;
        (x-&gt;level[i].forward-&gt;score &lt; score ||
            (x-&gt;level[i].forward-&gt;score == score &amp;&amp;
            sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt;= 0))) {
        rank += x-&gt;level[i].span;
        x = x-&gt;level[i].forward;
    }

    /* x might be equal to zsl-&gt;header, so test if obj is non-NULL */
    if (x-&gt;ele &amp;&amp; sdscmp(x-&gt;ele,ele) == 0) {
        return rank;
    }
}
</code></pre>

<h3 id="toc_6">范围查询</h3>

<p>范围查询也可以分为3类：<em>分值范围、排名范围、字符串匹配</em>。不过三者之间的差异并没有特别巨大，也可以根据不同的结构体进行分类讨论。</p>

<h4 id="toc_7">对于ziplist</h4>

<p>ziplist 本身由于节省内存，所以，方法上没有不同，照常还是遍历。</p>

<p>首先，ziplist会获取的范围的对象，通过first类函数找到最初的元素：</p>

<pre><code>    while (eptr != NULL) {
        sptr = ziplistNext(zl,eptr);
        serverAssert(sptr != NULL);

        score = zzlGetScore(sptr);
        if (zslValueGteMin(score,range)) {
            /* Check if score &lt;= max. */
            if (zslValueLteMax(score,range))
                return eptr;
            return NULL;
        }

        /* Move to next element. */
        eptr = ziplistNext(zl,sptr);
    }
</code></pre>

<p>找到起始元素后，会通过迭代的方式来获取范围类的数据，并进行删除。</p>

<pre><code>while ((sptr = ziplistNext(zl,eptr)) != NULL) {
    if (zzlLexValueLteMax(eptr,range)) {
        /* Delete both the element and the score. */
        zl = ziplistDelete(zl,&amp;eptr);
        zl = ziplistDelete(zl,&amp;eptr);
        num++;
    } else {
        /* No longer in range. */
        break;
    }
}
</code></pre>

<h4 id="toc_8">对于skiplist</h4>

<p>skiplist 本身的高效，所以，不需要特别的处理，不过，也只是在最开始的时候快速找到起始元素，然后开始不断遍历。</p>

<pre><code>x = zsl-&gt;header;
for (i = zsl-&gt;level-1; i &gt;= 0; i--) {
    while (x-&gt;level[i].forward &amp;&amp;
        !zslLexValueGteMin(x-&gt;level[i].forward-&gt;ele,range))
            x = x-&gt;level[i].forward;
    update[i] = x;
}

/* Current node is the last with score &lt; or &lt;= min. */
x = x-&gt;level[0].forward;

/* Delete nodes while in range. */
while (x &amp;&amp; zslLexValueLteMax(x-&gt;ele,range)) {
    zskiplistNode *next = x-&gt;level[0].forward;
    zslDeleteNode(zsl,x,update);
    dictDelete(dict,x-&gt;ele);
    zslFreeNode(x); /* Here is where x-&gt;ele is actually released. */
    removed++;
    x = next;
}
</code></pre>

<h2 id="toc_9">合并操作</h2>

<p>对于差集，多个集合进行轮询，判断第一个集合的元素是否在其他集合中，若存在，则添加进一个新建的有序集合中即可。</p>

<p>对于并集，那就是先把所有集合全部插入一个字典中，在遍历字典，插入集合中即可。</p>

<p>2者默认都是skiplist模式的有序列表。</p>

<h2 id="toc_10">总结</h2>

<p>此次只看到一点皮毛，感觉redis源码很多地方写法与自身写法不同，侧面反映作者注重于效率。</p>

<h2 id="toc_11">相关链接</h2>

<ul>
<li><a href="https://blog.csdn.net/xiaouncle/article/details/62236593">Redis常用命令-Zset</a></li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/6/11</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Redis.html'>Redis</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15286369556294.html">
                
                  <h1>Redis常用数据类型介绍、使用场景</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">String（字符串）</h2>

<p>String是简单的 key-value 键值对，value 不仅可以是 String，也可以是数字。String在redis内部存储默认就是一个字符串，被redisObject所引用，当遇到incr,decr等操作时会转成数值型进行计算，此时redisObject的encoding字段为int。</p>

<p>String在redis内部存储默认就是一个字符串，被redisObject所引用，当遇到incr,decr等操作时会转成数值型进行计算，此时redisObject的encoding字段为int。</p>

<h3 id="toc_1">应用场景</h3>

<p>String是最常用的一种数据类型，普通的key/value存储都可以归为此类，这里就不所做解释了。</p>

<h2 id="toc_2">List（列表）</h2>

<p>Redis列表是简单的字符串列表，可以类比到C++中的std::list，简单的说就是一个链表或者说是一个队列。可以从头部或尾部向Redis列表添加元素。列表的最大长度为2<sup>32</sup> - 1，也即每个列表支持超过40亿个元素。</p>

<p>Redis list的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销，Redis内部的很多实现，包括发送缓冲队列等也都是用的这个数据结构。</p>

<h3 id="toc_3">应用场景</h3>

<p>Redis list的应用场景非常多，也是Redis最重要的数据结构之一，比如twitter的关注列表、粉丝列表等都可以用Redis的list结构来实现，再比如有的应用使用Redis的list类型实现一个简单的轻量级消息队列，生产者push，消费者pop/bpop。</p>

<h2 id="toc_4">Hash（字典，哈希表）</h2>

<p>类似C#中的dict类型或者C++中的hash_map类型。</p>

<p>Redis Hash对应Value内部实际就是一个HashMap，实际这里会有2种不同实现，这个Hash的成员比较少时Redis为了节省内存会采用类似一维数组的方式来紧凑存储，而不会采用真正的HashMap结构，对应的value redisObject的encoding为zipmap,当成员数量增大时会自动转成真正的HashMap,此时encoding为ht。</p>

<h3 id="toc_5">应用场景</h3>

<p>假设有多个用户及对应的用户信息，可以用来存储以用户ID为key，将用户信息序列化为比如json格式做为value进行保存。</p>

<h2 id="toc_6">Set（集合）</h2>

<p>可以理解为一堆值不重复的列表，类似数学领域中的集合概念，且Redis也提供了针对集合的求交集、并集、差集等操作。</p>

<p>set 的内部实现是一个 value永远为null的HashMap，实际就是通过计算hash的方式来快速排重的，这也是set能提供判断一个成员是否在集合内的原因。</p>

<h3 id="toc_7">应用场景</h3>

<p>Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。</p>

<p>又或者在微博应用中，每个用户关注的人存在一个集合中，就很容易实现求两个人的共同好友功能。</p>

<h2 id="toc_8">Sorted Set（有序集合）</h2>

<p>Redis有序集合类似Redis集合，不同的是增加了一个功能，即集合是有序的。一个有序集合的每个成员带有分数，用于进行排序。</p>

<p>Redis有序集合添加、删除和测试的时间复杂度均为O(1)(固定时间，无论里面包含的元素集合的数量)。列表的最大长度为2<sup>32-</sup> 1元素(4294967295，超过40亿每个元素的集合)。</p>

<p>Redis sorted set的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score,使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。</p>

<h3 id="toc_9">使用场景</h3>

<p>Redis sorted set的使用场景与set类似，区别是set不是自动有序的，而sorted set可以通过用户额外提供一个优先级(score)的参数来为成员排序，并且是插入有序的，即自动排序。当你需要一个有序的并且不重复的集合列表，那么可以选择sorted set数据结构，比如twitter 的public timeline可以以发表时间作为score来存储，这样获取时就是自动按时间排好序的。</p>

<p>又比如用户的积分排行榜需求就可以通过有序集合实现。还有上面介绍的使用List实现轻量级的消息队列，其实也可以通过Sorted Set实现有优先级或按权重的队列。</p>

<h2 id="toc_10">相关链接</h2>

<ul>
<li><a href="https://www.cnblogs.com/lizhenghn/p/5322887.html">Redis常用数据类型介绍、使用场景及其操作命令</a></li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/6/10</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Redis.html'>Redis</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15286278830553.html">
                
                  <h1>Redis Bio模块的学习</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p><em>Redis</em>宣称的单进程的程序，但是，源码中到处都有为了防止顺序混乱的代码，之后，在淘汰机制中发现了<em>dbAsyncDelete</em>函数，才了解到<em>Redis</em>本身的存在异步操作的，现在，我们来看看异步IO都做了什么处理吧。</p>

<h2 id="toc_1">Bio的功能</h2>

<p>Bio模块本身代码不多，可以一一来介绍各个函数的功能，首先，我们看看线程相关的一下对象。</p>

<h3 id="toc_2">线程相关对象</h3>

<pre><code>static pthread_t bio_threads[BIO_NUM_OPS];  //BIO线程
static pthread_mutex_t bio_mutex[BIO_NUM_OPS]; //BIO每个线程的mutex锁变量
static pthread_cond_t bio_newjob_cond[BIO_NUM_OPS]; //BIO线程锁的条件变量， 监听这个条件变量唤起当前线程
static pthread_cond_t bio_step_cond[BIO_NUM_OPS]; //BIO线程阻塞锁，bioWaitStepOfType监听这个条件变量被通知该操作的执行。
static list *bio_jobs[BIO_NUM_OPS];
static unsigned long long bio_pending[BIO_NUM_OPS]; // BIO未执行的
</code></pre>

<p>从中我们可以看出，线程本身是作为一个变量存储，同时，对于每个线程，都有相关的锁以及锁条件。</p>

<p>同时，<em>Redis</em>中的线程，为每种类型的操作都分配了一个线程进行处理，其中拥有3中类型：</p>

<pre><code>#define BIO_CLOSE_FILE    0 /* Deferred close(2) syscall. */
#define BIO_AOF_FSYNC     1 /* Deferred AOF fsync. */
#define BIO_LAZY_FREE     2 /* Deferred objects freeing. */
</code></pre>

<p>这样可以很好的控制线程的数量，这也是为什么<em>Redis</em>会设置一个<em>jobs</em>列表来存储任务的原因。</p>

<h3 id="toc_3">bioInit 函数</h3>

<p>bioInit函数是在整个Redis服务启动时调用，源码如下：</p>

<pre><code>void bioInit(void) {
    pthread_attr_t attr;
    pthread_t thread;
    size_t stacksize;
    int j;

    /* Initialization of state vars and objects */
    for (j = 0; j &lt; BIO_NUM_OPS; j++) {
        pthread_mutex_init(&amp;bio_mutex[j],NULL);
        pthread_cond_init(&amp;bio_newjob_cond[j],NULL);
        pthread_cond_init(&amp;bio_step_cond[j],NULL);
        bio_jobs[j] = listCreate();
        bio_pending[j] = 0;
    }

    /* Set the stack size as by default it may be small in some system */
    pthread_attr_init(&amp;attr);
    pthread_attr_getstacksize(&amp;attr,&amp;stacksize);
    if (!stacksize) stacksize = 1; /* The world is full of Solaris Fixes */
    while (stacksize &lt; REDIS_THREAD_STACK_SIZE) stacksize *= 2;
    pthread_attr_setstacksize(&amp;attr, stacksize);

    for (j = 0; j &lt; BIO_NUM_OPS; j++) {
        void *arg = (void*)(unsigned long) j;
        if (pthread_create(&amp;thread,&amp;attr,bioProcessBackgroundJobs,arg) != 0) {
            serverLog(LL_WARNING,&quot;Fatal: Can&#39;t initialize Background Jobs.&quot;);
            exit(1);
        }
        bio_threads[j] = thread;
    }
}
</code></pre>

<p>在BIO初始化时，首先是对线程相关的对象进行初始化，包括<em>线程锁、锁条件、线程队列</em>等。<br/>
在之后，通过<em>pthread_attr_init</em>函数对线程环境进行初始化，并对栈大小进行重设。<br/>
最后，根据<em>线程环境</em>创建了一系列的线程，用于后续使用。</p>

<h3 id="toc_4">bioCreateBackgroundJob 函数</h3>

<p>该函数主要是用于添加一个异步任务，传入的参数比较简单，包括Type和3个变量。这些都存储在bio_job结构体中：</p>

<pre><code>struct bio_job {
    time_t time; /* Time at which the job was created. */
    void *arg1, *arg2, *arg3;
};
</code></pre>

<p>关于为啥是3个变量，主要是针对不同类型的异步事件使用，3个变量的排列组合共有8种，差不多够用了。<br/>
代码中主要是对于惰性淘汰进行分类：若第一个指针，则代表释放object；第二个指针代表释放一个数据库；第三个指针代表释放一个哈希表。</p>

<p><em>bioCreateBackgroundJob</em> 函数在赋值完，会将相关的线程进行唤醒让其来主动处理队列中的任务。这其中的逻辑与协程相似，但却有所不同。</p>

<h3 id="toc_5">bioProcessBackgroundJobs 函数</h3>

<p>该函数在创建线程后，会直接执行，那么本身对线程做了一些设定：<br/>
<code><br/>
    pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);<br/>
    pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);<br/>
</code><br/>
首先，使线程保持可控制性，这样能线程能被杀死，这样做的目的暂时是为了debug调试。</p>

<p>之后，函数对线程进行了信号量的设置：</p>

<pre><code>sigemptyset(&amp;sigset);
sigaddset(&amp;sigset, SIGALRM);
if (pthread_sigmask(SIG_BLOCK, &amp;sigset, NULL))
    serverLog(LL_WARNING,
        &quot;Warning: can&#39;t mask SIGALRM in bio.c thread: %s&quot;, strerror(errno));
</code></pre>

<p>这个之后可以多了解一番。</p>

<p>之后，函数就进入了一个死循环用来不断的处理来自队列的任务，包括AOF同步等。</p>

<h2 id="toc_6">总结</h2>

<p><em>Redis</em>的线程使用比较谨慎，其中仅仅只包含3种类型的线程事件。这样保证了Redis本身代码的简洁。</p>

<h2 id="toc_7">相关链接</h2>

<ul>
<li><a href="https://www.cnblogs.com/lijunamneg/archive/2013/01/25/2877211.html">线程取消</a></li>
<li><a href="https://yq.aliyun.com/articles/58703?utm_source=tool.lu">bio学习</a></li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/6/10</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Redis.html'>Redis</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15286261757400.html">
                
                  <h1>Redis 跳跃表</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<h2 id="toc_1">算法分析</h2>

<h2 id="toc_2">相关链接</h2>

<ul>
<li><a href="https://blog.csdn.net/men_wen/article/details/70040026">CSDN - 跳跃表(skiplist)</a></li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/6/10</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Redis.html'>Redis</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15286147511534.html">
                
                  <h1>Redis 对象Object</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>在<em>Redis</em>中，对对象拥有一套管理的机制，包括引用、内存、以及淘汰机制，这套机制的的建立，便是Object结构体本身的设计，所以此次，我们通过相关的方面来了解<em>Object</em>对象。</p>

<h2 id="toc_1">主要的类型</h2>

<p>在对象系统中，共有6个类型：<code>string、list、set、zset、hash、stream</code>。</p>

<p>相对应的基础的数据结构也有7类：<code>string、adlist、ziplist、quicklist、dict、skiplist、inset</code></p>

<p>下面的表格将会列出各个类型对应的使用的数据结构：</p>

<table>
<thead>
<tr>
<th>Type_Encoding</th>
<th>DataStruct</th>
<th>Limit</th>
</tr>
</thead>

<tbody>
<tr>
<td>String_int</td>
<td>long long</td>
<td>Element is int</td>
</tr>
<tr>
<td>String_raw</td>
<td>sbs</td>
<td>Length &gt; 44</td>
</tr>
<tr>
<td>String_embstr</td>
<td>embstr</td>
<td>Length &lt;= 44</td>
</tr>
<tr>
<td>List_ziplist</td>
<td>ziplist</td>
<td>Default</td>
</tr>
<tr>
<td>List_quicklist</td>
<td>quicklist</td>
<td>Size &gt; 64 or Count &gt; 512</td>
</tr>
<tr>
<td>Set_ht</td>
<td>dict</td>
<td>Element isn’t int or Cout &gt; 512</td>
</tr>
<tr>
<td>Set_intset</td>
<td>intset</td>
<td>Default</td>
</tr>
<tr>
<td>Hash_ziplist</td>
<td>ziplist</td>
<td>Default</td>
</tr>
<tr>
<td>Hash_ht</td>
<td>dict</td>
<td>Size &gt; 64 or Count &gt; 512</td>
</tr>
<tr>
<td>Zset_skiplist</td>
<td>dict、skiplist</td>
<td>Size &gt; 64 or Count &gt; 128</td>
</tr>
<tr>
<td>Zset_ziplist</td>
<td>ziplist</td>
<td>Default</td>
</tr>
</tbody>
</table>

<p>大部分情况的转换都是根据元素个数与元素大小超过限制进行判断。当然这些限制也是可配置项：</p>

<pre><code>hash-max-ziplist-entries 512 
hash-max-ziplist-value 64 
list-max-ziplist-entries 512 
list-max-ziplist-value 64 
set-max-intset-entries 512 
zset-max-ziplist-entries 128 
zset-max-ziplist-value 64
</code></pre>

<h2 id="toc_2">Object的设计</h2>

<p><em>Object</em>的设计拥有所有对象系统共有的特征：<em>relcount、ptr、type</em>。细节的结构体如下：</p>

<pre><code>typedef struct redisObject {
    unsigned type:4;
    unsigned encoding:4;
    unsigned lru:LRU_BITS; /* LRU time (relative to global lru_clock) or
                            * LFU data (least significant 8 bits frequency
                            * and most significant 16 bits access time). */
    int refcount;
    void *ptr;
} robj;
</code></pre>

<p>结构体不难理解，拥有类型、编码、超时权重、引用次数以及所指内存。<br/>
其中<em>类型\编码</em>在上一节已经列举出来，相关的类型原理之后再进行描述。</p>

<h2 id="toc_3">对象的销毁以及共享</h2>

<p>在拥有对象引用属性时，系统就会考虑对象销毁的时机。对象系统提供了<em>decrRefCount</em>和<em>incrRefCount</em>2个方法，前者用于减少引用数，后者相反。</p>

<p>所以，当<em>Redis</em>使用完对象时，会调用<em>decrRefCount</em>方法来减少引用数，当发现引用数为1时，说明当前对象需要被销毁，对象系统会主动调用相关类型的销毁函数进行内存清理。</p>

<p>当然，<em>Redis</em>为了高效，提供了共享对象，其中包含<em>1~10000</em>中间的所有数字，创建时将其的引用数设置为无穷大，同时在减少引用数的时候，判断引用数是否为无穷大，是则不进行引用数减少，提高了内存利用率</p>

<h2 id="toc_4">总结</h2>

<p>关于Redis的对象系统，其实没有什么需要过多的介绍，对于对象来说，<em>Redis</em>本身对不同的类型进行了多态化的分解，导致主要的操作都分散在各个部分中，包括淘汰策略、以及内存分配等。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/6/10</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Redis.html'>Redis</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15285709665764.html">
                
                  <h1>Redis 字典扫描算法</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p>字典扫描算法包含了2个特别精巧的位运算算法，2者保证了整个扫描过程即使穿插了重哈希操作也不会顺序混合。</p>

<h2 id="toc_1">问题一：反转一个数</h2>

<p>如何快速反转一个数，正常往往都是<em>O(n)</em>的算法，虽然数字正常不会超过64位，但是，<em>Redis</em>使用了更加位运算将其复杂度减低至了<em>O(logn)</em>。</p>

<p>首先，考虑对于一个二进制数：11010100(212)，如何进行反转？</p>

<p>第一次反转，反转4位：</p>

<pre><code>mask = 0000 1111
1101 0100 &gt;&gt; 4 &amp; 0000 1111 = 0000 1101
1101 0100 &lt;&lt; 4 &amp; 1111 0000 = 0100 0000
0000 1101 | 0100 0000 = 0100 1101
</code></pre>

<p>第二次反转，反转2位：</p>

<pre><code>mask = 0000 1111 ^ 0011 1100  = 0011 0011
0100 1101 &gt;&gt; 2 &amp; 0011 0011 = 0001 0011
0100 1101 &lt;&lt; 2 &amp; 1100 1100 = 0000 0100
0001 0011 | 0000 0100 = 0001 0111
</code></pre>

<p>第三次反转，反转1位：</p>

<pre><code>mask = 0110 0110 ^ 0011 0011  = 0101 0101
0001 0111 &gt;&gt; 1 &amp; 0101 0101 = 0000 0001
0001 0111 &lt;&lt; 1 &amp; 1010 1010 = 0010 1010
0000 0001 | 0010 1010 = 0010 1011
</code></pre>

<p>其实可以发现关键的点就是<em>mask</em>的生成，规律如下：</p>

<pre><code>1. 0000 1111
2. 0011 0011
3. 0101 0101
</code></pre>

<p>通过位运算来反转二进制数。</p>

<h2 id="toc_2">问题二：遍历变长字典</h2>

<p>答案是：从高位遍历到低位。</p>

<p>遍历的情况分为3种：未进行重哈希、扩大字典、缩小字典。对于未进行重哈希的情况就不进行描述。</p>

<h3 id="toc_3">优点</h3>

<ol>
<li>提供键空间的遍历操作，支持游标，复杂度O(1), 整体遍历一遍只需要O(N)；</li>
<li>提供结果模式匹配；</li>
<li>支持一次返回的数据条数设置，但仅仅是个hints，有时候返回的会多；</li>
<li>弱状态，所有状态只需要客户端需要维护一个游标；</li>
</ol>

<h3 id="toc_4">缺点</h3>

<ol>
<li>无法提供完整的快照遍历，也就是中间如果有数据修改，可能有些涉及改动的数据遍历不到；</li>
<li>每次返回的数据条数不一定，极度依赖内部实现；</li>
<li>返回的数据可能有重复，应用层必须能够处理重入逻辑；</li>
</ol>

<h2 id="toc_5">相关链接</h2>

<ul>
<li><a href="http://chenzhenianqing.com/articles/1090.html">Redis Scan迭代器遍历操作原理</a></li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/6/10</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Redis.html'>Redis</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15285605915126.html">
                
                  <h1>Redis 淘汰策略解读</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<h2 id="toc_0">前言</h2>

<p><em>Redis</em>本身是一款高效的内存数据库，内存数据库中很重要的一点在于能很好的利用并管理内存，这也衍生出了内存淘汰策略，这和操作系统的内存页管理机制相同，拥有各种淘汰算法，例如：FIFO、LRU、OPT等，这次我们主要是讨论一下关于<em>Redis</em>本身的内存淘汰策略。</p>

<!--more-->

<h2 id="toc_1">过期键淘汰逻辑</h2>

<p>淘汰逻辑<em>Redis</em>本身存在2种方式的淘汰并存，这样做的目的也是为了提高效率。</p>

<h3 id="toc_2">惰性淘汰逻辑</h3>

<p><em>Redis</em>当键值已经超出失效时间时，是无法做到及时的将内存进行空闲出来，同时考虑到及时的将内存空闲出来会需要有十分高的成本。<br/>
于是<em>Redis</em>将淘汰功能，下发至各个命令操作中，当有客户端对相关的键进行访问时，命令将会调用<em>expireIfNeeded</em>方法来判断键值是否已经失效，若是，则将其删除。</p>

<pre><code>int expireIfNeeded(redisDb *db, robj *key) {
    mstime_t when = getExpire(db,key);
    
    mstime_t now;

    if (when &lt; 0) return 0;

    if (server.loading) return 0;

    now = server.lua_caller ? server.lua_time_start : mstime();

    if (server.masterhost != NULL) return now &gt; when;

    if (now &lt;= when) return 0;

    server.stat_expiredkeys++;
    propagateExpire(db,key,server.lazyfree_lazy_expire);
    notifyKeyspaceEvent(NOTIFY_EXPIRED,
        &quot;expired&quot;,key,db-&gt;id);
    return server.lazyfree_lazy_expire ? dbAsyncDelete(db,key) :
                                         dbSyncDelete(db,key);
}
</code></pre>

<p><em>expireIfNeeded</em>函数大致逻辑如下：<br/>
1. 获取当前键的失效时间<br/>
2. 判断失效时间是否小于0，是则表示不失效<br/>
3. 判断当前服务器是否正在加载数据信息<br/>
4. 获取当前时间<br/>
5. 判断是否已经失效<br/>
6. 统计失效键信息<br/>
7. 发送失效键信息至其余节点<br/>
8. 发送键失效通知给订阅通道<br/>
9. 键值删除</p>

<blockquote>
<p>其中键删除操作包括同步删除和异步删除，这次不进行细讲</p>
</blockquote>

<h3 id="toc_3">主动淘汰逻辑</h3>

<p>消极方法的缺点是，如果<em>key</em>迟迟不被访问，就会占用很多内存空间。 所以就产生的主动淘汰：此方法利用了<em>Redis</em>的时间事件，即每隔一段时间就中断一下完成一些指定操作，其中就包括检查并删除失效主键。<br/>
主动淘汰机制相关的配置项为<em>set-active-expire</em>，主要的调用位置为：<em>beforeSleep</em> 和 <em>databasesCron</em> ，一个是事件循环前触发，一个是数据库定时触发。</p>

<pre><code>void activeExpireCycle(int type) {
    static unsigned int current_db = 0; /* Last DB tested. */
    static int timelimit_exit = 0;      /* Time limit hit in previous call? */
    static long long last_fast_cycle = 0; /* When last fast cycle ran. */

    int j, iteration = 0;
    int dbs_per_call = CRON_DBS_PER_CALL;
    long long start = ustime(), timelimit, elapsed;

    if (clientsArePaused()) return;

    if (type == ACTIVE_EXPIRE_CYCLE_FAST) {
        if (!timelimit_exit) return;
        if (start &lt; last_fast_cycle + ACTIVE_EXPIRE_CYCLE_FAST_DURATION*2) return;
        last_fast_cycle = start;
    }

    if (dbs_per_call &gt; server.dbnum || timelimit_exit)
        dbs_per_call = server.dbnum;

    timelimit = 1000000*ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC/server.hz/100;
    timelimit_exit = 0;
    if (timelimit &lt;= 0) timelimit = 1;

    if (type == ACTIVE_EXPIRE_CYCLE_FAST)
        timelimit = ACTIVE_EXPIRE_CYCLE_FAST_DURATION; /* in microseconds. */

    long total_sampled = 0;
    long total_expired = 0;

    for (j = 0; j &lt; dbs_per_call &amp;&amp; timelimit_exit == 0; j++) {
        int expired;
        redisDb *db = server.db+(current_db % server.dbnum);

        current_db++;
        do {
            unsigned long num, slots;
            long long now, ttl_sum;
            int ttl_samples;
            iteration++;

            if ((num = dictSize(db-&gt;expires)) == 0) {
                db-&gt;avg_ttl = 0;
                break;
            }
            slots = dictSlots(db-&gt;expires);
            now = mstime();
            
            if (num &amp;&amp; slots &gt; DICT_HT_INITIAL_SIZE &amp;&amp;
                (num*100/slots &lt; 1)) break;

            expired = 0;
            ttl_sum = 0;
            ttl_samples = 0;

            if (num &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP)
                num = ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP;

            while (num--) {
                dictEntry *de;
                long long ttl;

                if ((de = dictGetRandomKey(db-&gt;expires)) == NULL) break;
                ttl = dictGetSignedIntegerVal(de)-now;
                if (activeExpireCycleTryExpire(db,de,now)) expired++;
                if (ttl &gt; 0) {
                    /* We want the average TTL of keys yet not expired. */
                    ttl_sum += ttl;
                    ttl_samples++;
                }
                total_sampled++;
            }
            total_expired += expired;

            if (ttl_samples) {
                long long avg_ttl = ttl_sum/ttl_samples;

                if (db-&gt;avg_ttl == 0) db-&gt;avg_ttl = avg_ttl;
                db-&gt;avg_ttl = (db-&gt;avg_ttl/50)*49 + (avg_ttl/50);
            }

            if ((iteration &amp; 0xf) == 0) { /* check once every 16 iterations. */
                elapsed = ustime()-start;
                if (elapsed &gt; timelimit) {
                    timelimit_exit = 1;
                    server.stat_expired_time_cap_reached_count++;
                    break;
                }
            }
        } while (expired &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP/4);
    }

    elapsed = ustime()-start;
    latencyAddSampleIfNeeded(&quot;expire-cycle&quot;,elapsed/1000);

    double current_perc;
    if (total_sampled) {
        current_perc = (double)total_expired/total_sampled;
    } else
        current_perc = 0;
    server.stat_expired_stale_perc = (current_perc*0.05)+
                                     (server.stat_expired_stale_perc*0.95);
}

</code></pre>

<p><em>activeExpireCycle</em>函数关键点如下：<br/>
1. 函数提供了 <em>ACTIVE_EXPIRE_CYCLE_FAST</em> 和 <em>ACTIVE_EXPIRE_CYCLE_SLOW</em> 2种模式，区别在于：FAST模式本身对时间有苛刻的要求，不允许淘汰键导致过高的延时，所以会有一个超时时间(1000ms)的限制。<br/>
2. 函数会遍历每个数据库，然后从过期键中获取20个值，若20个中淘汰了5个，则继续淘汰，尽可能的保证过期比例小于0.25。<br/>
3. 其中，函数会统计相关的超时情况以及淘汰时间等。</p>

<h2 id="toc_4">内存淘汰策略</h2>

<p>内存淘汰策略的设置项为<em>maxmemory-policy</em>，其中拥有6种策略：<br/>
1. <em>noeviction</em>策略(不淘汰策略)<br/>
    该策略不进行内存淘汰，当内存达到阀值后，将会报错。但该策略为默认策略，所以每次启用<em>Redis</em>服务时，最好是设置一下淘汰策略<br/>
2. <em>allkeys-lru</em>策略(主键lru策略)<br/>
    在主键空间中，优先移除最近未使用的key。<br/>
3. <em>volatile-lru</em>策略(过期键lru策略)<br/>
    在设置了过期时间的键空间中，优先移除最近未使用的key。<br/>
4. <em>allkeys-random</em>策略(主键随机淘汰策略)<br/>
    在主键空间中，随机移除某个key。<br/>
5. <em>volatile-random</em>策略(过期键随机淘汰策略)<br/>
    在设置了过期时间的键空间中，随机移除某个key。<br/>
6. <em>volatile-ttl</em>策略(过期键fifo策略)<br/>
    在设置了过期时间的键空间中，具有更早过期时间的key优先移除。</p>

<p>对于不同淘汰机制，也存在相关的使用场景：<br/>
1. <em>allkeys-lru</em>：如果我们的应用对缓存的访问符合幂律分布（也就是存在相对热点数据），或者我们不太清楚我们应用的缓存访问分布状况，我们可以选择<em>allkeys-lru</em>策略。<br/>
2. <em>allkeys-random</em>：如果我们的应用对于缓存<em>key</em>的访问概率相等，则可以使用这个策略。<br/>
3. <em>volatile-ttl</em>：这种策略使得我们可以向<em>Redis</em>提示哪些<em>key</em>更适合被<em>eviction</em>。</p>

<h2 id="toc_5">内存淘汰逻辑</h2>

<p>内存超限淘汰机制与上述的过期键淘汰机制不同，它本身存在触发的条件是在于每次定时请求，若发现内存不足时，将会进行键值淘汰，来保证正常运行。</p>

<p>与过期键淘汰函数<em>expireIfNeeded</em>对应的函数为：<em>freeMemoryIfNeeded</em>函数，它将会在定时事件和脚本运行时进行内存检查。它主要的判断条件为当前服务是否设置了<em>maxmemory</em>，若设置了则需要进行内存淘汰。</p>

<p><em>freeMemoryIfNeeded</em>函数本身针对不同的淘汰策略会有不同的逻辑。主要分为随机淘汰和策略淘汰。</p>

<h3 id="toc_6">内存随机淘汰</h3>

<p>随机淘汰的实现相对简单，只需要对不同的空间进行随机筛选键，并进内存释放即可。</p>

<pre><code>for (i = 0; i &lt; server.dbnum; i++) {
    j = (++next_db) % server.dbnum;
    db = server.db+j;
    dict = (server.maxmemory_policy == MAXMEMORY_ALLKEYS_RANDOM) ?
            db-&gt;dict : db-&gt;expires;
    if (dictSize(dict) != 0) {
        de = dictGetRandomKey(dict);
        bestkey = dictGetKey(de);
        bestdbid = j;
        break;
    }
}
</code></pre>

<h3 id="toc_7">内存策略淘汰</h3>

<p>待续，关键点：LRU算法</p>

<h2 id="toc_8">总结</h2>

<p><em>Redis</em>淘汰逻辑核心点不多，主要只是将整个淘汰工作分布至各个操作中，提高了整体的效率，同时也使用了异步删除等机制。之后还能衍生出集群的键值淘汰逻辑等。</p>

<h2 id="toc_9">参考链接</h2>

<ul>
<li><a href="https://blog.csdn.net/kl1106/article/details/79566594">CSDN - Redis缓存淘汰</a></li>
<li><a href="https://blog.csdn.net/lizhi_java/article/details/68953179">CSDN - 缓存淘汰策略</a></li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2018/6/10</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Redis.html'>Redis</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <div class="site-a-logo"><img src="https://avatars3.githubusercontent.com/u/8474552?s=240" /></div>
            
                <h1>artikell</h1>
                <div class="site-des">The royal family never give up</div>
                <div class="social">







<a target="_blank" class="weibo" href="https://weibo.com/skyfirelee" title="weibo">Weibo</a>

<a target="_blank" class="github" target="_blank" href="https://github.com/artikell" title="GitHub">GitHub</a>
<a target="_blank" class="email" href="mailto:739609084@qq.com" title="Email">Email</a>
  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Optimize.html"><strong>Optimize</strong></a>
        
            <a href="Redis.html"><strong>Redis</strong></a>
        
            <a href="Hobby.html"><strong>Hobby</strong></a>
        
            <a href="Docker.html"><strong>Docker</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15526053026851.html">优化专栏</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15444908356391.html">Golang启动流程</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15416610621281.html">Golang版本对比以及选择</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15390880867263.html">总结docker搭建服务过程</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15345862239174.html">Redis 主流程学习</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    



  </body>
</html>
