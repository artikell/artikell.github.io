<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title></title>
        <link>undefined</link>
        <description>undefined</description>
        <lastBuildDate>Wed, 02 Nov 2022 00:51:35 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>Joplin Pages Publisher</generator>
        <item>
            <title><![CDATA[Dragonfly 学习(0%)]]></title>
            <guid>38e6a1f18f514a699a274b00a746797a</guid>
            <pubDate>Wed, 02 Nov 2022 00:34:45 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Dynomite 学习(0%)]]></title>
            <guid>2ca237c7cf8e4824bd7b3beb83e9c965</guid>
            <pubDate>Wed, 02 Nov 2022 00:32:40 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Apache Pegasus学习(0%)]]></title>
            <guid>dec8900baffc4037beb178e564ed82b3</guid>
            <pubDate>Wed, 02 Nov 2022 00:32:30 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Redis7 版本差异(0%)]]></title>
            <guid>2734cc9584c642dbbaaa1e09a152cd7c</guid>
            <pubDate>Wed, 02 Nov 2022 00:26:59 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[RedisBloom 布隆过滤器详解(50%)]]></title>
            <guid>693bab77bf8d4b779fe814501119e8d4</guid>
            <pubDate>Tue, 01 Nov 2022 02:59:43 GMT</pubDate>
            <content:encoded><![CDATA[<h2 id="前言">前言</h2>
<h2 id="布隆过滤器">布隆过滤器</h2>
<p>布隆过滤器（Bloom Filter）是 1970 年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。主要用于<strong>判断一个元素是否在一个集合中</strong>。</p>
<p>通常我们会遇到很多要判断一个元素是否在某个集合中的业务场景，一般想到的是将集合中所有元素保存起来，然后通过比较确定。<strong>链表、树、散列表</strong>（又叫哈希表，Hash table）等等数据结构都是这种思路。</p>
<p>但是随着集合中元素的增加，我们需要的存储空间也会呈现线性增长，最终达到瓶颈。同时检索速度也越来越慢，上述三种结构的检索时间复杂度分别为O(n) O(n) O(n)，O(logn) O(logn) O(logn)，O(1) O(1) O(1)。</p>
<h3 id="原理">原理</h3>
<p>假设我们有个集合 A，A 中有 n 个元素。利用k个哈希散列函数，将A中的每个元素映射到一个长度为 a 位的数组 B中的不同位置上，这些位置上的二进制数均设置为 1。</p>
<p>如果待检查的元素，经过这 k个哈希散列函数的映射后，发现其 k 个位置上的二进制数全部为 1，这个元素很可能属于集合A，反之，一定不属于集合A。</p>
<h3 id="误判现象">误判现象</h3>
<p>由于本身采用的是哈希散列，故很容易存在碰撞，也会出现多个元素散列到相同的位置上，这就是布隆过滤器的误判现象，所以，布隆过滤器判断存在的不一定存在，但是，判断不存在的一定不存在。</p>
<p>其中影响整个的正确率的因素包括<strong>填充率</strong>以及<strong>散列次数</strong>。元素被散列多次，碰撞的可能性会下降，同理在填充率较低的情况下，碰撞的可能性也会减少。</p>
<p>布隆过滤器可精确的代表一个集合，可精确判断某一元素是否在此集合中，精确程度由用户的具体设计决定，达到 100% 的正确是不可能的。</p>
<h3 id="可扩展的布隆过滤器">可扩展的布隆过滤器</h3>
<p>通常，创建布隆过滤器时必须预先知道它们将包含多少条目。bpe 数需要固定，同样位数组的宽度也是固定的。<br />
与哈希表不同，布隆过滤器不能“重新平衡”，因为无法知道哪些条目是过滤器的一部分（过滤器只能确定给定条目是否存在，但实际上并不存储存在的条目）。</p>
<p>为了让布隆过滤器能够“缩放”并能够容纳比设计更多的元素，它们可以堆叠。一旦单个布隆过滤器达到容量，就会在其上创建一个新的布隆过滤器。通常，新过滤器将具有比前一个过滤器更大的容量，以减少需要堆叠另一个过滤器的可能性。</p>
<p>在可堆叠（可扩展）布隆过滤器中，检查成员资格现在涉及检查每个层是否存在。现在添加新项目涉及事先检查它是否存在，并将其添加到当前筛选器。但是，哈希仍然只需要计算一次。</p>
<p>在创建布隆过滤器（即使是可扩展的过滤器）时，重要的是要清楚地了解它应该包含多少项。初始层只能包含少量元素的过滤器将显著降低性能，因为它需要更多层才能达到更大的容量。</p>
<h3 id="redisbloom实现">RedisBloom实现</h3>
<h3 id="应用范围">应用范围</h3>
<p>布隆在海量数据查询中以优异的空间效率和低误判率有非常广泛的应用，其中包括但不限于：</p>
<ol>
<li>检查单词拼写正确性</li>
<li>检测海量名单嫌疑人</li>
<li>垃圾邮件过滤</li>
<li>搜索爬虫URL去重</li>
<li>缓存穿透过滤</li>
</ol>
<p>世界上著名各大科技公司使用布隆过滤器的实际案例：</p>
<ol>
<li>Google 著名的分布式数据库 Bigtable 使用了布隆过滤器来查找不存在的行或列，以减少磁盘查找的IO次数。</li>
<li>Squid 网页代理缓存服务器在 cache digests 中使用了也布隆过滤器。</li>
<li>Venti 文档存储系统也采用布隆过滤器来检测先前存储的数据。</li>
<li>SPIN 模型检测器也使用布隆过滤器在大规模验证问题时跟踪可达状态空间。</li>
<li>Google Chrome浏览器使用了布隆过滤器加速安全浏览服务。</li>
</ol>
<h2 id="相关命令">相关命令</h2>
<h4 id="bfadd">BF.ADD</h4>
<p>Syntax</p>
<div><pre class="hljs"><code>BF.<span class="hljs-built_in">ADD</span> key item</code></pre></div>
<p>Time complexity:</p>
<p>O(k), where k is the number of hash functions used by the last sub-filter</p>
<h4 id="bfexists">BF.EXISTS</h4>
<p>Syntax</p>
<div><pre class="hljs"><code>BF.EXISTS<span class="hljs-built_in"> key</span> <span class="hljs-type">item</span></code></pre></div>
<p>Time complexity:</p>
<p>O(k), where k is the number of hash functions used by the last sub-filter</p>
<h4 id="bfinfo">BF.INFO</h4>
<p>Syntax</p>
<div><pre class="hljs"><code>BF.INFO key [CAPACITY | <span class="hljs-type">SIZE</span> | <span class="hljs-type">FILTERS</span> | <span class="hljs-type">ITEMS</span> | <span class="hljs-type">EXPANSION</span>]</code></pre></div>
<p>Time complexity:</p>
<p>O(1)</p>
<h4 id="bfinsert">BF.INSERT</h4>
<p>Syntax</p>
<div><pre class="hljs"><code>BF.INSERT key <span class="hljs-comment">[CAPACITY capacity]</span> <span class="hljs-comment">[ERROR error]</span>
  <span class="hljs-comment">[EXPANSION expansion]</span> <span class="hljs-comment">[NOCREATE]</span> <span class="hljs-comment">[NONSCALING]</span> ITEMS item <span class="hljs-comment">[item
  ...]</span></code></pre></div>
<p>Time complexity:</p>
<p>O(k * n), where k is the number of hash functions and n is the number of items</p>
<h4 id="bfloadchunk">BF.LOADCHUNK</h4>
<p>Syntax</p>
<div><pre class="hljs"><code><span class="hljs-type">BF</span>.<span class="hljs-type">LOADCHUNK</span> key iterator <span class="hljs-class"><span class="hljs-keyword">data</span></span></code></pre></div>
<p>Time complexity:</p>
<p>O(n), where n is the capacity</p>
<h4 id="bfmadd">BF.MADD</h4>
<p>Syntax</p>
<div><pre class="hljs"><code>BF.MADD<span class="hljs-built_in"> key</span> <span class="hljs-type">item</span> [<span class="hljs-type">item</span> ...]</code></pre></div>
<p>Time complexity:</p>
<p>O(k * n), where k is the number of hash functions and n is the number of items</p>
<h4 id="bfmadd-2">BF.MADD</h4>
<p>Syntax</p>
<div><pre class="hljs"><code>BF.MADD<span class="hljs-built_in"> key</span> <span class="hljs-type">item</span> [<span class="hljs-type">item</span> ...]</code></pre></div>
<p>Time complexity:</p>
<p>O(k * n), where k is the number of hash functions and n is the number of items</p>
<h4 id="bfmexists">BF.MEXISTS</h4>
<p>Syntax</p>
<div><pre class="hljs"><code>BF.MEXISTS<span class="hljs-built_in"> key</span> <span class="hljs-type">item</span> [<span class="hljs-type">item</span> ...]</code></pre></div>
<p>Time complexity:</p>
<p>O(k * n), where k is the number of hash functions and n is the number of items</p>
<h4 id="bfreserve">BF.RESERVE</h4>
<p>Syntax</p>
<div><pre class="hljs"><code>BF<span class="hljs-selector-class">.RESERVE</span> key error_rate capacity <span class="hljs-selector-attr">[EXPANSION expansion]</span>
  <span class="hljs-selector-attr">[NONSCALING]</span></code></pre></div>
<p>Time complexity:</p>
<p>O(1)</p>
<h4 id="bfscandump">BF.SCANDUMP</h4>
<p>Syntax</p>
<div><pre class="hljs"><code>BF.SCANDUMP <span class="hljs-keyword">key</span> <span class="hljs-keyword">iterator</span></code></pre></div>
<p>Time complexity:</p>
<p>O(n), where n is the capacity</p>
<h2 id="最佳实践">最佳实践</h2>
<p>布隆过滤器的工作原理是通过快速哈希函数运行项目并从该哈希中采样位，并在位字段中以特定间隔将它们从 0 设置为 1。为了检查布隆过滤器中是否存在，需要对相同的位进行采样。许多项目可能有重叠的位，但由于哈希函数产生唯一标识符，如果哈希中的单个位仍然是 0，那么我们知道它之前没有添加过。</p>
<p>布隆过滤器多年来一直通过客户端库与 Redis 一起使用，这些库利用 GETBIT 和 SETBIT 来处理键的位域。值得庆幸的是，从 Redis 4.0 开始，ReBloom 模块已经可用，它消除了任何 Bloom 过滤器实现开销。</p>
<p>布隆过滤器的一个很好的用例是检查已使用的用户名。在小范围内，这没有问题，但随着服务的增长，这可能会对数据库造成很大的负担。使用 ReBloom 实现这一点非常简单。</p>
<p>首先，让我们添加一些用户名作为测试：</p>
<div><pre class="hljs"><code><span class="hljs-meta">&gt;</span> <span class="language-javascript"><span class="hljs-variable constant_">BF</span>.<span class="hljs-property">ADD</span> usernames funnyfred</span>
(integer) 1
<span class="hljs-meta">&gt;</span> <span class="language-javascript"><span class="hljs-variable constant_">BF</span>.<span class="hljs-property">ADD</span> usernames fredisfunny</span>
(integer) 1
<span class="hljs-meta">&gt;</span> <span class="language-javascript"><span class="hljs-variable constant_">BF</span>.<span class="hljs-property">ADD</span> usernames fred</span>
(integer) 1
<span class="hljs-meta">&gt;</span> <span class="language-javascript"><span class="hljs-variable constant_">BF</span>.<span class="hljs-property">ADD</span> usernames funfred</span>
(integer) 1</code></pre></div>
<p>现在，让我们针对布隆过滤器运行一些测试。</p>
<div><pre class="hljs"><code><span class="hljs-meta">&gt;</span> <span class="language-javascript"><span class="hljs-variable constant_">BF</span>.<span class="hljs-property">EXISTS</span> usernames fred</span>
(integer) 1
<span class="hljs-meta">&gt;</span> <span class="language-javascript"><span class="hljs-variable constant_">BF</span>.<span class="hljs-property">EXISTS</span> usernames fred_is_funny</span>
(integer) 0</code></pre></div>
<p>正如预期的那样，fred_is_funny产生 0。响应为零表示我们可以确定此用户名未被使用。响应为 1 表示它可能已被使用。我们不能肯定地说，因为这可能是多个项目之间重叠位的情况。</p>
<p>通常，误报的几率很低，但非零。随着布隆过滤器“填满”，机会增加。您可以使用BF调整错误率和大小。保留命令。</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Redis Lua & Function(30%)]]></title>
            <guid>0f499408aed54dc280407983255e13f7</guid>
            <pubDate>Fri, 28 Oct 2022 00:16:37 GMT</pubDate>
            <content:encoded><![CDATA[<h2 id="介绍顺序">介绍顺序</h2>
<ul>
<li>怎么用Lua和Funciton？</li>
<li>Lua能做什么？</li>
<li>Redis如何和Lua配合的？</li>
<li>Redis中</li>
</ul>
<h2 id="redis和lua功能">Redis和Lua功能</h2>
<h3 id="在redis使用lua脚本的好处">在redis使用lua脚本的好处</h3>
<ul>
<li>减少网络开销。可以将多个请求通过脚本的形式一次发送，减少网络时延。</li>
<li>原子操作。Redis会将整个脚本作为一个整体执行，中间不会被其他请求插入。因此在脚本运行过程中无需担心会出现竞态条件，无需使用事务。</li>
<li>复用。客户端发送的脚本会永久存在redis中，这样其他客户端可以复用这一脚本，而不需要使用代码完成相同的逻辑。</li>
</ul>
<h3 id="在redis中使用lua脚本">在redis中使用lua脚本</h3>
<p>简单介绍一下lua的常见命令，命令不多，就下面这几个：</p>
<ul>
<li>EVAL</li>
<li>EVALSHA</li>
<li>SCRIPT LOAD - SCRIPT EXISTS</li>
<li>SCRIPT FLUSH</li>
<li>SCRIPT KILL</li>
</ul>
<h4 id="eval命令">EVAL命令</h4>
<div><pre class="hljs"><code>命令格式：EVAL script numkeys key <span class="hljs-selector-attr">[key …]</span> arg <span class="hljs-selector-attr">[arg …]</span></code></pre></div>
<ul>
<li>script参数是一段 Lua5.1 脚本程序。脚本不必(也不应该[^1])定义为一个 Lua 函数\</li>
<li>numkeys指定后续参数有几个key，即：key [key …]中key的个数。如没有key，则为0\</li>
<li>key [key …] 从 EVAL 的第三个参数开始算起，表示在脚本中所用到的那些 Redis 键(key)。在Lua脚本中通过KEYS[1], KEYS[2]获取。\</li>
<li>arg [arg …] 附加参数。在Lua脚本中通过ARGV[1],ARGV[2]获取。</li>
</ul>
<h5 id="错误处理">错误处理</h5>
<p>当 redis.call() 在执行命令的过程中发生错误时，脚本会停止执行，并返回一个脚本错误，错误的输出信息会说明错误造成的原因：</p>
<div><pre class="hljs"><code><span class="hljs-number">127.0.0.1:6379</span>&gt; lpush foo a
(integer) <span class="hljs-number">1</span>

<span class="hljs-number">127.0.0.1:6379</span>&gt; eval <span class="hljs-string">"return redis.call('get', 'foo')"</span> <span class="hljs-number">0</span>
(error) ERR Error running script (call to f_282297a0228f48cd3fc6a55de6316f31422f5d17): ERR Operation against a key holding the wrong kind of value</code></pre></div>
<p>和 redis.call() 不同， redis.pcall() 出错时并不引发(raise)错误，而是返回一个带 err 域的 Lua 表(table)，用于表示错误：</p>
<div><pre class="hljs"><code><span class="hljs-number">127.0.0.1:6379</span>&gt; EVAL <span class="hljs-string">"return redis.pcall('get', 'foo')"</span> <span class="hljs-number">0</span>
(error) ERR Operation against a key holding the wrong kind of value</code></pre></div>
<h4 id="script-load命令-和-evalsha命令">SCRIPT LOAD命令 和 EVALSHA命令</h4>
<div><pre class="hljs"><code>SCRIPT <span class="hljs-keyword">LOAD</span>命令格式：SCRIPT <span class="hljs-keyword">LOAD</span> script
EVALSHA命令格式：EVALSHA sha1 numkeys <span class="hljs-built_in">key</span> [<span class="hljs-built_in">key</span> …] arg [arg …]</code></pre></div>
<p>这两个命令放在一起讲的原因是：EVALSHA 命令中的sha1参数，就是SCRIPT LOAD 命令执行的结果。</p>
<p>SCRIPT LOAD 将脚本 script 添加到Redis服务器的脚本缓存中，并不立即执行这个脚本，而是会立即对输入的脚本进行求值。并返回给定脚本的 SHA1 校验和。如果给定的脚本已经在缓存里面了，那么不执行任何操作。</p>
<p>在脚本被加入到缓存之后，在任何客户端通过EVALSHA命令，可以使用脚本的 SHA1 校验和来调用这个脚本。脚本可以在缓存中保留无限长的时间，直到执行SCRIPT FLUSH为止。</p>
<div><pre class="hljs"><code>## SCRIPT LOAD加载脚本，并得到sha1值
<span class="hljs-number">127.0.0.1:6379</span>&gt; SCRIPT LOAD <span class="hljs-string">"redis.call('SET', KEYS[1], ARGV[1]);redis.call('EXPIRE', KEYS[1], ARGV[2]); return 1;"</span>
<span class="hljs-string">"6aeea4b3e96171ef835a78178fceadf1a5dbe345"</span>

## EVALSHA使用sha1值，并拼装和EVAL类似的numkeys和key数组、arg数组，调用脚本。
<span class="hljs-number">127.0.0.1:6379</span>&gt; EVALSHA 6aeea4b3e96171ef835a78178fceadf1a5dbe345 <span class="hljs-number">1</span> userAge <span class="hljs-number">10</span> <span class="hljs-number">60</span>
(integer) <span class="hljs-number">1</span>
<span class="hljs-number">127.0.0.1:6379</span>&gt; get userAge
<span class="hljs-string">"10"</span>
<span class="hljs-number">127.0.0.1:6379</span>&gt; ttl userAge
(integer) <span class="hljs-number">50</span></code></pre></div>
<h4 id="script-exists-命令">SCRIPT EXISTS 命令</h4>
<div><pre class="hljs"><code>命令格式：<span class="hljs-keyword">SCRIPT </span>EXISTS <span class="hljs-keyword">sha1 </span>[<span class="hljs-keyword">sha1 </span>…]</code></pre></div>
<p>作用：给定一个或多个脚本的 SHA1 校验和，返回一个包含 0 和 1 的列表，表示校验和所指定的脚本是否已经被保存在缓存当中</p>
<div><pre class="hljs"><code><span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; SCRIPT EXISTS <span class="hljs-number">6</span>aeea4b3e96171ef835a78178fceadf1a5dbe345
<span class="hljs-attribute">1</span>) (integer) <span class="hljs-number">1</span>
<span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; SCRIPT EXISTS <span class="hljs-number">6</span>aeea4b3e96171ef835a78178fceadf1a5dbe346
<span class="hljs-attribute">1</span>) (integer) <span class="hljs-number">0</span>
<span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; SCRIPT EXISTS <span class="hljs-number">6</span>aeea4b3e96171ef835a78178fceadf1a5dbe345 <span class="hljs-number">6</span>aeea4b3e96171ef835a78178fceadf1a5dbe366
<span class="hljs-attribute">1</span>) (integer) <span class="hljs-number">1</span>
<span class="hljs-attribute">2</span>) (integer) <span class="hljs-number">0</span></code></pre></div>
<h4 id="script-flush-命令">SCRIPT FLUSH 命令</h4>
<div><pre class="hljs"><code>命令格式：SCRIPT <span class="hljs-keyword">FLUSH</span></code></pre></div>
<p>作用：清除Redis服务端所有 Lua 脚本缓存</p>
<div><pre class="hljs"><code><span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; SCRIPT EXISTS <span class="hljs-number">6</span>aeea4b3e96171ef835a78178fceadf1a5dbe345
<span class="hljs-attribute">1</span>) (integer) <span class="hljs-number">1</span>
<span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; SCRIPT FLUSH
<span class="hljs-attribute">OK</span>
<span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; SCRIPT EXISTS <span class="hljs-number">6</span>aeea4b3e96171ef835a78178fceadf1a5dbe345
<span class="hljs-attribute">1</span>) (integer) <span class="hljs-number">0</span></code></pre></div>
<h4 id="script-kill-命令">SCRIPT KILL 命令</h4>
<div><pre class="hljs"><code>命令格式：SCRIPT <span class="hljs-keyword">FLUSH</span></code></pre></div>
<p>作用：杀死当前正在运行的 Lua 脚本，当且仅当这个脚本没有执行过任何写操作时，这个命令才生效。 这个命令主要用于终止运行时间过长的脚本，比如一个因为 BUG 而发生无限 loop 的脚本，诸如此类。</p>
<p>假如当前正在运行的脚本已经执行过写操作，那么即使执行SCRIPT KILL，也无法将它杀死，因为这是违反 Lua 脚本的原子性执行原则的。在这种情况下，唯一可行的办法是使用SHUTDOWN NOSAVE命令，通过停止整个 Redis 进程来停止脚本的运行，并防止不完整(half-written)的信息被写入数据库中。</p>
<h3 id="lua-脚本的问题">Lua 脚本的问题</h3>
<p>脚本必须完整的发送到服务端，虽然 Lua 脚本可以被缓存，但是可能随时丢失，比如：</p>
<ul>
<li>重启 Server</li>
<li>SCRIPT FLUSH</li>
<li>Fail over to replica</li>
</ul>
<p>脚本的设计理念是由应用端维护而不是 server，这又带来另一些问题：</p>
<ul>
<li>客户端必须维护所有的脚本，保证脚本的版本是最新的</li>
<li>脚本的缓存失效提高了 Transactions （MULTIEXECDISCARDWATCH）的失败率</li>
<li>增加了调试的难度</li>
<li>在 script 中不能调用其它 script，降低了可重用性、可维护性</li>
</ul>
<h2 id="redis和function功能">Redis和Function功能</h2>
<h3 id="数据模型">数据模型</h3>
<h3 id="命令介绍">命令介绍</h3>
<p>简单介绍一下function的常见命令，命令不多，就下面这几个：</p>
<ul>
<li>FCALL: 调用函数</li>
<li>FCALL_RO：调用只读函数</li>
<li>FUNCTION DELETE: 按名称删除函数</li>
<li>FUNCTION DUMP: 将所有函数转储到序列化的二进制负载中</li>
<li>FUNCTION FLUSH: 删除所有功能</li>
<li>FUNCTION KILL: 终止当前正在执行的函数。</li>
<li>FUNCTION LIST: 列出所有功能的信息</li>
<li>FUNCTION LOAD: 使用给定的参数（名称、代码、描述）创建函数</li>
<li>FUNCTION RESTORE: 恢复给定有效负载上的所有功能</li>
<li>FUNCTION STATS: 返回有关当前运行的函数的信息（名称、描述、持续时间）</li>
</ul>
<h4 id="function-load加载">FUNCTION LOAD加载</h4>
<div><pre class="hljs"><code>redis&gt; <span class="hljs-keyword">FUNCTION</span> <span class="hljs-keyword">LOAD</span> Lua mylib ""
(error) ERR <span class="hljs-keyword">No</span> <span class="hljs-keyword">functions</span> registered</code></pre></div>
<p>Lua 表示加载引擎，mylib 是库名，后面跟着源码，</p>
<p>每个库至少要有一个注册方法，注册方法是 redis.register_function() ，所以上述例子失败了。</p>
<p>以下是成功的示例：</p>
<div><pre class="hljs"><code>redis&gt; <span class="hljs-keyword">FUNCTION</span> <span class="hljs-title">LOAD</span> Lua mylib "redis.register_function('knockknock', <span class="hljs-keyword">function</span>() <span class="hljs-keyword">return</span> <span class="hljs-type">'Who\\'s</span> there?' <span class="hljs-keyword">end</span>)<span class="hljs-string">"
OK
redis&gt; FCALL knockknock 0
"</span>Who<span class="hljs-symbol">'s</span> there?<span class="hljs-string">"</span></code></pre></div>
<p>redis.register_function 的第一个参数是函数名，第二参数是回调方法。注意 FCALL 至少有两个参数，第二个参数是 key 的数量，和 eval 一样，用来区分后续的参数有多少个是 key。</p>
<p>你也可以通过文件的方式导入函数：</p>
<div><pre class="hljs"><code>$ <span class="hljs-keyword">cat</span> mylib.lua | redis-<span class="hljs-keyword">cli</span> -x FUNCTION LOAD Lua mylib <span class="hljs-keyword">REPLACE</span> DESCRIPTION <span class="hljs-string">"My application's Hash data type enhancements"</span></code></pre></div>
<p>如果需要查看加载的函数，可以通过 FUNCTION LIST 。</p>
<h2 id="lua原理">Lua原理</h2>
<p>lua的优点</p>
<ul>
<li>可移植性</li>
<li>容易嵌入</li>
<li>体积小</li>
<li>高效率</li>
</ul>
<p>这些优点都来自于lua的设计目标：简洁。从Scheme获得了很多灵感，包括匿名函数，合理的语义域概念</p>
<p><img src="/_resources/824b1641df8c4e3a9b8a927ad6a34be6.png" /></p>
<h2 id="redis的lua原理">Redis的Lua原理</h2>
<h2 id="参考文献">参考文献</h2>
<p><a title="https://www.51cto.com/article/286631.html" href="https://www.51cto.com/article/286631.html">详解关于Lua源码分析学习教程-51CTO.COM</a></p>
]]></content:encoded>
        </item>
    </channel>
</rss>