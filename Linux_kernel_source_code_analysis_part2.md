# 存储管理

## Linux 内存管理框架

通过页面目录和页面表分为2个层次实现线性地址到物理地址的映射。但这类设计只能针对32位操作系统，因为每个页面大小为4k。

于是针对当前情况，linux设计了3层结构：PGD,PMD,PT。
而PTE是page table entry，表项结构体。PT是PTE的大数组，PMD和PGD则是PT的映射表。

![](2020-1-12-22-46-27.jpg)

虚拟Linux内存管理通过四部完成地址转换：
1. 用线性地址的最高一个位段从PGD找到对应PMD表项
2. 第二个位段从PMD中找到对应PT表项
3. 第三个位段从PT中找到对应的PTE，指向物理页面的指针
4. 线性地址中最后位段为相对偏移量

这其中有个重点问题，在cpu和mmu的机制中，只存在2层模型，所以需要将三层映射支持两层结构中。同时在后期Intel中引入了PAE扩充功能，允许地址宽度提高至36位，在硬件方面支持了三层映射模型。

三层模型支持两层模型流程：
1. 内核为MMU设置好映射的PGD，通过位段找到对应的中间目录
2. 而PMD设置为0，所以PGD直接映射到PT中。
3. MMU找到PT目录中找到对应的PTE
4. 最终和偏移量进行组合得到物理地址

![虚拟地址、线性地址、物理地址的关系](2020-1-12-23-50-09.jpg)

GDT和LDT，2者名字分别为全局段描述符和局部段描述符。

GDT的容量有多大？GDT位段总共13位，共计8192个描述项，而每个进程存在2个表项，所以，理论上系统最大进程数为4090

然后，每个描述表项含有段的基地址和段的大小，再加上其他一些信息，共计8个字节。
```
typedef struct {
 unsigned int base24_31:8; /* 基地址的高8位 */
 unsigned int g:1;  
 unsigned int d_b:1;  
 unsigned int unused:1; 
 unsigned int avl:1;    
 unsigned int seg_limit_16_19:4;     /* 段长度的高4位 */
 unsigned int p:1;  
 unsigned int dpl:2;  
 unsigned int s:1;  
 unsigned int type:4; 
 unsigned int base_0_23:24; /* 基地址的低24位 */
 unsigned int seg_limit_0_15:16; /* 段长度的低16位 */
} 
```

所以每个描述符包含了32位的地址。

在Linux中，所有地址映射都使用GDT，最后2个位段标识权限，倒数第三个位段标识是否为GDT。

段描述符表分为三类：全局描述符表GDT，局部描述符表LDT和中断描述符表IDT

当 TI=0时表示段描述符在GDT中，如下图所示：
1. 先从GDTR寄存器中获得GDT基址。
2. 然后再GDT中以段选择符高13位位置索引值得到段描述符。
3. 段描述符符包含段的基址、限长、优先级等各种属性，这就得到了段的起始地址（基址），再以基址加上偏移地址yyyyyyyy才得到最后的线性地址。

![](2020-1-14-02-05-42.jpg)

当TI=1时表示段描述符在LDT中，如下图所示：
1. 还是先从GDTR寄存器中获得GDT基址。
2. 从LDTR寄存器中获取LDT所在段的位置索引(LDTR高13位)。
3. 以这个位置索引在GDT中得到LDT段描述符从而得到LDT段基址。
4. 用段选择符高13位位置索引值从LDT段中得到段描述符。
5. 段描述符符包含段的基址、限长、优先级等各种属性，这就得到了段的起始地址（基址），再以基址加上偏移地址yyyyyyyy才得到最后的线性地址。

![](2020-1-14-02-06-03.jpg)

所以，在通过GDT后，会得到逻辑地址，而由于Linux本身将基地址设置为0，所以虚拟地址和逻辑地址是一样的。

获取到逻辑地址后，MMU会通过CR3寄存器获取到PGD的信息，开始页表查询。

MMU最初以10,10,12作为位段，4K为一页，而每个表项是4字节，所以，1024个表项，正好就是4K。

![](2020-1-14-02-32-11.jpg)

4字节主要存储的是下一个页表的基地址，以及相关页表的描述信息。具体的映射关系如下：
1. 从CR3中取得页面目录的基地址
2. 以线性地址中的dir位段作为下标，获得对应的页表描述项
3. 以线性地址的page位段为下标，得到页面描述项
4. 将页面描述项的页面基地址与线性地址的偏移量相加得到物理地址

为何是使用20位作为基地址？由于2^12正好为4096个字节=4k大小，所以，正好是一个页描述符的基地址。



## 地址映射过程

## 重要数据结构、函数

## 越界访问

## 用户堆栈管理

## 物理内存的使用和周转

## 页面的周转

## 内存缓冲区的管理

## 外部设备的地址映射

## 系统调用-brk和mmap


## 相关链接
1. [PAE 分页模式详解](https://www.cnblogs.com/ck1020/p/6078214.html)