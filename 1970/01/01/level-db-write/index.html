<!doctype html>
<html lang="en">
    <head>
		
        <meta http-equiv="Content-Type" content="text/html" charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="description" content="">
        <link rel="shortcut icon" href="/asset/guolin.png"/>
        <link rel="canonical" href="http://guolinn.com/">
        <link rel="alternate" type="application/rss+xml" title="Skyfire Lee" href="/atom.xml">
        <title>浅析levelDB流程（写流程） | Artikell</title>
        <meta name="description" content="{{meta_description}}">

        <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
        <link rel="stylesheet" type="text/css" href="/styles/crisp.css">
        <meta name="HandheldFriendly" content="True" />
        <meta name="MobileOptimized" content="320" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->

    <meta name="generator" content="Hexo 4.2.1"></head>
    
		<body class="post-template">
	

        <header id="header">
            <a id="logo" href="/"><img src="/asset/guolin.png" alt="Artikell" /></a>
            <h1><a href="/">Skyfire Lee</a></h1>
            <p></p>
            <div id="follow-icons">
                  <a href="/atom.xml"><i class="fa fa-rss-square fa-2x"></i></a>
  </div>
<h6><a href="/about">About</a></h6>
        </header>

        <main id="content">
        

<article class="post">
  一月 1, 1970
  

  <h1 class="post-title">浅析levelDB流程（写流程）</h1>
  <section class="post-content article-entry">
    <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>打开流程完成了整个db的初始化，而后就是整个level对比的存储流程，如何读写db是核心业务。当然读写自然会触发压缩流程，但本文单纯只会串联整个的读写过程，保证内容的简洁，至于压缩则另开一篇详解。</p>
<h2 id="写流程"><a href="#写流程" class="headerlink" title="写流程"></a>写流程</h2><h3 id="命令封装"><a href="#命令封装" class="headerlink" title="命令封装"></a>命令封装</h3><p>之前文章中，我们有提过更新的2个操作，在最后底层其实是一个操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func (db *DB) Put(key, value []byte, wo *opt.WriteOptions) error &#123;</span><br><span class="line">	return db.putRec(keyTypeVal, key, value, wo)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (db *DB) Delete(key []byte, wo *opt.WriteOptions) error &#123;</span><br><span class="line">	return db.putRec(keyTypeDel, key, nil, wo)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，在<code>Put</code>和<code>Delete</code>命令中，最终会直接调用<code>putRec</code>方法，而在此方法中，做的核心逻辑就是，抢锁，并等待信息，其中抢锁的逻辑还是由<code>channel</code>实现，逻辑后续再理，先了解一下写入流程<code>writeLocked</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">batch :&#x3D; db.batchPool.Get().(*Batch)</span><br><span class="line">batch.Reset()</span><br><span class="line">batch.appendRec(kt, key, value)</span><br><span class="line">return db.writeLocked(batch, batch, merge, sync)</span><br></pre></td></tr></table></figure>
<p>调用该方法后，则就是AOF写入以及落入<code>memdb</code>跳表数据库中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Seq number.</span><br><span class="line">seq :&#x3D; db.seq + 1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Write journal.</span><br><span class="line">if err :&#x3D; db.writeJournal(batches, seq, sync); err !&#x3D; nil &#123;</span><br><span class="line">	db.unlockWrite(overflow, merged, err)</span><br><span class="line">	return err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Put batches.</span><br><span class="line">for _, batch :&#x3D; range batches &#123;</span><br><span class="line">	if err :&#x3D; batch.putMem(seq, mdb.DB); err !&#x3D; nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">	seq +&#x3D; uint64(batch.Len())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，数据已经落入存储中，并返回告知请求处理正常。那么，这一套流程，中间还存在哪些问题呢？<br>其中提高吞吐、提高内存空间利用率则是中间的优化点。</p>
<h3 id="合并写"><a href="#合并写" class="headerlink" title="合并写"></a>合并写</h3><p>关于吞吐量的计算逻辑可以参考：<a href="https://zhuanlan.zhihu.com/p/337708438" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/337708438</a></p>
<p>由于本身leveldb会写入内存，所以中间存在锁的抢占，而在golang中，leveldb使用的是channel进行锁争抢，当你能写入writeLockC管道时，便可以继续写入操作。然而，锁的争抢必定会导致性能下降，那么，合并写就成为了提供性能的一个解决方案。</p>
<p>合并锁的逻辑就是，优先尝试写入writeMergeC管道中，如果写入成功，则等待合并写的结果返回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">case db.writeMergeC &lt;- writeMerge&#123;sync: sync, keyType: kt, key: key, value: value&#125;:</span><br><span class="line">    if &lt;-db.writeMergedC &#123;</span><br><span class="line">        &#x2F;&#x2F; Write is merged.</span><br><span class="line">        return &lt;-db.writeAckC</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; Write is not merged, the write lock is handed to us. Continue.</span><br><span class="line">case db.writeLockC &lt;- struct&#123;&#125;&#123;&#125;:</span><br><span class="line">    &#x2F;&#x2F; Write lock acquired.</span><br><span class="line">case err :&#x3D; &lt;-db.compPerErrC:</span><br><span class="line">    &#x2F;&#x2F; Compaction error.</span><br><span class="line">    return err</span><br><span class="line">case &lt;-db.closeC:</span><br><span class="line">    &#x2F;&#x2F; Closed</span><br><span class="line">    return ErrClosed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而如果合并锁写入不成功，则尝试去抢写入锁，如果当前写入锁还是没有释放，那其中有可能导致异常出现（猜测）。<br>而在抢到写入锁的协程中，则会不断的等待合并写的请求达到上限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">merge: </span><br><span class="line"></span><br><span class="line">for mergeLimit &gt; 0 &#123;</span><br><span class="line">    select &#123;</span><br><span class="line">    case incoming :&#x3D; &lt;-db.writeMergeC:</span><br><span class="line">        ... ...</span><br><span class="line">    default:</span><br><span class="line">        break merge</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此可见，当一次写入异常时，常常会阻塞所有的合并写异常，所有，合并写其实是针对大数据量的变更。</p>
<p>当然，如果处理完成后，则会写入writeAckC管道告知等待的写入，但是如果此次合并写并没有写入完成写入，则会使其抢锁成功，并自身去进行写入，这块逻辑便是之前的writeMergeC和writeLockC逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func (db *DB) unlockWrite(overflow bool, merged int, err error) &#123;</span><br><span class="line">	for i :&#x3D; 0; i &lt; merged; i++ &#123;</span><br><span class="line">		db.writeAckC &lt;- err</span><br><span class="line">	&#125;</span><br><span class="line">	if overflow &#123;</span><br><span class="line">		&#x2F;&#x2F; Pass lock to the next write (that failed to merge).</span><br><span class="line">		db.writeMergedC &lt;- false</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		&#x2F;&#x2F; Release lock.</span><br><span class="line">		&lt;-db.writeLockC</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


  </section>
  <footer class="post-footer">
    <!--
    <section class="author">
      <h4>Skyfire Lee</h4>
      <p></p>
    </section>
    -->
  </footer>
</article>

<nav class="pagination" role="pagination">
    
    <a class="newer-posts" href="/1970/01/01/level-db-file/">
        ← prev <!--浅析levelDB文件格式-->
    </a>
    
    <span class="page-number">•</span>
    
    <a class="older-posts" href="/1970/01/01/level-db-read/">
        <!--浅析levelDB流程（读流程）--> next →
    </a>
    
</nav>


        </main>
        <footer id="footer">
            <section id="footer-message">&copy; 2022 Skyfire Lee. All rights reserved. Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. <a href="https://github.com/guolin/crisp-hexo-theme" target="_blank">crisp</a> theme by <a href="guolin.github.io" target="_blank">Guo Lin</a>.</section>
        </footer>
    </body>
</html>


