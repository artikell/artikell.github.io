---
title: 浅析levelDB流程（读流程）
---

## 前言

前文描述完写流程，此时就需要描述一下大体的数据读取流程。

## 命令封装

读取的时候，由于是kv数据库，当然只会有一个参数，那就是key的值，同时还有一个读取时的选型，当前是包含是否读取缓存、是否严格查询。两者含义挖坑之后再填

同时，在得到key的数据后，为了避免读写冲突，所以会在db层面生成一个快照，保证读取的数据不会被后来的写入所影响，这也是变现的实现了一下可重复读？

而具体的快照，则只是当前数据库中的唯一递增序号。这也避免了在读取时，数据被销毁，导致数据丢失。

进入读取方法后，leveldb还会将读取命令生成一个internalKey对象，其中包含`key`、`seq`、`keyType`三个属性。


## 读取MEM流程

`get`方法里面，还支持传入memDB和tFile对象，目的是支持事务操作，这块逻辑暂不考虑。

拿到数据后，则优先从`memDB`中获取数据，当然，在leveldb中，memDB一直存在2个：`mem`和`frozenMem`。在读取时，为了避免内存变更，则将2者进行引用增加。

获取到memDB后,则直接从跳表中获取,如果获取到后，则直接返回，此时，引用并没有清理，且引用清理时机过长，完全可能导致引用一直不释放。

## 读取FILE流程

file中，则涉及到version的概念，因为之前讲过，version中保存了整个leveldb的文件信息，所以，在数据读取时，还是需要保证version不会被销毁，同理还是增加引用。

其次则就会传入key信息，此时，则需要对leveldb每一次文件进行遍历。

第一遍历level0文件，全部遍历，第二则遍历levle0+的文件，则只需要对比最大key信息即可，



