---
title: 关于JVM的垃圾收集（2）
---

关于垃圾收集，上文已经提到了2类算法：引用计数、可达性计算。而针对可达性算法，为了提高垃圾收集效率，将内存分为新生代和老年代，并演化出3类假说：大部分对象朝生夕灭、熬过多次的垃圾收集越难消亡、跨代引用相对于同代引用是极少的。

在这些基础上，java本身也会对gc进行分类处理，而非每次都是全内存进行垃圾清理。其中的分类为Minor GC、Major GC，分别为新生代GC和老年代GC，Mixed GC，表示对新生代和部分老年代的GC、Full GC，收集整个Java堆和方法区的垃圾。

而在不同的GC阶段，自然也有不同的实现方式

## 标记清理算法

所谓标记清理当然分为标记和清理2个阶段：标记出所有需要收集的对象，而后统一进行回收。标记阶段负责判断垃圾，而清理阶段则直接处理相关垃圾对象。

该方法的实际实现便是Golang中的三色标记。其主要确定在于执行效率不稳定，若存在大量对象，且大部分对象都需要回溯，则需要进行大规模的标记和清理动作，其次是内存空间碎片化问题，标记清理会导致大量的空间碎片，而当分配大对象时找不到足够的连续内存，则会提前触发下一次垃圾回收。

## 标记复制算法

为了解决标记清理算法面对大量可回收对象时执行效率低的问题，便产生出了半区复制的GC算法。原理是将可用内存按容量划分为大小相等的两块，每次只使用其中一块，当一块用完后将存活的对象复制到另外一块上面。而后再直接将旧有的一半空间清理。

这类算法缺点则是会产生大量的内存间复制的开销，同时空间浪费相对比较严重。而在IBM公司的实验中发现，新生代98%的对象都熬不过第一轮收集，那也可以佐证并不需要进行半区1：1的空间分配。

于是也就产生了经典的8：1：1的分区关系，划分为Eden（8）、Survivor0（1）、Survivor1（1），在对象申请时，只使用Eden+Survivor0区域，而当进行GC时，就将对象复制到Survivor1区域，并直接清空内存。这样只有10%的空间会浪费，同时，当存活的对象大于10%，那就需要启用老年代空间来存放对象。

## 标记整理算法

标记复制算法的问题则是在存活对象过多的情况下，需要进行较多的对象复制操作，效率极低。同时，如果出现100%的对象存活，那还需要额外的空间来保证算法稳定。那针对老年代的对象特征，那就是需要新的一类算法来保证空间的利用率。

而标记整理便是当前的实际算法，这算法与标记清理的差异在于，前者在回收后需要对存活的对象进行移动。

移动对象的确定在于，需要小心的维护对象的连接关系，保证在移动的过程中，不会直接导致进程崩坏。而如果不进行整理，那么空间碎片化会导致需要类似的内存分配器和访问器来解决。

是否移动对象在实践中都存在利弊，那考虑整体老年代的特征而言，并不需要频繁的GC，更多的是空间利用率的提升，那选择移动对象那必然是较优的选择。