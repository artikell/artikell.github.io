<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Start Again</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Start Again">
<meta property="og:url" content="http://artikell.github.io/index.html">
<meta property="og:site_name" content="Start Again">
<meta property="og:locale" content="zh">
<meta property="article:author" content="Skyfire Lee">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Start Again" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Start Again</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://artikell.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-golang-lockg" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/12/golang-lockg/" class="article-date">
  <time datetime="2020-07-12T15:51:41.000Z" itemprop="datePublished">2020-07-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/12/golang-lockg/">Golang-Lockg学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://artikell.github.io/2020/07/12/golang-lockg/" data-id="ckcj99t5i00001xuy3djah5w5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-golang-dispatch" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/08/golang-dispatch/" class="article-date">
  <time datetime="2020-07-08T07:38:21.000Z" itemprop="datePublished">2020-07-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/08/golang-dispatch/">Golang调度讲解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Golang调度是runtime中的核心部分，要说涉及到的东西，从基本的线程协程切换、GC的STW，到锁的暂停，都有相关涉猎。今天请个假休息一下，有空整理整理最近看的调度知识。</p>
<h2 id="调度基本知识"><a href="#调度基本知识" class="headerlink" title="调度基本知识"></a>调度基本知识</h2><h3 id="进程、线程和协程"><a href="#进程、线程和协程" class="headerlink" title="进程、线程和协程"></a>进程、线程和协程</h3><p>进程和线程的区别都不用说了，简单来说就是，最初，大佬们觉得，每个任务肯定都有独立的内存空间、句柄等等等。只要保证程序直接能够不互相干扰就行。</p>
<p>当机器性能不断的提升，程序员们发现，我任务太多了，需要执行很久，但是并不需要那么多的空间。如果照原来的方法每个任务都分配空间就特别耗时和耗资源，于是决定在进程的基础上拆分出线程，你只负责执行任务就行了。</p>
<p>按道理，线程已经足够轻量，大数据时代又来了。现在需要大量的碎片计算，就像请求一个hello world，执行的任务不耗时，但是频繁。这时候的线程切换就是一个问题，主要原因是，线程的切换需要切换至操作系统的内核态，不断地做内存的复制，页表的cache很容易就失效，耗时因此增加。</p>
<p>程序员再次想起，只要尽可能的不做内核态的切换，就可以减少这样的风险。于是出现了用户态的线程，也就是协程。</p>
<h3 id="并发模型"><a href="#并发模型" class="headerlink" title="并发模型"></a>并发模型</h3><p>大家在学习Golang源码中可以顺便思考一下，为什么是GMP模型？这就引出《七周七并发模型》书中的其他的并发模型：</p>
<ul>
<li>通过无变量的函数式编程实现并发，是无锁并发的一种模型；</li>
<li>Clojure对于状态和标识的分离，可以轻松实现内存事务模型；</li>
<li>Erlang的Actor模型是容错性非常高的分布式并发模型；</li>
<li>CSP模型是另一种分布式并发模型，被Go和Clojure采用；</li>
<li>GPU的并行计算主要针对数据密集型计算的并行，搞游戏的一定要看；</li>
<li>Hadoop和Storm分别适合超大数据量的批处理和流式处理。</li>
</ul>
<p>CSP（Communicating Sequential Processes）是由Tony Hoare在1978的论文上首次提出的。 它是处理并发编程的一种设计模式或者模型，指导并发程序的设计，提供了一种并发程序可实践的组织方法或者设计范式。通过此方法，可以减少并发程序引入的其它缺点，减少和规避并发程序的常见缺点和bug，并且可以被数学理论所论证。</p>
<blockquote>
<p>经典名言：Do not communicate by sharing memory; instead, share memory by communicating</p>
</blockquote>
<p>该模型主要的最终实现在于golang中的channel和goroutine。</p>
<h3 id="GMP模型"><a href="#GMP模型" class="headerlink" title="GMP模型"></a>GMP模型</h3><p>在golang实现之前，其实解决线程切换开销大的问题可能有各种各样的方式。nginx中通过epollo来进行事件管理，还有python中的yield进行用户态的手动切换。这些都属于非抢占式的，核心问题就是如果中间出现过量的超时操作，很容易就会导致进程阻塞。</p>
<p>而golang的GMP模型中参考操作系统中的线程切换制作了sysmon线程用于做协程的抢占操作。</p>
<p>在GMP模型特殊之处也是在于中间P层的存在，在1.1之前，是不存在P层。这就导致了，G其实是挂载在全局的链表中。每次切换协程都会抢占一个全局锁，于是给GM中增加了一个P层。</p>
<h3 id="特殊的线程、协程"><a href="#特殊的线程、协程" class="headerlink" title="特殊的线程、协程"></a>特殊的线程、协程</h3><p>在golang中，存在2个特殊的线程：sysmon、templateThread。前者主要用于实现golang的抢占式调度，后者则是作为fork线程时使用的模板线程。</p>
<p>同时还存在一个特殊的协程：signalG，功能也就是用于接收进程的信号。</p>
<p>这3者可以单独讲解。本文主要讲解整体的正常线程调度流程。</p>
<h2 id="进程启动"><a href="#进程启动" class="headerlink" title="进程启动"></a>进程启动</h2><h3 id="最初的入口和空间"><a href="#最初的入口和空间" class="headerlink" title="最初的入口和空间"></a>最初的入口和空间</h3><p>首先，golang的启动入口rt0_go（asm_arm64.s文件）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">	MOVW	R0, 8(RSP) &#x2F;&#x2F; argc</span><br><span class="line">	MOVD	R1, 16(RSP) &#x2F;&#x2F; argv</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; create istack out of the given (operating system) stack.</span><br><span class="line">	&#x2F;&#x2F; _cgo_init may update stackguard.</span><br><span class="line">	MOVD	$runtime·g0(SB), g</span><br><span class="line">	MOVD	RSP, R7</span><br><span class="line">	MOVD	$(-64*1024)(R7), R0</span><br><span class="line">	MOVD	R0, g_stackguard0(g)</span><br><span class="line">	MOVD	R0, g_stackguard1(g)</span><br><span class="line">	MOVD	R0, (g_stack+stack_lo)(g)</span><br><span class="line">	MOVD	R7, (g_stack+stack_hi)(g)</span><br><span class="line"></span><br><span class="line">    ... ...</span><br><span class="line">nocgo:</span><br><span class="line">	BL	runtime·save_g(SB)</span><br><span class="line">	&#x2F;&#x2F; update stackguard after _cgo_init</span><br><span class="line">	MOVD	(g_stack+stack_lo)(g), R0</span><br><span class="line">	ADD	$const__StackGuard, R0</span><br><span class="line">	MOVD	R0, g_stackguard0(g)</span><br><span class="line">	MOVD	R0, g_stackguard1(g)</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; set the per-goroutine and per-mach &quot;registers&quot;</span><br><span class="line">	MOVD	$runtime·m0(SB), R0</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; save m-&gt;g0 &#x3D; g0</span><br><span class="line">	MOVD	g, m_g0(R0)</span><br><span class="line">	&#x2F;&#x2F; save m0 to g0-&gt;m</span><br><span class="line">	MOVD	R0, g_m(g)</span><br><span class="line"></span><br><span class="line">	MOVW	8(RSP), R0	&#x2F;&#x2F; copy argc</span><br><span class="line">	MOVW	R0, -8(RSP)</span><br><span class="line">	MOVD	16(RSP), R0		&#x2F;&#x2F; copy argv</span><br><span class="line">	MOVD	R0, 0(RSP)</span><br></pre></td></tr></table></figure>

<p>这段汇编其实不用特别讨论，主要做的就是初始化的一个流程：  </p>
<ol>
<li>赋值stack.lo和stack.hi属性</li>
<li>保存g0对象</li>
<li>设置m对象，包括m-&gt;g0、g0-&gt;m，做一个m0和g0的绑定</li>
<li>复制argc和argv</li>
</ol>
<p>以上基本上就是一些属性的赋值，后续就是执行了一系列的初始化函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BL	runtime·args(SB)</span><br><span class="line">BL	runtime·osinit(SB)</span><br><span class="line">BL	runtime·schedinit(SB)</span><br></pre></td></tr></table></figure>

<p>这3个函数，不是特别影响调度流程，具体功能主要是对一些功能进行初始化，例如内存管理、信号、mp链表、GC等功能的初始化。</p>
<p>在以上部分，现在基本上只存在一个m0代表主线程，一个g0代表主线程中的g0空间，还要一个signalG空间（并不在执行链表中），同时初始化了maxprocs个p，且在m0上面挂载了一个p对象。这时候，需要开始执行main函数，则需要一个新的g来执行方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MOVD	$runtime·mainPC(SB), R0		&#x2F;&#x2F; entry</span><br><span class="line">MOVD	RSP, R7</span><br><span class="line">MOVD.W	$0, -8(R7)</span><br><span class="line">MOVD.W	R0, -8(R7)</span><br><span class="line">MOVD.W	$0, -8(R7)</span><br><span class="line">MOVD.W	$0, -8(R7)</span><br><span class="line">MOVD	R7, RSP</span><br><span class="line">BL	runtime·newproc(SB)</span><br></pre></td></tr></table></figure>

<p><code>newproc</code>方法会将<code>runtime.main</code>函数作为入参传入，功能等同于<code>go runtime.main()</code>。而<code>newproc</code>方法具体功能主要就是创建一个g并插入当前的p中。</p>
<p>到这一步为止，整个进程还是只存在一个线程，但是存在3个g：g0、signalG、mainG。之后，就开始执行一个调度流程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BL	runtime·mstart(SB)</span><br></pre></td></tr></table></figure>

<h3 id="调度启动流程"><a href="#调度启动流程" class="headerlink" title="调度启动流程"></a>调度启动流程</h3><p>这是每个线程进入循环的入口。为什么这么说，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func newosproc(mp *m) &#123;</span><br><span class="line">	... ...</span><br><span class="line">	ret :&#x3D; clone(cloneFlags, stk, unsafe.Pointer(mp), unsafe.Pointer(mp.g0), unsafe.Pointer(funcPC(mstart)))</span><br></pre></td></tr></table></figure>
<p>这就是创建一个线程的代码，印象中的线程创建是<code>thread_create</code>方法，底层最后还是调用的<code>clone</code>方法<a href="https://linux.die.net/man/2/clone" target="_blank" rel="noopener">参考</a>，所有golang自行封装了一个方法。而这个调用的最后一个方法就是<code>mstart</code>方法。</p>
<p>进入<code>mstart</code>方法后，核心功能具体可以分为4部分：  </p>
<ol>
<li>osStack的判断</li>
<li>stackguard的赋值</li>
<li>mstart1的调用</li>
<li>mexit方法，m的退出函数</li>
</ol>
<p>首先，先确定stackguard的功能，通过汇编指令，我们可以看到每个函数中都能有一段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TEXT runtime.main(SB) &#x2F;opt&#x2F;go&#x2F;src&#x2F;runtime&#x2F;proc.go</span><br><span class="line">        proc.go:113             0x430690        64488b0c25f8ffffff      mov rcx, qword ptr fs:[0xfffffff8]</span><br><span class="line">        proc.go:113             0x430699        483b6110                cmp rsp, qword ptr [rcx+0x10]</span><br><span class="line">        proc.go:113             0x43069d        0f86f9020000            jbe 0x43099c</span><br><span class="line">&#x3D;&gt;      proc.go:113             0x4306a3*       4883ec50                sub rsp, 0x50</span><br><span class="line">        ... ...</span><br><span class="line">        proc.go:113             0x43099c        e86f8b0200              call $runtime.morestack_noctxt</span><br><span class="line">        &lt;autogenerated&gt;:1       0x4309a1        e9eafcffff              jmp $runtime.main</span><br></pre></td></tr></table></figure>
<p>第一行和第二行的具体功能分别是从TLS中获取当前的g对象、得到stackguard属性值。<br>这一整段的代码也就是表示如果当前的rsp比stackguard小的话，就认为是需要进行栈扩展。具体的值，也就是stack.lo+_StackGuard(896)。这一段就不具体叙述。</p>
<p>第二个问题是为什么要判断osStack？这就是要知道什么情况下会出现osStack，也就是系统栈空间。核心代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func allocm(_p_ *p, fn func()) *m &#123;</span><br><span class="line">    ... ...</span><br><span class="line">	if iscgo || GOOS &#x3D;&#x3D; &quot;solaris&quot; || GOOS &#x3D;&#x3D; &quot;illumos&quot; || GOOS &#x3D;&#x3D; &quot;windows&quot; || GOOS &#x3D;&#x3D; &quot;plan9&quot; || GOOS &#x3D;&#x3D; &quot;darwin&quot; &#123;</span><br><span class="line">		mp.g0 &#x3D; malg(-1)</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		mp.g0 &#x3D; malg(8192 * sys.StackGuardMultiplier)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>主要是当创建m的时候，m里面的g0的栈根据不同的系统或者cgo会创建系统的栈空间，否则就会使用heap中的空间。而在<code>mstart</code>方法中，判断是否为osStack，主要是需要判断，当前的栈是否可复用，如果是操作系统自动分配的栈是不在heap中的，无法回收管理，所以直接释放，若是在heap中，则需要进行回收操作。</p>
<p>而<code>mexit</code>函数，功能主要也是做一系列的变量释放、回收操作。后续会引出相关功能。</p>
<p>之后，方法会进入<code>mstart1</code>函数中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">func mstart1() &#123;</span><br><span class="line">	_g_ :&#x3D; getg()</span><br><span class="line"></span><br><span class="line">	if _g_ !&#x3D; _g_.m.g0 &#123;</span><br><span class="line">		throw(&quot;bad runtime·mstart&quot;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	save(getcallerpc(), getcallersp())</span><br><span class="line">	asminit()</span><br><span class="line">	minit()</span><br><span class="line"></span><br><span class="line">	if _g_.m &#x3D;&#x3D; &amp;m0 &#123;</span><br><span class="line">		mstartm0()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if fn :&#x3D; _g_.m.mstartfn; fn !&#x3D; nil &#123;</span><br><span class="line">		fn()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if _g_.m !&#x3D; &amp;m0 &#123;</span><br><span class="line">		acquirep(_g_.m.nextp.ptr())</span><br><span class="line">		_g_.m.nextp &#x3D; 0</span><br><span class="line">	&#125;</span><br><span class="line">	schedule()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，当前方法保存了上一个函数的pc和sp地址，功能也就是为了调用mexit方法，这里不做叙述。再之后就是2个初始化方法，<code>asminit</code>方法，在大部分操作系统中是没有函数体的，而<code>minit</code>函数中，具体做的事情是信号的初始化，也就是每个m都有自己的一个信号栈。这一部分不在此次学习范围内。</p>
<p>而后续的<code>mstartm0</code>函数，功能具体描述大致有2部分：创建扩展的线程、初始化信号回调方法。俩者也就是只会在m0上面执行一次，不在调度功能内，暂时不做过多介绍。</p>
<blockquote>
<p>问：扩展线程的功能是干嘛的？</p>
</blockquote>
<p>再之后就会有<code>mstartfn</code>函数的执行，这一个函数具体会存在3种情况：sysmon抢占线程、templateThread模板线程、mspinning自旋方法。前2者在前面也提到过是2个特殊的线程，进入后便会不断的轮询等待。后者的自旋只是对当前的m做了一个自旋的标记。</p>
<p>而后，针对非m0的m要进行一个p的绑定，m0为啥不需要呢？当然是因为m0在之前就已经绑定好了。</p>
<h3 id="开始调度循环"><a href="#开始调度循环" class="headerlink" title="开始调度循环"></a>开始调度循环</h3><p>题目是调度循环，而代码中其实是没有一个for循环，最后的逻辑是进入了一个execute方法，那具体是如何实现循环？</p>
<p>循环具体涉及到了几个函数的循环：<code>schedule-&gt;execute-&gt;goexit-&gt;goexit1-&gt;goexit0-&gt;schedule</code></p>
<h4 id="Schedule函数"><a href="#Schedule函数" class="headerlink" title="Schedule函数"></a>Schedule函数</h4><p>函数的第一段逻辑，主要会判断当前m是否存在绑定的g，如果存在，则暂停当前m，而后执行<code>lockedg</code>。Why？这一段不是主流程，稍后再看。</p>
<blockquote>
<p>什么情况下会从暂停m？</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if _g_.m.lockedg !&#x3D; 0 &#123;</span><br><span class="line">	stoplockedm()</span><br><span class="line">	execute(_g_.m.lockedg.ptr(), false) &#x2F;&#x2F; Never returns.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后就是<code>gcwaiting</code>变量的判断，该变量不为0的情况主要是在GC的STW阶段。如果是STW阶段，则会暂停当前的m，等到startTheWorld时，会将所有的p唤醒。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if sched.gcwaiting !&#x3D; 0 &#123;</span><br><span class="line">	gcstopm()</span><br><span class="line">	goto top</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面就是<code>runSafePointFn</code>这个名字，主要功能就是在GC前，需要打开所有的p读写屏障。而这个逻辑，就是简单的需要保证每个P都需要执行一遍。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if pp.runSafePointFn !&#x3D; 0 &#123;</span><br><span class="line">	runSafePointFn()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再之后就是执行当前p上挂载的定时器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">checkTimers(pp, 0)</span><br></pre></td></tr></table></figure>

<p>上述都是一些m特殊的处理流程，等处理完后，就需要开始寻找g来进行执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if gp &#x3D;&#x3D; nil &amp;&amp; gcBlackenEnabled !&#x3D; 0 &#123;</span><br><span class="line">	gp &#x3D; gcController.findRunnableGCWorker(_g_.m.p.ptr())</span><br><span class="line">	tryWakeP &#x3D; tryWakeP || gp !&#x3D; nil</span><br><span class="line">&#125;</span><br><span class="line">if gp &#x3D;&#x3D; nil &#123;</span><br><span class="line">	if _g_.m.p.ptr().schedtick%61 &#x3D;&#x3D; 0 &amp;&amp; sched.runqsize &gt; 0 &#123;</span><br><span class="line">		lock(&amp;sched.lock)</span><br><span class="line">		gp &#x3D; globrunqget(_g_.m.p.ptr(), 1)</span><br><span class="line">		unlock(&amp;sched.lock)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">if gp &#x3D;&#x3D; nil &#123;</span><br><span class="line">	gp, inheritTime &#x3D; runqget(_g_.m.p.ptr())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码，基本上也就是3块逻辑：优先执行gc的g、其次查看是否需要获取全局列表、最后查看当前p的列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if gp.lockedm !&#x3D; 0 &#123;</span><br><span class="line">	&#x2F;&#x2F; Hands off own p to the locked m,</span><br><span class="line">	&#x2F;&#x2F; then blocks waiting for a new p.</span><br><span class="line">	startlockedm(gp)</span><br><span class="line">	goto top</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">execute(gp, inheritTime)</span><br></pre></td></tr></table></figure>

<p>最后针对绑定的g进行特殊处理。否则就执行<code>execute</code>方法</p>
<blockquote>
<p>会从哪些地方去获取g？优先级是什么？</p>
</blockquote>
<h4 id="Execute函数"><a href="#Execute函数" class="headerlink" title="Execute函数"></a>Execute函数</h4><p>该函数主要功能切换当前上下文至指定的g中，具体源码如下，没有特别的逻辑，都是将g属性初始化一遍。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func execute(gp *g, inheritTime bool) &#123;</span><br><span class="line">	_g_ :&#x3D; getg()</span><br><span class="line"></span><br><span class="line">	_g_.m.curg &#x3D; gp</span><br><span class="line">	gp.m &#x3D; _g_.m</span><br><span class="line">	casgstatus(gp, _Grunnable, _Grunning)</span><br><span class="line">	gp.waitsince &#x3D; 0</span><br><span class="line">	gp.preempt &#x3D; false</span><br><span class="line">	gp.stackguard0 &#x3D; gp.stack.lo + _StackGuard</span><br><span class="line">	if !inheritTime &#123;</span><br><span class="line">		_g_.m.p.ptr().schedtick++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gogo(&amp;gp.sched)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而<code>gogo</code>方法是真正在汇编层切换寄存器的逻辑，传入的sched就是这个g的上下文信息，包含4个寄存器信息，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">TEXT runtime·gogo(SB), NOSPLIT, $16-8</span><br><span class="line">	MOVQ	buf+0(FP), BX		&#x2F;&#x2F; gobuf</span><br><span class="line">	MOVQ	gobuf_g(BX), DX</span><br><span class="line">	MOVQ	0(DX), CX		&#x2F;&#x2F; make sure g !&#x3D; nil</span><br><span class="line">	get_tls(CX)</span><br><span class="line">	MOVQ	DX, g(CX)		&#x2F;&#x2F; 保存g至tls中</span><br><span class="line">	&#x2F;&#x2F; 恢复sp，ax，dx，bp寄存器</span><br><span class="line">	MOVQ	gobuf_sp(BX), SP	&#x2F;&#x2F; restore SP</span><br><span class="line">	MOVQ	gobuf_ret(BX), AX</span><br><span class="line">	MOVQ	gobuf_ctxt(BX), DX</span><br><span class="line">	MOVQ	gobuf_bp(BX), BP</span><br><span class="line">	&#x2F;&#x2F; 清空gobuf</span><br><span class="line">	MOVQ	$0, gobuf_sp(BX)	&#x2F;&#x2F; clear to help garbage collector</span><br><span class="line">	MOVQ	$0, gobuf_ret(BX)</span><br><span class="line">	MOVQ	$0, gobuf_ctxt(BX)</span><br><span class="line">	MOVQ	$0, gobuf_bp(BX)</span><br><span class="line">	MOVQ	gobuf_pc(BX), BX</span><br><span class="line">	JMP	BX</span><br></pre></td></tr></table></figure>

<h4 id="Goexit函数"><a href="#Goexit函数" class="headerlink" title="Goexit函数"></a>Goexit函数</h4><p>goexit方法是当当前线程执行完毕后执行的析构方法，设置的方法为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">func gostartcallfn(gobuf *gobuf, fv *funcval) &#123;</span><br><span class="line">    var fn unsafe.Pointer</span><br><span class="line">    if fv !&#x3D; nil &#123;</span><br><span class="line">        fn &#x3D; unsafe.Pointer(fv.fn)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        fn &#x3D; unsafe.Pointer(funcPC(nilfunc))</span><br><span class="line">    &#125;</span><br><span class="line">    gostartcall(gobuf, fn, unsafe.Pointer(fv))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; adjust Gobuf as if it executed a call to fn with context ctxt</span><br><span class="line">&#x2F;&#x2F; and then did an immediate gosave.</span><br><span class="line">func gostartcall(buf *gobuf, fn, ctxt unsafe.Pointer) &#123;</span><br><span class="line">    sp :&#x3D; buf.sp</span><br><span class="line">    if sys.RegSize &gt; sys.PtrSize &#123;</span><br><span class="line">        sp -&#x3D; sys.PtrSize</span><br><span class="line">        *(*uintptr)(unsafe.Pointer(sp)) &#x3D; 0</span><br><span class="line">    &#125;</span><br><span class="line">    sp -&#x3D; sys.PtrSize</span><br><span class="line">    *(*uintptr)(unsafe.Pointer(sp)) &#x3D; buf.pc &#x2F;&#x2F; 注意这里，这个，这里的 buf.pc 实际上是 goexit 的 pc</span><br><span class="line">    buf.sp &#x3D; sp</span><br><span class="line">    buf.pc &#x3D; uintptr(fn)</span><br><span class="line">    buf.ctxt &#x3D; ctxt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 gostartcall 中把 newproc1 时设置到 buf.pc 中的 goexit 的函数地址放到了 goroutine 的栈顶，然后重新设置 buf.pc 为 goroutine 函数的位置。这样做的目的是为了在执行完任何 goroutine 的函数时，通过 RET 指令，都能从栈顶把 sp 保存的 goexit 的指令 pop 到 pc 寄存器，效果相当于任何 goroutine 执行函数执行完之后，都会去执行 runtime.goexit，完成一些清理工作后再进入 schedule。</p>
<p>当前流程只剩下<code>goexit-&gt;goexit1-&gt;goexit0</code>，代码还算可读，直接上代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">TEXT runtime·goexit(SB),NOSPLIT,$0-0</span><br><span class="line">	BYTE	$0x90	&#x2F;&#x2F; NOP</span><br><span class="line">	CALL	runtime·goexit1(SB)	&#x2F;&#x2F; does not return</span><br><span class="line">	&#x2F;&#x2F; traceback from goexit1 must hit code range of goexit</span><br><span class="line">	BYTE	$0x90	&#x2F;&#x2F; NOP</span><br><span class="line"></span><br><span class="line">	... ... </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Finishes execution of the current goroutine.</span><br><span class="line">func goexit1() &#123;</span><br><span class="line">	if raceenabled &#123;</span><br><span class="line">		racegoend()</span><br><span class="line">	&#125;</span><br><span class="line">	if trace.enabled &#123;</span><br><span class="line">		traceGoEnd()</span><br><span class="line">	&#125;</span><br><span class="line">	mcall(goexit0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在代码来看，goexit和goexit1目标只是切换到g0协程中并执行<code>goexit0</code>中，第一部分，大部分都是变量清空，并清空当前的g状态置为_Gdead。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">func goexit0(gp *g) &#123;</span><br><span class="line">	_g_ :&#x3D; getg()</span><br><span class="line"></span><br><span class="line">	casgstatus(gp, _Grunning, _Gdead)</span><br><span class="line">	if isSystemGoroutine(gp, false) &#123;</span><br><span class="line">		atomic.Xadd(&amp;sched.ngsys, -1)</span><br><span class="line">	&#125;</span><br><span class="line">	gp.m &#x3D; nil</span><br><span class="line">	locked :&#x3D; gp.lockedm !&#x3D; 0</span><br><span class="line">	gp.lockedm &#x3D; 0</span><br><span class="line">	_g_.m.lockedg &#x3D; 0</span><br><span class="line">	gp.preemptStop &#x3D; false</span><br><span class="line">	gp.paniconfault &#x3D; false</span><br><span class="line">	gp._defer &#x3D; nil &#x2F;&#x2F; should be true already but just in case.</span><br><span class="line">	gp._panic &#x3D; nil &#x2F;&#x2F; non-nil for Goexit during panic. points at stack-allocated data.</span><br><span class="line">	gp.writebuf &#x3D; nil</span><br><span class="line">	gp.waitreason &#x3D; 0</span><br><span class="line">	gp.param &#x3D; nil</span><br><span class="line">	gp.labels &#x3D; nil</span><br><span class="line">	gp.timer &#x3D; nil</span><br><span class="line">	if gcBlackenEnabled !&#x3D; 0 &amp;&amp; gp.gcAssistBytes &gt; 0 &#123;</span><br><span class="line">		scanCredit :&#x3D; int64(gcController.assistWorkPerByte * float64(gp.gcAssistBytes))</span><br><span class="line">		atomic.Xaddint64(&amp;gcController.bgScanCredit, scanCredit)</span><br><span class="line">		gp.gcAssistBytes &#x3D; 0</span><br><span class="line">	&#125;</span><br><span class="line">	dropg()</span><br></pre></td></tr></table></figure>

<p>清空完自身的g后，主要就剩下清理其他的信息，例如：写入g的队列中，清空m，进入调度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func goexit0(gp *g) &#123;</span><br><span class="line">	... ...</span><br><span class="line">	gfput(_g_.m.p.ptr(), gp)</span><br><span class="line">	if locked &#123;</span><br><span class="line">		if GOOS !&#x3D; &quot;plan9&quot; &#123; &#x2F;&#x2F; See golang.org&#x2F;issue&#x2F;22227.</span><br><span class="line">			gogo(&amp;_g_.m.g0.sched)</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			_g_.m.lockedExt &#x3D; 0</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	schedule()</span><br></pre></td></tr></table></figure>

<h2 id="待办事项"><a href="#待办事项" class="headerlink" title="待办事项"></a>待办事项</h2><ul>
<li>定时执行逻辑</li>
<li>锁定线程逻辑</li>
<li>tryWakeP逻辑</li>
<li>findrunnable逻辑</li>
<li>mcall、notesleep逻辑</li>
<li>inheritTime功能</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://artikell.github.io/2020/07/08/golang-dispatch/" data-id="ckceyz3dl000136uyh4cf6lru" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/08/hello-world/" class="article-date">
  <time datetime="2020-07-08T07:22:40.504Z" itemprop="datePublished">2020-07-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/08/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://artikell.github.io/2020/07/08/hello-world/" data-id="ckceyz3cu000036uy9henei4n" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/07/12/golang-lockg/">Golang-Lockg学习</a>
          </li>
        
          <li>
            <a href="/2020/07/08/golang-dispatch/">Golang调度讲解</a>
          </li>
        
          <li>
            <a href="/2020/07/08/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Skyfire Lee<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>