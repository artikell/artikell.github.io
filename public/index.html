<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"artikell.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Start Again">
<meta property="og:url" content="http://artikell.github.io/index.html">
<meta property="og:site_name" content="Start Again">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Skyfire Lee">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://artikell.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Start Again</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Start Again</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://artikell.github.io/2021/06/02/level-db-start/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Skyfire Lee">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Start Again">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/02/level-db-start/" class="post-title-link" itemprop="url">浅析levelDB流程（打开流程）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-06-02 01:32:32 / 修改时间：01:32:53" itemprop="dateCreated datePublished" datetime="2021-06-02T01:32:32+08:00">2021-06-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>核心是逐步学习leveldb的实现，而其中一步步从读写开始学习相关实现</p>
<h2 id="打开的方法"><a href="#打开的方法" class="headerlink" title="打开的方法"></a>打开的方法</h2><p>从上文的demo，我们可以看出常见的打开方式是传入一个文件夹目录，方法是<code>OpenFile</code>，而针对各种常见，leveldb也提供了多种方法，例如可以自身传入一个存储方式的<code>Open(stor storage.Storage, o *opt.Options)</code>、直接从目录中恢复数据的<code>RecoverFile(path string, o *opt.Options)</code>等。而此次，我们核心从基础的OpenFile方法中入手，看看在打开leveldb时，是如何进行初始化操作。</p>
<h2 id="数据的获取"><a href="#数据的获取" class="headerlink" title="数据的获取"></a>数据的获取</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stor, err :&#x3D; storage.OpenFile(path, o.GetReadOnly())</span><br></pre></td></tr></table></figure>
<p>最初引入眼帘的便是通过<code>storage.OpenFile</code>去持有一个存储对象。这其中可以使用内存作为存储，当然大部分情况还是使用文件存储。<br>在打开文件后，需要开始检查路径是否存在、检查文件锁是否存在。检查完这2项后，还有就是确定当前是否只读，如果只读，则不需要新建Log文件，因为Log文件是用于支持AOF能力，否则则需要重建。<br>当检查完成后，便会得到以下的结构体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fs :&#x3D; &amp;fileStorage&#123;</span><br><span class="line">	path:     path,</span><br><span class="line">	readOnly: readOnly,</span><br><span class="line">	flock:    flock,</span><br><span class="line">	logw:     logw,</span><br><span class="line">	logSize:  logSize,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结构体中核心包含路径、是否只读、是否锁，以及log文件相关数据<br>当然，还有有趣的一行代码是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runtime.SetFinalizer(fs, (*fileStorage).Close)</span><br></pre></td></tr></table></figure>
<p>这行代码的目的和析构函数类似，当对象销毁时，进行善后处理。</p>
<h2 id="会话的构建"><a href="#会话的构建" class="headerlink" title="会话的构建"></a>会话的构建</h2><p>当已经持有存储对象时，第一步就开始针对存储对象构建会话session信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">s, err :&#x3D; newSession(stor, o)</span><br><span class="line">	s &#x3D; &amp;session&#123;</span><br><span class="line">		stor:      newIStorage(stor),</span><br><span class="line">		storLock:  storLock,</span><br><span class="line">		refCh:     make(chan *vTask),</span><br><span class="line">		relCh:     make(chan *vTask),</span><br><span class="line">		deltaCh:   make(chan *vDelta),</span><br><span class="line">		abandon:   make(chan int64),</span><br><span class="line">		fileRefCh: make(chan chan map[int64]int),</span><br><span class="line">		closeC:    make(chan struct&#123;&#125;),</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>会话中一个大的属性便是管道信息，可以见得session持有了多类管道，中间的能力简单来说就是，当leveldb中文件存在变更，都是通过session来进行异步操作。例如文件的删除和添加。而后会启动一个协程来辅助处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go s.refLoop()</span><br></pre></td></tr></table></figure>
<p>得到session对象后，则需要用version对象来管理各个版本的文件信息，这也是保证leveldb中并发安全的基础</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s.setVersion(nil, newVersion(s))</span><br><span class="line">--- </span><br><span class="line"></span><br><span class="line">func newVersion(s *session) *version &#123;</span><br><span class="line">	id :&#x3D; atomic.AddInt64(&amp;s.ntVersionId, 1)</span><br><span class="line">	nv :&#x3D; &amp;version&#123;s: s, id: id - 1&#125;</span><br><span class="line">	return nv</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当在初始化时，仅仅只是将version和session进行绑定。</p>
<h2 id="奔溃恢复"><a href="#奔溃恢复" class="headerlink" title="奔溃恢复"></a>奔溃恢复</h2><p>初始化完基本信息，leveldb就进入了奔溃恢复流程，这也是所有存储不可避免的一个机制，包括mysql。而崩溃恢复也是针对session而已，最终核心也是恢复出上一次存储的version信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err &#x3D; s.recover()</span><br></pre></td></tr></table></figure>
<p>首先第一步恢复就是恢复当前的存储基本信息，这也映射到了leveldb中的current文件中对应的Manifest文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fd, err :&#x3D; s.stor.GetMeta()</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reader, err :&#x3D; s.stor.Open(fd)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br><span class="line">defer reader.Close()</span><br></pre></td></tr></table></figure>
<p>得到Current文件后，就会生成一个记事本journal对象，这个对象管理着Log文件内容，而Manifest文件本书也是Log文件格式存储，所以，直接复用即可。<br>文件格式本文暂时不仔细描述，而从Manifest文件中，可以解析出，当前数据库使用的对比方法、压缩格式、各层级的文件信息，至此，我们就可以产生出一个新的version对象。</p>
<h2 id="数据库对象构建"><a href="#数据库对象构建" class="headerlink" title="数据库对象构建"></a>数据库对象构建</h2><p>session本身是管理此次底层version的变更，而再上一层则需要一个db层来管理对外接口以及内存和文件的事件管理。所以，这一层更多的是压缩、和写入的管理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">db :&#x3D; &amp;DB&#123;</span><br><span class="line">		s: s,</span><br><span class="line">		&#x2F;&#x2F; Initial sequence</span><br><span class="line">		seq: s.stSeqNum,</span><br><span class="line">		&#x2F;&#x2F; MemDB</span><br><span class="line">		memPool: make(chan *memdb.DB, 1),</span><br><span class="line">		&#x2F;&#x2F; Snapshot</span><br><span class="line">		snapsList: list.New(),</span><br><span class="line">		&#x2F;&#x2F; Write</span><br><span class="line">		batchPool:    sync.Pool&#123;New: newBatch&#125;,</span><br><span class="line">		writeMergeC:  make(chan writeMerge),</span><br><span class="line">		writeMergedC: make(chan bool),</span><br><span class="line">		writeLockC:   make(chan struct&#123;&#125;, 1),</span><br><span class="line">		writeAckC:    make(chan error),</span><br><span class="line">		&#x2F;&#x2F; Compaction</span><br><span class="line">		tcompCmdC:   make(chan cCmd),</span><br><span class="line">		tcompPauseC: make(chan chan&lt;- struct&#123;&#125;),</span><br><span class="line">		mcompCmdC:   make(chan cCmd),</span><br><span class="line">		compErrC:    make(chan error),</span><br><span class="line">		compPerErrC: make(chan error),</span><br><span class="line">		compErrSetC: make(chan error),</span><br><span class="line">		&#x2F;&#x2F; Close</span><br><span class="line">		closeC: make(chan struct&#123;&#125;),</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>由结构体可见大部分是针对压缩和写入合并使用的管道对象。<br>而生成完session后，仅仅只是吧以及落磁盘的level文件加载，而在崩溃前的内存数据还在丢失的，这些数据则需要从Log文件中恢复，这些则是在DB生成后恢复，当然恢复也是直接入memDB中，当做写入执行。中间必然也就触发了压缩和version的变更。</p>
<p>当Log文件恢复后，最终就是启动各类的管道来执行相关的异步操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">go db.compactionError()</span><br><span class="line">go db.mpoolDrain()</span><br><span class="line"></span><br><span class="line">if readOnly &#123;</span><br><span class="line">	db.SetReadOnly()</span><br><span class="line">&#125; else &#123;</span><br><span class="line">	db.closeW.Add(2)</span><br><span class="line">	go db.tCompaction()</span><br><span class="line">	go db.mCompaction()</span><br><span class="line">	&#x2F;&#x2F; go db.jWriter()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由此可见，leveldb中，使用了大量的异步逻辑来保证存储的高性能。同时也是利用了AOF原理来提高高可用性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://artikell.github.io/2020/07/19/golang-gmp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Skyfire Lee">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Start Again">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/19/golang-gmp/" class="post-title-link" itemprop="url">Golang-GMP模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-19 18:04:28" itemprop="dateCreated datePublished" datetime="2020-07-19T18:04:28+08:00">2020-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-02 01:32:05" itemprop="dateModified" datetime="2021-06-02T01:32:05+08:00">2021-06-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="GMP模型"><a href="#GMP模型" class="headerlink" title="GMP模型"></a>GMP模型</h2><h3 id="关于线程和协程"><a href="#关于线程和协程" class="headerlink" title="关于线程和协程"></a>关于线程和协程</h3><p>在计算机操作系统中,轻量级进程（LWP）是一种实现多任务的方法。与普通进程相比，LWP与其他进程共享所有（或大部分）它的逻辑地址空间和系统资源；与线程相比，LWP有它自己的进程标识符，优先级，状态，以及栈和局部存储区，并和其他进程有着父子关系；这是和类Unix操作系统的系统调用vfork()生成的进程一样的。另外，线程既可由应用程序管理，又可由内核管理，而LWP只能由内核管理并像普通进程一样被调度。Linux内核是支持LWP的典型例子。</p>
<p><img src="1767848-9c4b06362907280d.webp" alt="img"></p>
<h3 id="Golang中的模型"><a href="#Golang中的模型" class="headerlink" title="Golang中的模型"></a>Golang中的模型</h3><p>有2个支持高并发的模型：CSP和Actor（erlang）。Go选择了CSP，Go为了提供更容易的并发使用方法，提供了2个重要的概念<code>goroutine</code>和<code>channel</code>。</p>
<p><strong>goroutine</strong>来自协程的概念，让一组可复用的函数运行在一组线程之上，即使有协程阻塞，该线程的其他协程也可以被<code>runtime</code>调度，转移到其他可运行的线程上。</p>
<p><img src="3184f3.jpg" alt="img"></p>
<p>其实<strong>老调度器</strong>有4个缺点：详见<a href="https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit#!" target="_blank" rel="noopener">Scalable Go Scheduler Design Doc</a></p>
<ol>
<li>创建、销毁、调度G都需要每个M获取锁，这就形成了激烈的锁竞争</li>
<li>M转移G会造成延迟和额外的系统开销。</li>
<li>M中的mcache是用来存放小对象的，mcache和栈都和M关联造成了大量的内存开销和差的局部性</li>
<li>系统调用导致频繁的线程阻塞和取消阻塞操作增加了系统开销。</li>
</ol>
<p>所以Go语言在2012年重新设计了调度器方案（<a href="https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit#!" target="_blank" rel="noopener">Scalable Go Scheduler Design Doc</a>，<a href="https://golang.org/s/go11sched" target="_blank" rel="noopener">设计方案</a>）。</p>
<p><img src="567399-d400f4b192f3dc48.webp" alt="img"></p>
<h2 id="关于GMP模型"><a href="#关于GMP模型" class="headerlink" title="关于GMP模型"></a>关于GMP模型</h2><h3 id="关于Machine"><a href="#关于Machine" class="headerlink" title="关于Machine"></a>关于Machine</h3><p>machine代表一个线程，每次创建一个M的时候，都会有一个底层线程创建；所有的G任务，最终还是在M上执行。</p>
<p>machine的字段多达几十个，但将其进行粗劣的分类是可以明确m的具体职责：</p>
<ol>
<li>特殊g的管理：g0、gsignal、curg</li>
<li>p的管理：p、nextp、oldp</li>
<li>状态管理：locks、preemptoff、mallocing、throwing、dying、incgo、signalPending、blocked</li>
<li>锁的管理：lockedg、lockedExt、lockedInt、nextwaitm、waitlock</li>
<li>cgo运行相关：ncgocall、ncgo、cgoCallersUse、cgoCallers</li>
</ol>
<p>从字段中可以看出，在m层，主要方向有几个关键词：锁、抢占、cgo、g与p的管理、信号。主要原因还是由于m是一个贴近操作系统的结构体，而操作系统的调度的核心问题也是锁、信号，阻塞等。</p>
<blockquote>
<p>如何解决m和m的绑定问题？</p>
</blockquote>
<h4 id="创建Machine"><a href="#创建Machine" class="headerlink" title="创建Machine"></a>创建Machine</h4><p>创建m的时机有3类：sysmon抢占线程、templateThread模板线程、运行p。前2者是特殊的线程，不会进入调度系统中。创建m的方法是直接调用<code>runtime.newm</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func newm(fn func(), _p_ *p) &#123;</span><br><span class="line">	&#x2F;&#x2F; 分配一个m对象</span><br><span class="line">	mp :&#x3D; allocm(_p_, fn)</span><br><span class="line">	&#x2F;&#x2F; 设置下一个执行的p</span><br><span class="line">	mp.nextp.set(_p_)</span><br><span class="line">	&#x2F;&#x2F; 初始化系统信号拦截</span><br><span class="line">	mp.sigmask &#x3D; initSigmask</span><br><span class="line">    ... ...</span><br><span class="line">	newm1(mp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出在m的创建流程中，具体分为2步：结构体的创建、线程的创建。在<code>allocm</code>方法中，核心是需要申请一个m的对象以及相关的g0空间，而针对不同的操作系统，g0的内存空间又区分为是使用系统分配，还是go指定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func allocm(_p_ *p, fn func()) *m &#123;</span><br><span class="line"></span><br><span class="line">    ... ...</span><br><span class="line">	mp :&#x3D; new(m)</span><br><span class="line">	mp.mstartfn &#x3D; fn</span><br><span class="line">	mcommoninit(mp)</span><br><span class="line"></span><br><span class="line">	if iscgo || GOOS &#x3D;&#x3D; &quot;solaris&quot; || GOOS &#x3D;&#x3D; &quot;illumos&quot; || GOOS &#x3D;&#x3D; &quot;windows&quot; || GOOS &#x3D;&#x3D; &quot;plan9&quot; || GOOS &#x3D;&#x3D; &quot;darwin&quot; &#123;</span><br><span class="line">		mp.g0 &#x3D; malg(-1)</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		mp.g0 &#x3D; malg(8192 * sys.StackGuardMultiplier)</span><br><span class="line">	&#125;</span><br><span class="line">	mp.g0.m &#x3D; mp</span><br><span class="line"></span><br><span class="line">	return mp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在<code>runtime.newm1</code>方法中，主要是直接调用<code>runtime.newosproc</code>方法，正如其名，就是用于创建一个系统的线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func newm1(mp *m) &#123;</span><br><span class="line">    ... ...</span><br><span class="line">	newosproc(mp)</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func newosproc(mp *m) &#123;</span><br><span class="line">	stk :&#x3D; unsafe.Pointer(mp.g0.stack.hi)</span><br><span class="line">    ... ...</span><br><span class="line">	var oset sigset</span><br><span class="line">	sigprocmask(_SIG_SETMASK, &amp;sigset_all, &amp;oset)</span><br><span class="line">	ret :&#x3D; clone(cloneFlags, stk, unsafe.Pointer(mp), unsafe.Pointer(mp.g0), unsafe.Pointer(funcPC(mstart)))</span><br><span class="line">	sigprocmask(_SIG_SETMASK, &amp;oset, nil)</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关于Processor"><a href="#关于Processor" class="headerlink" title="关于Processor"></a>关于Processor</h3><p>每一个运行的M都必须绑定一个P，就像线程必须在么一个CPU核上执行一样，由P来调度G在M上的运行，P的个数就是GOMAXPROCS（最大256），启动时固定的，一般不修改；</p>
<p>processor的字段可以分为以下几类：</p>
<ol>
<li>内存管理相关：mcache、pcache、mspancache、palloc</li>
<li>调度计数相关：schedtick、syscalltick、sysmontick</li>
<li>cache相关：deferpool、deferpoolbuf、gFree、sudogcache、sudogbuf</li>
<li>g调度相关：runqhead、runqtail、runq、runnext</li>
<li>定时器相关：timer0When、timersLock、timers、numTimers、adjustTimers、deletedTimers、</li>
<li>gc相关：gcAssistTime、gcFractionalMarkTime、gcBgMarkWorker、gcMarkWorkerMode、gcMarkWorkerStartTime、gcw、wbBuf、runSafePointFn</li>
</ol>
<p>这几大方面主要是由于p本身的定位是执行器有关，当执行用户代码时，需要在效率和性能方面做到兼容，</p>
<p>p的创建流程代码并不难懂，方法由procresize来执行，也就是平时大家设置GOMAXPROCS计数，其中涉及到扩容和缩容操作。</p>
<h3 id="关于Goroutine"><a href="#关于Goroutine" class="headerlink" title="关于Goroutine"></a>关于Goroutine</h3><p>gorountine也就是平时的协程，每次go调用的时候，都会创建一个G对象，它包括栈、指令指针以及对于调用goroutines很重要的其它信息</p>
<p>gorountine的字段可以分为以下几类：</p>
<ol>
<li>上下文信息：startpc、gopc、sigpc、sched、syscallsp、syscallpc、stktopsp、param</li>
<li>抢占相关：preempt、preemptStop、preemptShrink</li>
<li>栈相关：stack、stackguard0、stackguard1</li>
<li>defer相关：_panic、_defer</li>
<li>锁相关：waiting、timer、selectDone、</li>
<li>信号相关：sigcode0、sigcode1、sigpc</li>
</ol>
<p>当然，gorountine不仅仅是上述的字段，还有大量的pprof的计数字段，本次暂时不做讨论。</p>
<p>可以看出，g和m的字段中，都有信号、锁、抢占相关的字段，但是，为什么m中却没有栈信息，难道不需要栈信息？这就是g0协程的重要性，golang中为了做权限隔离，避免用户代码影响runtime的运行，专门抽象了g0协程执行。既然无法向操作系统中通过中断实现内核态切换，就考虑使用特殊协程，这样相关上下文切换逻辑是完全复用，所以，g0是一个只做权限隔离的协程，同时所有m都拥有一个g0。</p>
<h4 id="创建Gorountine"><a href="#创建Gorountine" class="headerlink" title="创建Gorountine"></a>创建Gorountine</h4><p>创建gorountine就是平时大家使用的<code>go func()</code>关键字。在编译阶段，关键字会变编译为<code>runtime.newproc</code>方法，同时会传入参数大小和函数指针fn。然后从堆栈中获取参数并调用<code>runtime.newproc1</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func newproc(siz int32, fn *funcval) &#123;</span><br><span class="line">	argp :&#x3D; add(unsafe.Pointer(&amp;fn), sys.PtrSize)</span><br><span class="line">	gp :&#x3D; getg()</span><br><span class="line">	pc :&#x3D; getcallerpc()</span><br><span class="line">	systemstack(func() &#123;</span><br><span class="line">		newproc1(fn, argp, siz, gp, pc)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>runtime.newproc1</code>方法中具体可以分为3块逻辑：</p>
<ol>
<li>gorountine结构体创建</li>
<li>gorountine对象的初始化</li>
<li>插入调度对象并唤醒p</li>
</ol>
<p>创建完的gorountine结构体最终会插入p中的runq链表中。</p>
<h2 id="调度实现"><a href="#调度实现" class="headerlink" title="调度实现"></a>调度实现</h2><p>从m的创建流程中，可以看到<code>newosproc</code>方法是第四个参数，也就是系统线程的入口函数。线程创建完成后，操作系统会根据系统调度算法运行线程，<code>runtime.mstart</code>也就是线程的初始化方法。</p>
<h3 id="线程初始化"><a href="#线程初始化" class="headerlink" title="线程初始化"></a>线程初始化</h3><p><code>runtime.mstart</code>方法中，优先将栈的检查地址更新，这是因为如果是操作系统自动生成的堆栈，线程运行前是无法确定的。之后会调用<code>runtime.mstart1</code>方法执行进一步的初始化方法。最后，针对特殊的线程（被lockg的线程），会执行<code>runtime.mexit</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func mstart() &#123;</span><br><span class="line">	_g_ :&#x3D; getg()</span><br><span class="line"></span><br><span class="line">	osStack :&#x3D; _g_.stack.lo &#x3D;&#x3D; 0</span><br><span class="line">	if osStack &#123;</span><br><span class="line">		size :&#x3D; _g_.stack.hi</span><br><span class="line">		if size &#x3D;&#x3D; 0 &#123;</span><br><span class="line">			size &#x3D; 8192 * sys.StackGuardMultiplier</span><br><span class="line">		&#125;</span><br><span class="line">		_g_.stack.hi &#x3D; uintptr(noescape(unsafe.Pointer(&amp;size)))</span><br><span class="line">		_g_.stack.lo &#x3D; _g_.stack.hi - size + 1024</span><br><span class="line">	&#125;</span><br><span class="line">	_g_.stackguard0 &#x3D; _g_.stack.lo + _StackGuard</span><br><span class="line">	_g_.stackguard1 &#x3D; _g_.stackguard0</span><br><span class="line">	mstart1()</span><br><span class="line"></span><br><span class="line">	mexit(osStack)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续看<code>runtime.mstart1</code>方法，也还是一系列的初始化方法：</p>
<ol>
<li>保存调用寄存器信息，主要用于当用户g切换至g0时，需要恢复的上下文</li>
<li>初始化信号处理方法，因为每个线程都需要自己的信号处理g</li>
<li>执行mstartfn方法，这个方法是针对sysmon这类的特殊线程实现的功能，使当前线程不进入调度循环中。</li>
</ol>
<p>执行完上述的初始化操作后，当前线程就将<code>nextp</code>字段转正进行绑定，并进入<code>runtime.schedule</code>方法中调度。</p>
<h3 id="线程循环"><a href="#线程循环" class="headerlink" title="线程循环"></a>线程循环</h3><p>在调用循环中，存在3个因素影响调度：当前是否需要stw、当前是否获取到g、当前m是否被g绑定。三者中获取g是调度循环的主流程，其他2者也是golang的特殊功能。所以先抽离出获取g的整体流程。</p>
<h4 id="获取Gorountine"><a href="#获取Gorountine" class="headerlink" title="获取Gorountine"></a>获取Gorountine</h4><p>在获取gorountine流程中，可以分为3部分：</p>
<ol>
<li>若当前p不存在g，或者调度计数满足61次，则从全局中获取g运行</li>
<li>产生从p本地队列中获取g</li>
<li>本地和全局都获取不到时，则在<code>findrunable</code>方法中阻塞获取g</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func schedule() &#123;</span><br><span class="line">    ... ... </span><br><span class="line">top:</span><br><span class="line">	if gp &#x3D;&#x3D; nil &#123;</span><br><span class="line">		if _g_.m.p.ptr().schedtick%61 &#x3D;&#x3D; 0 &amp;&amp; sched.runqsize &gt; 0 &#123;</span><br><span class="line">			lock(&amp;sched.lock)</span><br><span class="line">			gp &#x3D; globrunqget(_g_.m.p.ptr(), 1)</span><br><span class="line">			unlock(&amp;sched.lock)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if gp &#x3D;&#x3D; nil &#123;</span><br><span class="line">		gp, inheritTime &#x3D; runqget(_g_.m.p.ptr())</span><br><span class="line">		&#x2F;&#x2F; We can see gp !&#x3D; nil here even if the M is spinning,</span><br><span class="line">		&#x2F;&#x2F; if checkTimers added a local goroutine via goready.</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; 如果实在没找到，那就强行找一个可用的</span><br><span class="line">	if gp &#x3D;&#x3D; nil &#123;</span><br><span class="line">		gp, inheritTime &#x3D; findrunnable() &#x2F;&#x2F; blocks until work is available</span><br><span class="line">	&#125;</span><br><span class="line">    execute(gp, inheritTime)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="globrunqget方法"><a href="#globrunqget方法" class="headerlink" title="globrunqget方法"></a>globrunqget方法</h5><p>在从全局队列中获取g时，会从全局队列中获取g，并同时迁移<code>1/len(allp)</code>个数的g到本地队列中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func globrunqget(_p_ *p, max int32) *g &#123;</span><br><span class="line">	n :&#x3D; sched.runqsize&#x2F;gomaxprocs + 1</span><br><span class="line">	if n &gt; int32(len(_p_.runq))&#x2F;2 &#123;</span><br><span class="line">		n &#x3D; int32(len(_p_.runq)) &#x2F; 2</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sched.runqsize -&#x3D; n</span><br><span class="line"></span><br><span class="line">	gp :&#x3D; sched.runq.pop()</span><br><span class="line">	n--</span><br><span class="line">	for ; n &gt; 0; n-- &#123;</span><br><span class="line">		gp1 :&#x3D; sched.runq.pop()</span><br><span class="line">		runqput(_p_, gp1, false)</span><br><span class="line">	&#125;</span><br><span class="line">	return gp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="runqget方法"><a href="#runqget方法" class="headerlink" title="runqget方法"></a>runqget方法</h5><p>而在获取本地队列g的时候，优先会尝试获取<code>runnext</code>字段的g，在从<code>runq</code>中获取头部的g对象。当然由于<code>runq</code>是通过循环队列实现，所以gp是通过下标取余获取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func runqget(_p_ *p) (gp *g, inheritTime bool) &#123;</span><br><span class="line">	for &#123;</span><br><span class="line">		next :&#x3D; _p_.runnext</span><br><span class="line">		if next &#x3D;&#x3D; 0 &#123;</span><br><span class="line">			break</span><br><span class="line">		&#125;</span><br><span class="line">		if _p_.runnext.cas(next, 0) &#123;</span><br><span class="line">			return next.ptr(), true</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for &#123;</span><br><span class="line">		h :&#x3D; atomic.LoadAcq(&amp;_p_.runqhead) &#x2F;&#x2F; load-acquire, synchronize with other consumers</span><br><span class="line">		t :&#x3D; _p_.runqtail</span><br><span class="line">		if t &#x3D;&#x3D; h &#123;</span><br><span class="line">			return nil, false</span><br><span class="line">		&#125;</span><br><span class="line">		gp :&#x3D; _p_.runq[h%uint32(len(_p_.runq))].ptr()</span><br><span class="line">		if atomic.CasRel(&amp;_p_.runqhead, h, h+1) &#123; &#x2F;&#x2F; cas-release, commits consume</span><br><span class="line">			return gp, false</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="findrunnable方法"><a href="#findrunnable方法" class="headerlink" title="findrunnable方法"></a>findrunnable方法</h5><p>由于前2个方法实在获取不到可运行的g，所以在<code>findrunnable</code>方法中会不断的在各个可能存在可运行g的地方查询。具体的查询流程如下：</p>
<ol>
<li>检查finalizer是否存在析构对象</li>
<li>检查本地对象是否存在可用g</li>
<li>查询全局队列是否存在可用g</li>
<li>非阻塞检查netpoll</li>
<li>如果大家都空闲中，或者自旋的m超过了忙碌的p，则进入强制查询阶段</li>
<li>再不济，随机4次去其他的p中窃取g</li>
</ol>
<p>上述流程实在找不到，m就不在持有p，然后开始特殊判断阶段。m开始循环判断是否存在可运行的g。判断区域还是从全局队列中、所有p的本地队列中以及netpoll三个方面。最终如果实在获取不到，则休眠当前m，等待有可用的p来唤醒。</p>
<h4 id="执行Gorountine"><a href="#执行Gorountine" class="headerlink" title="执行Gorountine"></a>执行Gorountine</h4><p>获取到可执行的g之后，就需要调用<code>runtime.execute</code>方法，主要针对g做一些变量赋值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">casgstatus(gp, _Grunnable, _Grunning)</span><br><span class="line">gp.waitsince &#x3D; 0</span><br><span class="line">gp.preempt &#x3D; false</span><br><span class="line">gp.stackguard0 &#x3D; gp.stack.lo + _StackGuard</span><br><span class="line">if !inheritTime &#123;</span><br><span class="line">	_g_.m.p.ptr().schedtick++</span><br><span class="line">&#125;</span><br><span class="line">_g_.m.curg &#x3D; gp</span><br><span class="line">gp.m &#x3D; _g_.m</span><br></pre></td></tr></table></figure>
<p>赋值完后，会调用<code>runtime.gogo</code>方法进行协程的上下文切换，将原有的g0协程，切换至gp协程。</p>
<h2 id="调度工具"><a href="#调度工具" class="headerlink" title="调度工具"></a>调度工具</h2><ul>
<li>trace</li>
<li>pprof</li>
</ul>
<h2 id="相关主题"><a href="#相关主题" class="headerlink" title="相关主题"></a>相关主题</h2><ul>
<li>lock ranking</li>
</ul>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://docs.oracle.com/cd/E19683-01/806-6867/guide-60747/index.html" target="_blank" rel="noopener">https://docs.oracle.com/cd/E19683-01/806-6867/guide-60747/index.html</a><br><a href="https://www.linuxjournal.com/article/3184" target="_blank" rel="noopener">https://www.linuxjournal.com/article/3184</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://artikell.github.io/2020/07/12/golang-lockg/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Skyfire Lee">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Start Again">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/12/golang-lockg/" class="post-title-link" itemprop="url">Golang-Lockg学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-12 23:51:41" itemprop="dateCreated datePublished" datetime="2020-07-12T23:51:41+08:00">2020-07-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-14 23:56:41" itemprop="dateModified" datetime="2020-07-14T23:56:41+08:00">2020-07-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="GMP的关系"><a href="#GMP的关系" class="headerlink" title="GMP的关系"></a>GMP的关系</h2><h2 id="G的调度"><a href="#G的调度" class="headerlink" title="G的调度"></a>G的调度</h2><h2 id="抢占逻辑"><a href="#抢占逻辑" class="headerlink" title="抢占逻辑"></a>抢占逻辑</h2><h2 id="锁协程"><a href="#锁协程" class="headerlink" title="锁协程"></a>锁协程</h2><h2 id="GMP清理"><a href="#GMP清理" class="headerlink" title="GMP清理"></a>GMP清理</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://artikell.github.io/2020/07/08/golang-dispatch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Skyfire Lee">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Start Again">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/08/golang-dispatch/" class="post-title-link" itemprop="url">Golang调度讲解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-08 15:38:21" itemprop="dateCreated datePublished" datetime="2020-07-08T15:38:21+08:00">2020-07-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-12 23:51:12" itemprop="dateModified" datetime="2020-07-12T23:51:12+08:00">2020-07-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Golang调度是runtime中的核心部分，要说涉及到的东西，从基本的线程协程切换、GC的STW，到锁的暂停，都有相关涉猎。今天请个假休息一下，有空整理整理最近看的调度知识。</p>
<h2 id="调度基本知识"><a href="#调度基本知识" class="headerlink" title="调度基本知识"></a>调度基本知识</h2><h3 id="进程、线程和协程"><a href="#进程、线程和协程" class="headerlink" title="进程、线程和协程"></a>进程、线程和协程</h3><p>进程和线程的区别都不用说了，简单来说就是，最初，大佬们觉得，每个任务肯定都有独立的内存空间、句柄等等等。只要保证程序直接能够不互相干扰就行。</p>
<p>当机器性能不断的提升，程序员们发现，我任务太多了，需要执行很久，但是并不需要那么多的空间。如果照原来的方法每个任务都分配空间就特别耗时和耗资源，于是决定在进程的基础上拆分出线程，你只负责执行任务就行了。</p>
<p>按道理，线程已经足够轻量，大数据时代又来了。现在需要大量的碎片计算，就像请求一个hello world，执行的任务不耗时，但是频繁。这时候的线程切换就是一个问题，主要原因是，线程的切换需要切换至操作系统的内核态，不断地做内存的复制，页表的cache很容易就失效，耗时因此增加。</p>
<p>程序员再次想起，只要尽可能的不做内核态的切换，就可以减少这样的风险。于是出现了用户态的线程，也就是协程。</p>
<h3 id="并发模型"><a href="#并发模型" class="headerlink" title="并发模型"></a>并发模型</h3><p>大家在学习Golang源码中可以顺便思考一下，为什么是GMP模型？这就引出《七周七并发模型》书中的其他的并发模型：</p>
<ul>
<li>通过无变量的函数式编程实现并发，是无锁并发的一种模型；</li>
<li>Clojure对于状态和标识的分离，可以轻松实现内存事务模型；</li>
<li>Erlang的Actor模型是容错性非常高的分布式并发模型；</li>
<li>CSP模型是另一种分布式并发模型，被Go和Clojure采用；</li>
<li>GPU的并行计算主要针对数据密集型计算的并行，搞游戏的一定要看；</li>
<li>Hadoop和Storm分别适合超大数据量的批处理和流式处理。</li>
</ul>
<p>CSP（Communicating Sequential Processes）是由Tony Hoare在1978的论文上首次提出的。 它是处理并发编程的一种设计模式或者模型，指导并发程序的设计，提供了一种并发程序可实践的组织方法或者设计范式。通过此方法，可以减少并发程序引入的其它缺点，减少和规避并发程序的常见缺点和bug，并且可以被数学理论所论证。</p>
<blockquote>
<p>经典名言：Do not communicate by sharing memory; instead, share memory by communicating</p>
</blockquote>
<p>该模型主要的最终实现在于golang中的channel和goroutine。</p>
<h3 id="GMP模型"><a href="#GMP模型" class="headerlink" title="GMP模型"></a>GMP模型</h3><p>在golang实现之前，其实解决线程切换开销大的问题可能有各种各样的方式。nginx中通过epollo来进行事件管理，还有python中的yield进行用户态的手动切换。这些都属于非抢占式的，核心问题就是如果中间出现过量的超时操作，很容易就会导致进程阻塞。</p>
<p>而golang的GMP模型中参考操作系统中的线程切换制作了sysmon线程用于做协程的抢占操作。</p>
<p>在GMP模型特殊之处也是在于中间P层的存在，在1.1之前，是不存在P层。这就导致了，G其实是挂载在全局的链表中。每次切换协程都会抢占一个全局锁，于是给GM中增加了一个P层。</p>
<h3 id="特殊的线程、协程"><a href="#特殊的线程、协程" class="headerlink" title="特殊的线程、协程"></a>特殊的线程、协程</h3><p>在golang中，存在2个特殊的线程：sysmon、templateThread。前者主要用于实现golang的抢占式调度，后者则是作为fork线程时使用的模板线程。</p>
<p>同时还存在一个特殊的协程：signalG，功能也就是用于接收进程的信号。</p>
<p>这3者可以单独讲解。本文主要讲解整体的正常线程调度流程。</p>
<h2 id="进程启动"><a href="#进程启动" class="headerlink" title="进程启动"></a>进程启动</h2><h3 id="最初的入口和空间"><a href="#最初的入口和空间" class="headerlink" title="最初的入口和空间"></a>最初的入口和空间</h3><p>首先，golang的启动入口rt0_go（asm_arm64.s文件）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">	MOVW	R0, 8(RSP) &#x2F;&#x2F; argc</span><br><span class="line">	MOVD	R1, 16(RSP) &#x2F;&#x2F; argv</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; create istack out of the given (operating system) stack.</span><br><span class="line">	&#x2F;&#x2F; _cgo_init may update stackguard.</span><br><span class="line">	MOVD	$runtime·g0(SB), g</span><br><span class="line">	MOVD	RSP, R7</span><br><span class="line">	MOVD	$(-64*1024)(R7), R0</span><br><span class="line">	MOVD	R0, g_stackguard0(g)</span><br><span class="line">	MOVD	R0, g_stackguard1(g)</span><br><span class="line">	MOVD	R0, (g_stack+stack_lo)(g)</span><br><span class="line">	MOVD	R7, (g_stack+stack_hi)(g)</span><br><span class="line"></span><br><span class="line">    ... ...</span><br><span class="line">nocgo:</span><br><span class="line">	BL	runtime·save_g(SB)</span><br><span class="line">	&#x2F;&#x2F; update stackguard after _cgo_init</span><br><span class="line">	MOVD	(g_stack+stack_lo)(g), R0</span><br><span class="line">	ADD	$const__StackGuard, R0</span><br><span class="line">	MOVD	R0, g_stackguard0(g)</span><br><span class="line">	MOVD	R0, g_stackguard1(g)</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; set the per-goroutine and per-mach &quot;registers&quot;</span><br><span class="line">	MOVD	$runtime·m0(SB), R0</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; save m-&gt;g0 &#x3D; g0</span><br><span class="line">	MOVD	g, m_g0(R0)</span><br><span class="line">	&#x2F;&#x2F; save m0 to g0-&gt;m</span><br><span class="line">	MOVD	R0, g_m(g)</span><br><span class="line"></span><br><span class="line">	MOVW	8(RSP), R0	&#x2F;&#x2F; copy argc</span><br><span class="line">	MOVW	R0, -8(RSP)</span><br><span class="line">	MOVD	16(RSP), R0		&#x2F;&#x2F; copy argv</span><br><span class="line">	MOVD	R0, 0(RSP)</span><br></pre></td></tr></table></figure>

<p>这段汇编其实不用特别讨论，主要做的就是初始化的一个流程：  </p>
<ol>
<li>赋值stack.lo和stack.hi属性</li>
<li>保存g0对象</li>
<li>设置m对象，包括m-&gt;g0、g0-&gt;m，做一个m0和g0的绑定</li>
<li>复制argc和argv</li>
</ol>
<p>以上基本上就是一些属性的赋值，后续就是执行了一系列的初始化函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BL	runtime·args(SB)</span><br><span class="line">BL	runtime·osinit(SB)</span><br><span class="line">BL	runtime·schedinit(SB)</span><br></pre></td></tr></table></figure>

<p>这3个函数，不是特别影响调度流程，具体功能主要是对一些功能进行初始化，例如内存管理、信号、mp链表、GC等功能的初始化。</p>
<p>在以上部分，现在基本上只存在一个m0代表主线程，一个g0代表主线程中的g0空间，还要一个signalG空间（并不在执行链表中），同时初始化了maxprocs个p，且在m0上面挂载了一个p对象。这时候，需要开始执行main函数，则需要一个新的g来执行方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MOVD	$runtime·mainPC(SB), R0		&#x2F;&#x2F; entry</span><br><span class="line">MOVD	RSP, R7</span><br><span class="line">MOVD.W	$0, -8(R7)</span><br><span class="line">MOVD.W	R0, -8(R7)</span><br><span class="line">MOVD.W	$0, -8(R7)</span><br><span class="line">MOVD.W	$0, -8(R7)</span><br><span class="line">MOVD	R7, RSP</span><br><span class="line">BL	runtime·newproc(SB)</span><br></pre></td></tr></table></figure>

<p><code>newproc</code>方法会将<code>runtime.main</code>函数作为入参传入，功能等同于<code>go runtime.main()</code>。而<code>newproc</code>方法具体功能主要就是创建一个g并插入当前的p中。</p>
<p>到这一步为止，整个进程还是只存在一个线程，但是存在3个g：g0、signalG、mainG。之后，就开始执行一个调度流程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BL	runtime·mstart(SB)</span><br></pre></td></tr></table></figure>

<h3 id="调度启动流程"><a href="#调度启动流程" class="headerlink" title="调度启动流程"></a>调度启动流程</h3><p>这是每个线程进入循环的入口。为什么这么说，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func newosproc(mp *m) &#123;</span><br><span class="line">	... ...</span><br><span class="line">	ret :&#x3D; clone(cloneFlags, stk, unsafe.Pointer(mp), unsafe.Pointer(mp.g0), unsafe.Pointer(funcPC(mstart)))</span><br></pre></td></tr></table></figure>
<p>这就是创建一个线程的代码，印象中的线程创建是<code>thread_create</code>方法，底层最后还是调用的<code>clone</code>方法<a href="https://linux.die.net/man/2/clone" target="_blank" rel="noopener">参考</a>，所有golang自行封装了一个方法。而这个调用的最后一个方法就是<code>mstart</code>方法。</p>
<p>进入<code>mstart</code>方法后，核心功能具体可以分为4部分：  </p>
<ol>
<li>osStack的判断</li>
<li>stackguard的赋值</li>
<li>mstart1的调用</li>
<li>mexit方法，m的退出函数</li>
</ol>
<p>首先，先确定stackguard的功能，通过汇编指令，我们可以看到每个函数中都能有一段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TEXT runtime.main(SB) &#x2F;opt&#x2F;go&#x2F;src&#x2F;runtime&#x2F;proc.go</span><br><span class="line">        proc.go:113             0x430690        64488b0c25f8ffffff      mov rcx, qword ptr fs:[0xfffffff8]</span><br><span class="line">        proc.go:113             0x430699        483b6110                cmp rsp, qword ptr [rcx+0x10]</span><br><span class="line">        proc.go:113             0x43069d        0f86f9020000            jbe 0x43099c</span><br><span class="line">&#x3D;&gt;      proc.go:113             0x4306a3*       4883ec50                sub rsp, 0x50</span><br><span class="line">        ... ...</span><br><span class="line">        proc.go:113             0x43099c        e86f8b0200              call $runtime.morestack_noctxt</span><br><span class="line">        &lt;autogenerated&gt;:1       0x4309a1        e9eafcffff              jmp $runtime.main</span><br></pre></td></tr></table></figure>
<p>第一行和第二行的具体功能分别是从TLS中获取当前的g对象、得到stackguard属性值。<br>这一整段的代码也就是表示如果当前的rsp比stackguard小的话，就认为是需要进行栈扩展。具体的值，也就是stack.lo+_StackGuard(896)。这一段就不具体叙述。</p>
<p>第二个问题是为什么要判断osStack？这就是要知道什么情况下会出现osStack，也就是系统栈空间。核心代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func allocm(_p_ *p, fn func()) *m &#123;</span><br><span class="line">    ... ...</span><br><span class="line">	if iscgo || GOOS &#x3D;&#x3D; &quot;solaris&quot; || GOOS &#x3D;&#x3D; &quot;illumos&quot; || GOOS &#x3D;&#x3D; &quot;windows&quot; || GOOS &#x3D;&#x3D; &quot;plan9&quot; || GOOS &#x3D;&#x3D; &quot;darwin&quot; &#123;</span><br><span class="line">		mp.g0 &#x3D; malg(-1)</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		mp.g0 &#x3D; malg(8192 * sys.StackGuardMultiplier)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>主要是当创建m的时候，m里面的g0的栈根据不同的系统或者cgo会创建系统的栈空间，否则就会使用heap中的空间。而在<code>mstart</code>方法中，判断是否为osStack，主要是需要判断，当前的栈是否可复用，如果是操作系统自动分配的栈是不在heap中的，无法回收管理，所以直接释放，若是在heap中，则需要进行回收操作。</p>
<p>而<code>mexit</code>函数，功能主要也是做一系列的变量释放、回收操作。后续会引出相关功能。</p>
<p>之后，方法会进入<code>mstart1</code>函数中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">func mstart1() &#123;</span><br><span class="line">	_g_ :&#x3D; getg()</span><br><span class="line"></span><br><span class="line">	if _g_ !&#x3D; _g_.m.g0 &#123;</span><br><span class="line">		throw(&quot;bad runtime·mstart&quot;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	save(getcallerpc(), getcallersp())</span><br><span class="line">	asminit()</span><br><span class="line">	minit()</span><br><span class="line"></span><br><span class="line">	if _g_.m &#x3D;&#x3D; &amp;m0 &#123;</span><br><span class="line">		mstartm0()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if fn :&#x3D; _g_.m.mstartfn; fn !&#x3D; nil &#123;</span><br><span class="line">		fn()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if _g_.m !&#x3D; &amp;m0 &#123;</span><br><span class="line">		acquirep(_g_.m.nextp.ptr())</span><br><span class="line">		_g_.m.nextp &#x3D; 0</span><br><span class="line">	&#125;</span><br><span class="line">	schedule()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，当前方法保存了上一个函数的pc和sp地址，功能也就是为了调用mexit方法，这里不做叙述。再之后就是2个初始化方法，<code>asminit</code>方法，在大部分操作系统中是没有函数体的，而<code>minit</code>函数中，具体做的事情是信号的初始化，也就是每个m都有自己的一个信号栈。这一部分不在此次学习范围内。</p>
<p>而后续的<code>mstartm0</code>函数，功能具体描述大致有2部分：创建扩展的线程、初始化信号回调方法。俩者也就是只会在m0上面执行一次，不在调度功能内，暂时不做过多介绍。</p>
<blockquote>
<p>问：扩展线程的功能是干嘛的？</p>
</blockquote>
<p>再之后就会有<code>mstartfn</code>函数的执行，这一个函数具体会存在3种情况：sysmon抢占线程、templateThread模板线程、mspinning自旋方法。前2者在前面也提到过是2个特殊的线程，进入后便会不断的轮询等待。后者的自旋只是对当前的m做了一个自旋的标记。</p>
<p>而后，针对非m0的m要进行一个p的绑定，m0为啥不需要呢？当然是因为m0在之前就已经绑定好了。</p>
<h3 id="开始调度循环"><a href="#开始调度循环" class="headerlink" title="开始调度循环"></a>开始调度循环</h3><p>题目是调度循环，而代码中其实是没有一个for循环，最后的逻辑是进入了一个execute方法，那具体是如何实现循环？</p>
<p>循环具体涉及到了几个函数的循环：<code>schedule-&gt;execute-&gt;goexit-&gt;goexit1-&gt;goexit0-&gt;schedule</code></p>
<h4 id="Schedule函数"><a href="#Schedule函数" class="headerlink" title="Schedule函数"></a>Schedule函数</h4><p>函数的第一段逻辑，主要会判断当前m是否存在绑定的g，如果存在，则暂停当前m，而后执行<code>lockedg</code>。Why？这一段不是主流程，稍后再看。</p>
<blockquote>
<p>什么情况下会从暂停m？</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if _g_.m.lockedg !&#x3D; 0 &#123;</span><br><span class="line">	stoplockedm()</span><br><span class="line">	execute(_g_.m.lockedg.ptr(), false) &#x2F;&#x2F; Never returns.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后就是<code>gcwaiting</code>变量的判断，该变量不为0的情况主要是在GC的STW阶段。如果是STW阶段，则会暂停当前的m，等到startTheWorld时，会将所有的p唤醒。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if sched.gcwaiting !&#x3D; 0 &#123;</span><br><span class="line">	gcstopm()</span><br><span class="line">	goto top</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面就是<code>runSafePointFn</code>这个名字，主要功能就是在GC前，需要打开所有的p读写屏障。而这个逻辑，就是简单的需要保证每个P都需要执行一遍。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if pp.runSafePointFn !&#x3D; 0 &#123;</span><br><span class="line">	runSafePointFn()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再之后就是执行当前p上挂载的定时器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">checkTimers(pp, 0)</span><br></pre></td></tr></table></figure>

<p>上述都是一些m特殊的处理流程，等处理完后，就需要开始寻找g来进行执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if gp &#x3D;&#x3D; nil &amp;&amp; gcBlackenEnabled !&#x3D; 0 &#123;</span><br><span class="line">	gp &#x3D; gcController.findRunnableGCWorker(_g_.m.p.ptr())</span><br><span class="line">	tryWakeP &#x3D; tryWakeP || gp !&#x3D; nil</span><br><span class="line">&#125;</span><br><span class="line">if gp &#x3D;&#x3D; nil &#123;</span><br><span class="line">	if _g_.m.p.ptr().schedtick%61 &#x3D;&#x3D; 0 &amp;&amp; sched.runqsize &gt; 0 &#123;</span><br><span class="line">		lock(&amp;sched.lock)</span><br><span class="line">		gp &#x3D; globrunqget(_g_.m.p.ptr(), 1)</span><br><span class="line">		unlock(&amp;sched.lock)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">if gp &#x3D;&#x3D; nil &#123;</span><br><span class="line">	gp, inheritTime &#x3D; runqget(_g_.m.p.ptr())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码，基本上也就是3块逻辑：优先执行gc的g、其次查看是否需要获取全局列表、最后查看当前p的列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if gp.lockedm !&#x3D; 0 &#123;</span><br><span class="line">	&#x2F;&#x2F; Hands off own p to the locked m,</span><br><span class="line">	&#x2F;&#x2F; then blocks waiting for a new p.</span><br><span class="line">	startlockedm(gp)</span><br><span class="line">	goto top</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">execute(gp, inheritTime)</span><br></pre></td></tr></table></figure>

<p>最后针对绑定的g进行特殊处理。否则就执行<code>execute</code>方法</p>
<blockquote>
<p>会从哪些地方去获取g？优先级是什么？</p>
</blockquote>
<h4 id="Execute函数"><a href="#Execute函数" class="headerlink" title="Execute函数"></a>Execute函数</h4><p>该函数主要功能切换当前上下文至指定的g中，具体源码如下，没有特别的逻辑，都是将g属性初始化一遍。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func execute(gp *g, inheritTime bool) &#123;</span><br><span class="line">	_g_ :&#x3D; getg()</span><br><span class="line"></span><br><span class="line">	_g_.m.curg &#x3D; gp</span><br><span class="line">	gp.m &#x3D; _g_.m</span><br><span class="line">	casgstatus(gp, _Grunnable, _Grunning)</span><br><span class="line">	gp.waitsince &#x3D; 0</span><br><span class="line">	gp.preempt &#x3D; false</span><br><span class="line">	gp.stackguard0 &#x3D; gp.stack.lo + _StackGuard</span><br><span class="line">	if !inheritTime &#123;</span><br><span class="line">		_g_.m.p.ptr().schedtick++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gogo(&amp;gp.sched)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而<code>gogo</code>方法是真正在汇编层切换寄存器的逻辑，传入的sched就是这个g的上下文信息，包含4个寄存器信息，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">TEXT runtime·gogo(SB), NOSPLIT, $16-8</span><br><span class="line">	MOVQ	buf+0(FP), BX		&#x2F;&#x2F; gobuf</span><br><span class="line">	MOVQ	gobuf_g(BX), DX</span><br><span class="line">	MOVQ	0(DX), CX		&#x2F;&#x2F; make sure g !&#x3D; nil</span><br><span class="line">	get_tls(CX)</span><br><span class="line">	MOVQ	DX, g(CX)		&#x2F;&#x2F; 保存g至tls中</span><br><span class="line">	&#x2F;&#x2F; 恢复sp，ax，dx，bp寄存器</span><br><span class="line">	MOVQ	gobuf_sp(BX), SP	&#x2F;&#x2F; restore SP</span><br><span class="line">	MOVQ	gobuf_ret(BX), AX</span><br><span class="line">	MOVQ	gobuf_ctxt(BX), DX</span><br><span class="line">	MOVQ	gobuf_bp(BX), BP</span><br><span class="line">	&#x2F;&#x2F; 清空gobuf</span><br><span class="line">	MOVQ	$0, gobuf_sp(BX)	&#x2F;&#x2F; clear to help garbage collector</span><br><span class="line">	MOVQ	$0, gobuf_ret(BX)</span><br><span class="line">	MOVQ	$0, gobuf_ctxt(BX)</span><br><span class="line">	MOVQ	$0, gobuf_bp(BX)</span><br><span class="line">	MOVQ	gobuf_pc(BX), BX</span><br><span class="line">	JMP	BX</span><br></pre></td></tr></table></figure>

<h4 id="Goexit函数"><a href="#Goexit函数" class="headerlink" title="Goexit函数"></a>Goexit函数</h4><p>goexit方法是当当前线程执行完毕后执行的析构方法，设置的方法为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">func gostartcallfn(gobuf *gobuf, fv *funcval) &#123;</span><br><span class="line">    var fn unsafe.Pointer</span><br><span class="line">    if fv !&#x3D; nil &#123;</span><br><span class="line">        fn &#x3D; unsafe.Pointer(fv.fn)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        fn &#x3D; unsafe.Pointer(funcPC(nilfunc))</span><br><span class="line">    &#125;</span><br><span class="line">    gostartcall(gobuf, fn, unsafe.Pointer(fv))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; adjust Gobuf as if it executed a call to fn with context ctxt</span><br><span class="line">&#x2F;&#x2F; and then did an immediate gosave.</span><br><span class="line">func gostartcall(buf *gobuf, fn, ctxt unsafe.Pointer) &#123;</span><br><span class="line">    sp :&#x3D; buf.sp</span><br><span class="line">    if sys.RegSize &gt; sys.PtrSize &#123;</span><br><span class="line">        sp -&#x3D; sys.PtrSize</span><br><span class="line">        *(*uintptr)(unsafe.Pointer(sp)) &#x3D; 0</span><br><span class="line">    &#125;</span><br><span class="line">    sp -&#x3D; sys.PtrSize</span><br><span class="line">    *(*uintptr)(unsafe.Pointer(sp)) &#x3D; buf.pc &#x2F;&#x2F; 注意这里，这个，这里的 buf.pc 实际上是 goexit 的 pc</span><br><span class="line">    buf.sp &#x3D; sp</span><br><span class="line">    buf.pc &#x3D; uintptr(fn)</span><br><span class="line">    buf.ctxt &#x3D; ctxt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 gostartcall 中把 newproc1 时设置到 buf.pc 中的 goexit 的函数地址放到了 goroutine 的栈顶，然后重新设置 buf.pc 为 goroutine 函数的位置。这样做的目的是为了在执行完任何 goroutine 的函数时，通过 RET 指令，都能从栈顶把 sp 保存的 goexit 的指令 pop 到 pc 寄存器，效果相当于任何 goroutine 执行函数执行完之后，都会去执行 runtime.goexit，完成一些清理工作后再进入 schedule。</p>
<p>当前流程只剩下<code>goexit-&gt;goexit1-&gt;goexit0</code>，代码还算可读，直接上代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">TEXT runtime·goexit(SB),NOSPLIT,$0-0</span><br><span class="line">	BYTE	$0x90	&#x2F;&#x2F; NOP</span><br><span class="line">	CALL	runtime·goexit1(SB)	&#x2F;&#x2F; does not return</span><br><span class="line">	&#x2F;&#x2F; traceback from goexit1 must hit code range of goexit</span><br><span class="line">	BYTE	$0x90	&#x2F;&#x2F; NOP</span><br><span class="line"></span><br><span class="line">	... ... </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Finishes execution of the current goroutine.</span><br><span class="line">func goexit1() &#123;</span><br><span class="line">	if raceenabled &#123;</span><br><span class="line">		racegoend()</span><br><span class="line">	&#125;</span><br><span class="line">	if trace.enabled &#123;</span><br><span class="line">		traceGoEnd()</span><br><span class="line">	&#125;</span><br><span class="line">	mcall(goexit0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在代码来看，goexit和goexit1目标只是切换到g0协程中并执行<code>goexit0</code>中，第一部分，大部分都是变量清空，并清空当前的g状态置为_Gdead。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">func goexit0(gp *g) &#123;</span><br><span class="line">	_g_ :&#x3D; getg()</span><br><span class="line"></span><br><span class="line">	casgstatus(gp, _Grunning, _Gdead)</span><br><span class="line">	if isSystemGoroutine(gp, false) &#123;</span><br><span class="line">		atomic.Xadd(&amp;sched.ngsys, -1)</span><br><span class="line">	&#125;</span><br><span class="line">	gp.m &#x3D; nil</span><br><span class="line">	locked :&#x3D; gp.lockedm !&#x3D; 0</span><br><span class="line">	gp.lockedm &#x3D; 0</span><br><span class="line">	_g_.m.lockedg &#x3D; 0</span><br><span class="line">	gp.preemptStop &#x3D; false</span><br><span class="line">	gp.paniconfault &#x3D; false</span><br><span class="line">	gp._defer &#x3D; nil &#x2F;&#x2F; should be true already but just in case.</span><br><span class="line">	gp._panic &#x3D; nil &#x2F;&#x2F; non-nil for Goexit during panic. points at stack-allocated data.</span><br><span class="line">	gp.writebuf &#x3D; nil</span><br><span class="line">	gp.waitreason &#x3D; 0</span><br><span class="line">	gp.param &#x3D; nil</span><br><span class="line">	gp.labels &#x3D; nil</span><br><span class="line">	gp.timer &#x3D; nil</span><br><span class="line">	if gcBlackenEnabled !&#x3D; 0 &amp;&amp; gp.gcAssistBytes &gt; 0 &#123;</span><br><span class="line">		scanCredit :&#x3D; int64(gcController.assistWorkPerByte * float64(gp.gcAssistBytes))</span><br><span class="line">		atomic.Xaddint64(&amp;gcController.bgScanCredit, scanCredit)</span><br><span class="line">		gp.gcAssistBytes &#x3D; 0</span><br><span class="line">	&#125;</span><br><span class="line">	dropg()</span><br></pre></td></tr></table></figure>

<p>清空完自身的g后，主要就剩下清理其他的信息，例如：写入g的队列中，清空m，进入调度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func goexit0(gp *g) &#123;</span><br><span class="line">	... ...</span><br><span class="line">	gfput(_g_.m.p.ptr(), gp)</span><br><span class="line">	if locked &#123;</span><br><span class="line">		if GOOS !&#x3D; &quot;plan9&quot; &#123; &#x2F;&#x2F; See golang.org&#x2F;issue&#x2F;22227.</span><br><span class="line">			gogo(&amp;_g_.m.g0.sched)</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			_g_.m.lockedExt &#x3D; 0</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	schedule()</span><br></pre></td></tr></table></figure>

<h2 id="待办事项"><a href="#待办事项" class="headerlink" title="待办事项"></a>待办事项</h2><ul>
<li>定时执行逻辑</li>
<li>锁定线程逻辑</li>
<li>tryWakeP逻辑</li>
<li>findrunnable逻辑</li>
<li>mcall、notesleep逻辑</li>
<li>inheritTime功能</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://artikell.github.io/2020/07/08/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Skyfire Lee">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Start Again">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/08/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-07-08 15:22:40 / 修改时间：15:14:28" itemprop="dateCreated datePublished" datetime="2020-07-08T15:22:40+08:00">2020-07-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Skyfire Lee</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Skyfire Lee</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
