<!doctype html>
<html lang="en">
    <head>
		
        <meta http-equiv="Content-Type" content="text/html" charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="description" content="">
        <link rel="shortcut icon" href="/asset/guolin.png"/>
        <link rel="canonical" href="http://guolinn.com/">
        <link rel="alternate" type="application/rss+xml" title="Skyfire Lee" href="/atom.xml">
        <title>Redis通信协议 | Artikell</title>
        <meta name="description" content="{{meta_description}}">

        <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
        <link rel="stylesheet" type="text/css" href="/styles/crisp.css">
        <meta name="HandheldFriendly" content="True" />
        <meta name="MobileOptimized" content="320" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->

    <meta name="generator" content="Hexo 4.2.1"></head>
    
		<body class="post-template">
	

        <header id="header">
            <a id="logo" href="/"><img src="/asset/guolin.png" alt="Artikell" /></a>
            <h1><a href="/">Skyfire Lee</a></h1>
            <p></p>
            <div id="follow-icons">
                  <a href="/atom.xml"><i class="fa fa-rss-square fa-2x"></i></a>
  </div>
<h6><a href="/about">About</a></h6>
        </header>

        <main id="content">
        

<article class="post">
  九月 13, 2021
  
    <span class="taglist">  &middot; 
    
    
      <a href='/tags/从0开始的Redis/'>从0开始的Redis</a> 
    
    </span>
  

  <h1 class="post-title">Redis通信协议</h1>
  <section class="post-content article-entry">
    <h2 id="零、带着问题出发"><a href="#零、带着问题出发" class="headerlink" title="零、带着问题出发"></a>零、带着问题出发</h2><ul>
<li>如何表示基本的类型：数字还是字符串</li>
<li>数组和对象有该如何表示</li>
<li>如何判断请求是否正常</li>
<li>数据不存在如何表示</li>
<li>pipeline中的命令如何发布</li>
<li>内联命令是如何支持的</li>
<li>发布和订阅在命令中是如何实现的</li>
</ul>
<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>redis 客户端和服务端之间通信的协议是RESP（REdis Serialization Protocol）。传输层使用TCP。RESP的特点是：</p>
<ul>
<li>实现容易</li>
<li>解析快</li>
<li>人类可读</li>
</ul>
<h2 id="二、数据类型-和协议格式"><a href="#二、数据类型-和协议格式" class="headerlink" title="二、数据类型 和协议格式"></a>二、数据类型 和协议格式</h2><p>RESP实际上是一个支持以下数据类型的序列化协议：简单字符串（Simple Strings），错误(Errors)，整数(Integers)，批量字符串（Bulk String）和数组（Arrays）。</p>
<p>RESP在Redis中用作请求 - 响应协议的方式如下：</p>
<ul>
<li>客户端将命令作为Bulk Strings的RESP数组发送到Redis服务器。</li>
<li>服务器根据命令实现回复一种RESP类型。</li>
</ul>
<p>在RESP中，某些数据的类型取决于第一个字节：</p>
<ul>
<li>对于简单字符串，回复的第一个字节是“+”</li>
<li>对于错误，回复的第一个字节是“ - ”</li>
<li>对于整数，回复的第一个字节是“：”</li>
<li>对于批量字符串，回复的第一个字节是“$”</li>
<li>对于数组，回复的第一个字节是“*”</li>
</ul>
<p>在RESP中，协议的不同部分始终以“\ r \ n”（CRLF）结束。</p>
<h2 id="三、请求、回复格式"><a href="#三、请求、回复格式" class="headerlink" title="三、请求、回复格式"></a>三、请求、回复格式</h2><h4 id="1、简单字符串（Simple-Strings）"><a href="#1、简单字符串（Simple-Strings）" class="headerlink" title="1、简单字符串（Simple Strings）"></a>1、简单字符串（Simple Strings）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+OK\r\n</span><br></pre></td></tr></table></figure>
<ul>
<li>固定开始，\r\n固定结束， 中间即为回复的内容。</li>
</ul>
<h4 id="2、错误-Errors"><a href="#2、错误-Errors" class="headerlink" title="2、错误(Errors)"></a>2、错误(Errors)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Error message\r\n</span><br></pre></td></tr></table></figure>
<p>类似简单字符串，但是开头用‘-’表示是错误信息。</p>
<p>Error 称为错误类型，“ - ”之后的第一个单词，直到第一个空格或换行符 ,常见的有ERR、WRONGTYPE、NOSCRIPT等。</p>
<p>message 表示错误信息。</p>
<p>以下是一些redis返回的错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-ERR unknown command &#39;foobar&#39;</span><br><span class="line">-WRONGTYPE Operation against a key holding the wrong kind of value</span><br><span class="line">-NOSCRIPT No matching script. Please use EVAL.</span><br><span class="line">-READONLY You can&#39;t write against a read only slave.</span><br><span class="line">-OOM command not allowed when used memory &gt; &#39;maxmemory&#39;.</span><br><span class="line">-EXECABORT Transaction discarded because of previous errors.</span><br><span class="line">-BUSYKEY Target key name already exists.</span><br></pre></td></tr></table></figure>
<h4 id="3、整数（Integers）"><a href="#3、整数（Integers）" class="headerlink" title="3、整数（Integers）"></a>3、整数（Integers）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:1000\r\n</span><br></pre></td></tr></table></figure>
<p>像INCR、LLEN、LASTSAVE等命令返回的都是整数表示增量编号、长度、时间。</p>
<p>像EXISTS或SISMEMBER之类类的命令将返回1表示true，0表示false</p>
<p>返回的整数保证在有符号的64位整数范围内。</p>
<h4 id="4、批量字符串（Bulk-strings）"><a href="#4、批量字符串（Bulk-strings）" class="headerlink" title="4、批量字符串（Bulk strings）"></a>4、批量字符串（Bulk strings）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$6\r\nfoobar\r\n</span><br></pre></td></tr></table></figure>
<p>Bulk Strings用于表示长度最大为512 MB的单个二进制安全字符串。</p>
<p>批量字符串按以下方式编码：</p>
<p>一个“$”字节后跟组成字符串的字节数（一个前缀长度），由CRLF终止。<br>实际的字符串数据。<br>最终的CRLF。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$0\r\n\r\n</span><br></pre></td></tr></table></figure>
<p>表示空字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$-1\r\n</span><br></pre></td></tr></table></figure>
<p>表示NULL</p>
<h4 id="5、数组（Arrays）"><a href="#5、数组（Arrays）" class="headerlink" title="5、数组（Arrays）"></a>5、数组（Arrays）</h4><p>RESP数组使用以下格式发送：</p>
<p>一个*字符作为第一个字节，后跟数组中的元素数作为十进制数，后跟CRLF。<br>Array的每个元素的附加RESP类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*0\r\n</span><br></pre></td></tr></table></figure>
<p>表示空数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*2\r\n$3\r\nfoo\r\n$3\r\nbar\r\n</span><br></pre></td></tr></table></figure>
<p>表示”foo”和”bar” 两个批量字符串数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*-1\r\n</span><br></pre></td></tr></table></figure>
<p>表示NULL数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*2\r\n</span><br><span class="line">*3\r\n</span><br><span class="line">:1\r\n</span><br><span class="line">:2\r\n</span><br><span class="line">:3\r\n</span><br><span class="line">*2\r\n</span><br><span class="line">+Foo\r\n</span><br><span class="line">-Bar\r\n</span><br></pre></td></tr></table></figure>

<p>表示一个由两个元素组成的数组，该数组包含三个整数1,2,3以及一个简单字符串和一个错误的数组。</p>
<h2 id="四、内联命令"><a href="#四、内联命令" class="headerlink" title="四、内联命令"></a>四、内联命令</h2><p>当你需要和 Redis 服务器进行沟通， 但又找不到 redis-cli ， 而手上只有 telnet 的时候， 你可以通过 Redis 特别为这种情形而设的内联命令格式来发送命令。</p>
<p>以下是一个客户端和服务器使用内联命令来进行交互的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">客户端： PING</span><br><span class="line">服务器： +PONG</span><br></pre></td></tr></table></figure>
<p>以下另一个返回整数值的内联命令的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">客户端： EXISTS somekey</span><br><span class="line">服务器： :0</span><br></pre></td></tr></table></figure>
<p>因为没有了统一请求协议中的 “*” 项来声明参数的数量， 所以在 telnet 会话输入命令的时候， 必须使用空格来分割各个参数， 服务器在接收到数据之后， 会按空格对用户的输入进行分析（parse）， 并获取其中的命令参数。</p>
<h2 id="五、多命令和流水线"><a href="#五、多命令和流水线" class="headerlink" title="五、多命令和流水线"></a>五、多命令和流水线</h2><p>客户端可以通过流水线， 在一次写入操作中发送多个命令：</p>
<ul>
<li>在发送新命令之前， 无须阅读前一个命令的回复。</li>
<li>多个命令的回复会在最后一并返回。</li>
</ul>
<h2 id="六、订阅和发布"><a href="#六、订阅和发布" class="headerlink" title="六、订阅和发布"></a>六、订阅和发布</h2><p>SUBSCRIBE、UNSUBSCRIBE  和 PUBLISH三个命令实现了发布与订阅信息泛型（Publish/Subscribe messaging paradigm）， 在这个实现中， 发送者（发送信息的客户端）不是将信息直接发送给特定的接收者（接收信息的客户端）， 而是将信息发送给频道（channel）， 然后由频道将信息转发给所有对这个频道感兴趣的订阅者。</p>
<p>发送者无须知道任何关于订阅者的信息， 而订阅者也无须知道是那个客户端给它发送信息， 它只要关注自己感兴趣的频道即可。</p>
<p>对发布者和订阅者进行解构（decoupling）， 可以极大地提高系统的扩展性（scalability）， 并得到一个更动态的网络拓扑（network topology）。</p>
<p>比如说， 要订阅频道 foo 和 bar ， 客户端可以使用频道名字作为参数来调用 SUBSCRIBE 命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SUBSCRIBE foo bar</span><br></pre></td></tr></table></figure>
<p>当有客户端发送信息到这些频道时， Redis 会将传入的信息推送到所有订阅这些频道的客户端里面。</p>
<p>正在订阅频道的客户端不应该发送除 SUBSCRIBE 和 UNSUBSCRIBE 之外的其他命令。 其中， SUBSCRIBE 可以用于订阅更多频道， 而 UNSUBSCRIBE 则可以用于退订已订阅的一个或多个频道。</p>
<p>SUBSCRIBE 和 UNSUBSCRIBE 的执行结果会以信息的形式返回， 客户端可以通过分析所接收信息的第一个元素， 从而判断所收到的内容是一条真正的信息， 还是 SUBSCRIBE 或 UNSUBSCRIBE 命令的操作结果。</p>
<p>频道转发的每条信息都是一条带有三个元素的多条批量回复（multi-bulk reply）。</p>
<p>信息的第一个元素标识了信息的类型：</p>
<ul>
<li>subscribe ： 表示当前客户端成功地订阅了信息第二个元素所指示的频道。 而信息的第三个元素则记录了目前客户端已订阅频道的总数。</li>
<li>unsubscribe ： 表示当前客户端成功地退订了信息第二个元素所指示的频道。 信息的第三个元素记录了客户端目前仍在订阅的频道数量。 当客户端订阅的频道数量降为 0 时， 客户端不再订阅任何频道， 它可以像往常一样， 执行任何 Redis 命令。</li>
<li>message ： 表示这条信息是由某个客户端执行 PUBLISH 命令所发送的， 真正的信息。 信息的第二个元素是信息来源的频道， 而第三个元素则是信息的内容。</li>
</ul>
<p>举个例子， 如果客户端执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SUBSCRIBE first second</span><br></pre></td></tr></table></figure>
<p>那么它将收到以下回复：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;first&quot;</span><br><span class="line">3) (integer) 1</span><br><span class="line"> </span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;second&quot;</span><br><span class="line">3) (integer) 2</span><br></pre></td></tr></table></figure>
<p>如果在这时， 另一个客户端执行以下 PUBLISH 命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; PUBLISH second Hello</span><br></pre></td></tr></table></figure>
<p>那么之前订阅了 second 频道的客户端将收到以下信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1) &quot;message&quot;</span><br><span class="line">2) &quot;second&quot;</span><br><span class="line">3) &quot;hello&quot;</span><br></pre></td></tr></table></figure>
<p>当订阅者决定退订所有频道时， 它可以执行一个无参数的 UNSUBSCRIBE 命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; UNSUBSCRIBE</span><br></pre></td></tr></table></figure>
<p>这个命令将接到以下回复：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1) &quot;unsubscribe&quot;</span><br><span class="line">2) &quot;second&quot;</span><br><span class="line">3) (integer) 1</span><br><span class="line"> </span><br><span class="line">1) &quot;unsubscribe&quot;</span><br><span class="line">2) &quot;first&quot;</span><br><span class="line">3) (integer) 0</span><br></pre></td></tr></table></figure>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://blog.csdn.net/u014608280/article/details/84586042" target="_blank" rel="noopener">https://blog.csdn.net/u014608280/article/details/84586042</a></li>
</ul>

  </section>
  <footer class="post-footer">
    <!--
    <section class="author">
      <h4>Skyfire Lee</h4>
      <p></p>
    </section>
    -->
  </footer>
</article>

<nav class="pagination" role="pagination">
    
    <a class="newer-posts" href="/2021/09/13/re0-redis-event/">
        ← prev <!--Redis事件模型-->
    </a>
    
    <span class="page-number">•</span>
    
    <a class="older-posts" href="/2021/09/13/re0-system/">
        <!--从0开始的操作系统学习--> next →
    </a>
    
</nav>


        </main>
        <footer id="footer">
            <section id="footer-message">&copy; 2022 Skyfire Lee. All rights reserved. Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. <a href="https://github.com/guolin/crisp-hexo-theme" target="_blank">crisp</a> theme by <a href="guolin.github.io" target="_blank">Guo Lin</a>.</section>
        </footer>
    </body>
</html>


