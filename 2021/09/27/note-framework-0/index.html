<!doctype html>
<html lang="en">
    <head>
		
        <meta http-equiv="Content-Type" content="text/html" charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="description" content="">
        <link rel="shortcut icon" href="/asset/guolin.png"/>
        <link rel="canonical" href="http://guolinn.com/">
        <link rel="alternate" type="application/rss+xml" title="Skyfire Lee" href="/atom.xml">
        <title>读书笔记：从0开始学框架 | Artikell</title>
        <meta name="description" content="{{meta_description}}">

        <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
        <link rel="stylesheet" type="text/css" href="/styles/crisp.css">
        <meta name="HandheldFriendly" content="True" />
        <meta name="MobileOptimized" content="320" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->

    <meta name="generator" content="Hexo 4.2.1"></head>
    
		<body class="post-template">
	

        <header id="header">
            <a id="logo" href="/"><img src="/asset/guolin.png" alt="Artikell" /></a>
            <h1><a href="/">Skyfire Lee</a></h1>
            <p></p>
            <div id="follow-icons">
                  <a href="/atom.xml"><i class="fa fa-rss-square fa-2x"></i></a>
  </div>
<h6><a href="/about">About</a></h6>
        </header>

        <main id="content">
        

<article class="post">
  九月 27, 2021
  
    <span class="taglist">  &middot; 
    
    
      <a href='/tags/读书笔记/'>读书笔记</a> 
    
    </span>
  

  <h1 class="post-title">读书笔记：从0开始学框架</h1>
  <section class="post-content article-entry">
    <h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li>基础架构</li>
<li>高性能架构模式</li>
<li>高可用架构模式</li>
<li>可扩展架构模式</li>
<li>架构实战</li>
</ul>
<hr>
<h2 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h2><p>什么是架构？</p>
<p>架构是如何产生的？</p>
<p>架构的目的是什么？</p>
<p>架构设计有什么原则？</p>
<hr>
<h3 id="什么是架构？"><a href="#什么是架构？" class="headerlink" title="什么是架构？"></a>什么是架构？</h3><p>架构包含以下几个关键词：</p>
<ol>
<li>系统与子系统</li>
<li>模块与组件</li>
<li>框架与架构</li>
</ol>
<hr>
<h3 id="什么是架构？-1"><a href="#什么是架构？-1" class="headerlink" title="什么是架构？"></a>什么是架构？</h3><p>参考维基百科的定义，我将架构重新定义为：<strong>软件架构指软件系统的顶层结构</strong>。</p>
<ul>
<li>首先，“系统是一群关联个体组成”，这些“个体”可以是“子系统”“模块”“组件”等；架构需要明确系统包含哪些“个体”。</li>
<li>其次，系统中的个体需要“根据某种规则”运作，架构需要明确个体运作和协作的规则。</li>
<li>第三，维基百科定义的架构用到了“基础结构”这个说法，我改为“顶层结构”，可以更好地区分系统和子系统，避免将系统架构和子系统架构混淆在一起导致架构层次混乱。</li>
</ul>
<hr>
<h3 id="架构的背景"><a href="#架构的背景" class="headerlink" title="架构的背景"></a>架构的背景</h3><ul>
<li>机器语言（<strong>1940 年之前</strong>）：太难写、太难读、太难改！</li>
<li>汇编语言（<strong>20 世纪 40 年代</strong>）：解决了机器语言读写复杂的问题，但本质上还是面向机器的</li>
<li>高级语言（<strong>20 世纪 50 年代</strong>）：软件的规模和复杂度的大大增加，软件质量低下、项目无法如期完成、项目严重超支等</li>
<li>第一次软件危机与结构化程序设计（<strong>20 世纪 60 年代~20 世纪 70 年代</strong>）：软件生产力远远跟不上硬件和业务的发展</li>
<li>第二次软件危机与面向对象（<strong>20 世纪 80 年代</strong>）：软件的“扩展”变得非常复杂。</li>
</ul>
<hr>
<h3 id="软件架构的历史背景"><a href="#软件架构的历史背景" class="headerlink" title="软件架构的历史背景"></a>软件架构的历史背景</h3><blockquote>
<p>“When systems are constructed from many components, the organization of the overall system-the software architecture-presents a new set of design problems.”</p>
</blockquote>
<p>简单翻译一下：随着软件系统规模的增加，计算相关的算法和数据结构不再构成主要的设计问题；当系统由许多部分组成时，整个系统的组织，也就是所说的“软件架构”，导致了一系列新的设计问题。</p>
<hr>
<h3 id="架构设计的误区"><a href="#架构设计的误区" class="headerlink" title="架构设计的误区"></a>架构设计的误区</h3><ol>
<li>因为架构很重要，所以要做架构设计</li>
<li>不是每个系统都要做架构设计吗</li>
<li>公司流程要求系统开发过程中必须有架构设计</li>
<li>为了高性能、高可用、可扩展，所以要做架构设计</li>
</ol>
<hr>
<h3 id="架构设计的真正目的"><a href="#架构设计的真正目的" class="headerlink" title="架构设计的真正目的"></a>架构设计的真正目的</h3><blockquote>
<p>架构设计的主要目的是为了解决软件系统复杂度带来的问题。</p>
</blockquote>
<p>有的放矢，而不是贪大求全。</p>
<hr>
<h3 id="复杂度来源"><a href="#复杂度来源" class="headerlink" title="复杂度来源"></a>复杂度来源</h3><ol>
<li>高性能</li>
<li>高可用</li>
<li>可扩展</li>
<li>低成本、安全、规模</li>
</ol>
<hr>
<h3 id="高性能复杂度"><a href="#高性能复杂度" class="headerlink" title="高性能复杂度"></a>高性能复杂度</h3><ul>
<li>单机复杂度：多进程、多线程的协作</li>
<li>集群复杂度：任务分配和任务拆解</li>
</ul>
<hr>
<h3 id="高可用复杂度"><a href="#高可用复杂度" class="headerlink" title="高可用复杂度"></a>高可用复杂度</h3><blockquote>
<p>系统无中断地执行其功能的能力，代表系统的可用性程度，是进行系统设计时的准则之一。</p>
</blockquote>
<p><strong>“冗余”</strong>是高可用的最终解决方案</p>
<p>高性能增加机器目的在于“扩展”处理性能；高可用增加机器目的在于“冗余”处理单元。</p>
<hr>
<h3 id="高可用复杂度-1"><a href="#高可用复杂度-1" class="headerlink" title="高可用复杂度"></a>高可用复杂度</h3><ul>
<li><strong>计算高可用</strong>：无论在哪台机器上进行计算，同样的算法和输入数据，产出的结果都是一样的</li>
<li><strong>存储高可用</strong>：如何减少或者规避数据不一致对业务造成的影响。</li>
<li><strong>高可用状态决策</strong>：通过冗余来实现的高可用系统，状态决策本质上就不可能做到完全正确</li>
</ul>
<p><strong>决策手段</strong>：独裁式、协商式、民主式</p>
<hr>
<h3 id="可扩展性复杂度"><a href="#可扩展性复杂度" class="headerlink" title="可扩展性复杂度"></a>可扩展性复杂度</h3><p>设计具备良好可扩展性的系统，有两个基本条件：<strong>正确预测变化</strong>、<strong>完美封装变化</strong>。</p>
<p>预测变化的复杂性在于：</p>
<ul>
<li>不能每个设计点<strong>都考虑</strong>可扩展性。</li>
<li>不能完全<strong>不考虑</strong>可扩展性。</li>
<li>所有的预测都<strong>存在出错</strong>的可能性。</li>
</ul>
<hr>
<h3 id="可扩展性复杂度-1"><a href="#可扩展性复杂度-1" class="headerlink" title="可扩展性复杂度"></a>可扩展性复杂度</h3><p>唯一不变的是变化，而应对变化的手段就是将变化和不变的分离开：</p>
<ol>
<li>将“变化”封装在一个“变化层”，将不变的部分封装在一个独立的“稳定层”：<strong>ORM的实现</strong></li>
<li>提炼出一个“抽象层”和一个“实现层”：<strong>规则引擎和设计模式</strong></li>
</ol>
<hr>
<h3 id="复杂度来源：低成本、安全、规模"><a href="#复杂度来源：低成本、安全、规模" class="headerlink" title="复杂度来源：低成本、安全、规模"></a>复杂度来源：低成本、安全、规模</h3><ul>
<li>新技术带动低成本<ul>
<li>存储侧：NoSQL、全文搜索引擎、Hadoop</li>
<li>系统侧：HipHop PHP、Redis/MC + SSD Cache + MySQL、Kafka、</li>
</ul>
</li>
<li>安全需要多方考虑<ul>
<li>功能安全：就是“防小偷”。</li>
<li>架构安全：就是“防强盗”</li>
</ul>
</li>
<li>量变引起质变<ul>
<li>功能越来越多，导致系统复杂度指数级上升</li>
<li>数据越来越多，系统复杂度发生质变</li>
</ul>
</li>
</ul>
<hr>
<h3 id="架构设计原则"><a href="#架构设计原则" class="headerlink" title="架构设计原则"></a>架构设计原则</h3><ul>
<li>合适原则宣言：“合适优于业界领先”。</li>
<li>简单原则宣言：“简单优于复杂”。</li>
<li>演化原则宣言：“演化优于一步到位”。</li>
</ul>
<hr>
<h3 id="架构设计流程"><a href="#架构设计流程" class="headerlink" title="架构设计流程"></a>架构设计流程</h3><ul>
<li>识别复杂度：架构设计的本质目的是为了解决软件系统的复杂性</li>
<li>设计备选方案、评估和选择备选方案</li>
<li>详细方案设计：将方案涉及的关键技术细节给确定下来</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>随着软件系统规模的增加，引发了架构设计</li>
<li>架构设计是为了解决复杂度而产生</li>
<li>架构设计遵循适合、简单、演变三原则</li>
<li>架构需要从目的、方案、完善逐步进行</li>
</ol>
<hr>
<h2 id="高性能架构模式"><a href="#高性能架构模式" class="headerlink" title="高性能架构模式"></a>高性能架构模式</h2><p>高性能复杂度前文中是从单机到多机的复杂度增加，而将架构拆解开来，可以分为计算高性能和存储高性能。毕竟程序是存储+计算来实现。</p>
<p>存储高性能</p>
<ul>
<li>数据库高性能</li>
<li>Nosql高性能</li>
<li>缓存高性能</li>
</ul>
<p>计算高性能</p>
<ul>
<li>服务器高性能</li>
<li>多机负载均衡</li>
</ul>
<hr>
<h3 id="存储高性能（数据库高性能）"><a href="#存储高性能（数据库高性能）" class="headerlink" title="存储高性能（数据库高性能）"></a>存储高性能（数据库高性能）</h3><p>高性能数据库集群的第一种方式是“<strong>读写分离</strong>”，其本质是将访问压力分散到集群中的多个节点，但是没有分散存储压力；</p>
<p>第二种方式是“<strong>分库分表</strong>”，既可以分散访问压力，又可以分散存储压力。</p>
<hr>
<h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p>读写分离的实现逻辑并不复杂，但有两个细节点将引入设计复杂度：<strong>主从复制延迟</strong>和<strong>分配机制</strong>。</p>
<ul>
<li>复制延迟<ul>
<li>写操作后的读操作指定发给数据库主服务器</li>
<li>读从机失败后再读一次主机</li>
<li>关键业务读写操作全部指向主机，非关键业务采用读写分离</li>
</ul>
</li>
<li>分配机制<ul>
<li>程序代码封装：实现简单、无法通用</li>
<li>中间件封装</li>
</ul>
</li>
</ul>
<hr>
<h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><p><strong>核心问题</strong>：数据量太大，读写的性能会下降、数据库备份和恢复需要耗费很长时间、极端情况下丢失数据的风险越高</p>
<p>业务分库：业务分库指的是按照业务模块将数据分散到不同的数据库服务器</p>
<ul>
<li>join 操作问题</li>
<li>事务问题</li>
<li>成本问题</li>
</ul>
<p>数据分表：同一业务的单表数据也会达到单台数据库服务器的处理瓶颈，需要进行垂直分表和水平分表</p>
<ul>
<li>垂直分表</li>
<li>水平分表</li>
<li>路由</li>
</ul>
<hr>
<h3 id="高性能NoSQL起源"><a href="#高性能NoSQL起源" class="headerlink" title="高性能NoSQL起源"></a>高性能NoSQL起源</h3><p>关系数据库存在如下缺点：</p>
<ol>
<li>关系数据库存储的是行记录，无法存储数据结构</li>
<li>关系数据库的 schema 扩展很不方便</li>
<li>关系数据库在大数据场景下 I/O 较高</li>
<li>关系数据库的全文搜索功能比较弱</li>
</ol>
<hr>
<h3 id="高性能NoSQL分类"><a href="#高性能NoSQL分类" class="headerlink" title="高性能NoSQL分类"></a>高性能NoSQL分类</h3><ul>
<li><p>K-V 存储：解决关系数据库无法存储数据结构的问题，以 Redis 为代表。</p>
</li>
<li><p>文档数据库：解决关系数据库强 schema 约束的问题，以 MongoDB 为代表。</p>
</li>
<li><p>列式数据库：解决关系数据库大数据场景下的 I/O 问题，以 HBase 为代表。</p>
</li>
<li><p>全文搜索引擎：解决关系数据库的全文搜索性能问题，以 Elasticsearch 为代表。</p>
</li>
</ul>
<hr>
<h3 id="高性能缓存架构"><a href="#高性能缓存架构" class="headerlink" title="高性能缓存架构"></a>高性能缓存架构</h3><p>虽然我们可以通过各种手段来提升存储系统的性能，但在某些复杂的业务场景下，单纯依靠存储系统的性能提升不够的，典型的场景有：</p>
<ol>
<li>需要经过复杂运算后得出的数据，存储系统无能为力</li>
<li>读多写少的数据，存储系统有心无力</li>
</ol>
<p>缓存虽然能够大大减轻存储系统的压力，但同时也给架构引入了更多复杂性。</p>
<hr>
<h3 id="高性能缓存架构的问题"><a href="#高性能缓存架构的问题" class="headerlink" title="高性能缓存架构的问题"></a>高性能缓存架构的问题</h3><ul>
<li>缓存穿透：</li>
<li>缓存雪崩：</li>
<li>缓存热点：</li>
</ul>
<hr>
<h3 id="单服务器的高性能"><a href="#单服务器的高性能" class="headerlink" title="单服务器的高性能"></a>单服务器的高性能</h3><p>单服务器高性能的关键之一就是服务器采取的并发模型，并发模型有如下两个关键设计点：</p>
<ul>
<li><p>服务器如何管理连接。</p>
</li>
<li><p>服务器如何处理请求。</p>
</li>
</ul>
<p>以上两个设计点最终都和操作系统的 I/O 模型及进程模型相关。</p>
<ul>
<li>I/O 模型：阻塞、非阻塞、同步、异步。</li>
<li>进程模型：单进程、多进程、多线程。</li>
</ul>
<p>其中对应的网络编程模型有：PPC、TPC、Reactor、Proactor。</p>
<hr>
<h4 id="PPC和TPC"><a href="#PPC和TPC" class="headerlink" title="PPC和TPC"></a>PPC和TPC</h4><p>PPC 是 Process Per Connection 的缩写，其含义是指每次有新的连接就新建一个进程去专门处理这个连接的请求，这是传统的 UNIX 网络服务器所采用的模型。</p>
<ul>
<li>fork 代价高</li>
<li>父子进程通信复杂</li>
<li>支持的并发连接数量有限</li>
</ul>
<p>TPC 是 Thread Per Connection 的缩写，其含义是指每次有新的连接就新建一个线程去专门处理这个连接的请求。</p>
<ul>
<li>代价低，但并不是没有代价</li>
<li>线程间的互斥和共享又引入了复杂度</li>
<li>多线程会出现互相影响的情况</li>
</ul>
<hr>
<p>PPC和TPC其实是很大的浪费</p>
<p>引入资源池的处理方式后，会引出一个新的问题：进程如何才能高效地处理多个连接的业务？</p>
<p>解决这个问题的最简单的方式是将 read 操作改为非阻塞，然后进程不断地轮询多个连接。</p>
<p>如果一个进程处理几千上万的连接，则轮询的效率是很低的。</p>
<hr>
<h3 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h3><p>为了能够更好地解决上述问题，很容易可以想到，只有当连接上有数据的时候进程才去处理，这就是 I/O 多路复用技术的来源。</p>
<ul>
<li><p>当多条连接共用一个阻塞对象后，进程只需要在一个阻塞对象上等待，而无须再轮询所有连接，常见的实现方式有 select、epoll、kqueue 等。</p>
</li>
<li><p>当某条连接有新的数据可以处理时，操作系统会通知进程，进程从阻塞状态返回，开始进行业务处理。</p>
</li>
</ul>
<p>I/O 多路复用结合线程池，完美地解决了 PPC 和 TPC 的问题，而且“大神们”给它取了一个很牛的名字：Reactor，中文是“反应堆”。</p>
<p>Reactor 模式的核心组成部分包括 Reactor 和处理资源池（进程池或线程池），其中 Reactor 负责监听和分配事件，处理资源池负责处理事件。</p>
<hr>
<h3 id="Proactor模式"><a href="#Proactor模式" class="headerlink" title="Proactor模式"></a>Proactor模式</h3><p>Reactor 是非阻塞同步网络模型，因为真正的 read 和 send 操作都需要用户进程同步操作。</p>
<p>如果把 I/O 操作改为异步就能够进一步提升性能，这就是异步网络模型 Proactor。</p>
<p>Proactor 中文翻译为“前摄器”比较难理解，与其类似的单词是 proactive，含义为“主动的”，因此我们照猫画虎翻译为“主动器”反而更好理解。</p>
<p>理论上 Proactor 比 Reactor 效率要高一些，异步 I/O 能够充分利用 DMA 特性，让 I/O 操作与计算重叠，但要实现真正的异步 I/O，操作系统需要做大量的工作。</p>
<hr>
<h3 id="集群负载均衡"><a href="#集群负载均衡" class="headerlink" title="集群负载均衡"></a>集群负载均衡</h3><p>高性能集群的本质很简单，通过增加更多的服务器来提升系统整体的计算能力。</p>
<p>高性能集群的复杂性主要体现在需要增加一个任务分配器，以及为任务选择一个合适的任务分配算法</p>
<p>负载均衡分类</p>
<ul>
<li>DNS 负载均衡</li>
<li>硬件负载均衡</li>
<li>软件负载均衡</li>
</ul>
<hr>
<h4 id="DNS-负载均衡"><a href="#DNS-负载均衡" class="headerlink" title="DNS 负载均衡"></a>DNS 负载均衡</h4><p>优点有：</p>
<ul>
<li>简单、成本低：负载均衡工作交给 DNS 服务器处理，无须自己开发或者维护负载均衡设备。</li>
<li>就近访问，提升访问速度：DNS 解析时可以根据请求来源 IP，解析成距离用户最近的服务器地址，可以加快访问速度，改善性能。</li>
</ul>
<p>缺点有：</p>
<ul>
<li>更新不及时：DNS 缓存的时间比较长，修改 DNS 配置后，由于缓存的原因，还是有很多用户会继续访问修改前的 IP，这样的访问会失败，达不到负载均衡的目的，并且也影响用户正常使用业务。</li>
<li>扩展性差：DNS 负载均衡的控制权在域名商那里，无法根据业务特点针对其做更多的定制化功能和扩展特性。</li>
<li>分配策略比较简单：DNS 负载均衡支持的算法少；不能区分服务器的差异（不能根据系统与服务的状态来判断负载）；也无法感知后端服务器的状态。</li>
</ul>
<p>针对 DNS 负载均衡的一些缺点，对于时延和故障敏感的业务，有一些公司自己实现了 HTTP-DNS 的功能，即使用 HTTP 协议实现一个私有的 DNS 系统。这样的方案和通用的 DNS 优缺点正好相反。</p>
<hr>
<h4 id="硬件负载均衡"><a href="#硬件负载均衡" class="headerlink" title="硬件负载均衡"></a>硬件负载均衡</h4><p>优点是：</p>
<ul>
<li>功能强大：全面支持各层级的负载均衡，支持全面的负载均衡算法，支持全局负载均衡。</li>
<li>性能强大：对比一下，软件负载均衡支持到 10 万级并发已经很厉害了，硬件负载均衡可以支持 100 万以上的并发。</li>
<li>稳定性高：商用硬件负载均衡，经过了良好的严格测试，经过大规模使用，稳定性高。</li>
<li>支持安全防护：硬件均衡设备除具备负载均衡功能外，还具备防火墙、防 DDoS 攻击等安全功能。</li>
</ul>
<p>缺点是：</p>
<ul>
<li>价格昂贵：最普通的一台 F5 就是一台“马 6”，好一点的就是“Q7”了。</li>
<li>扩展能力差：硬件设备，可以根据业务进行配置，但无法进行扩展和定制。</li>
</ul>
<hr>
<h4 id="软件负载均衡"><a href="#软件负载均衡" class="headerlink" title="软件负载均衡"></a>软件负载均衡</h4><p>常见的有 Nginx 和 LVS，其中 Nginx 是软件的 7 层负载均衡，LVS 是 Linux 内核的 4 层负载均衡。4 层和 7 层的区别就在于协议和灵活性</p>
<p>优点：</p>
<ul>
<li>简单：无论是部署还是维护都比较简单。</li>
<li>便宜：只要买个 Linux 服务器，装上软件即可。</li>
<li>灵活：4 层和 7 层负载均衡可以根据业务进行选择；也可以根据业务进行比较方便的扩展，例如，可以通过 Nginx 的插件来实现业务的定制化功能。</li>
</ul>
<p>缺点：</p>
<ul>
<li>性能一般：一个 Nginx 大约能支撑 5 万并发。</li>
<li>功能没有硬件负载均衡那么强大。</li>
<li>一般不具备防火墙和防 DDoS 攻击等安全功能。</li>
</ul>
<hr>
<h3 id="负载均衡典型架构"><a href="#负载均衡典型架构" class="headerlink" title="负载均衡典型架构"></a>负载均衡典型架构</h3><p>基本原则：DNS 负载均衡用于实现地理级别的负载均衡；硬件负载均衡用于实现集群级别的负载均衡；软件负载均衡用于实现机器级别的负载均衡。</p>
<hr>
<h3 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h3><ul>
<li><strong>任务平分类</strong>：负载均衡系统将收到的任务平均分配给服务器进行处理，这里的“平均”可以是绝对数量的平均，也可以是比例或者权重上的平均。</li>
<li><strong>负载均衡类</strong>：负载均衡系统根据服务器的负载来进行分配，这里的负载并不一定是通常意义上我们说的“CPU 负载”，而是系统当前的压力，可以用 CPU 负载来衡量，也可以用连接数、I/O 使用率、网卡吞吐量等来衡量系统的压力。</li>
<li><strong>性能最优类</strong>：负载均衡系统根据服务器的响应时间来进行任务分配，优先将新任务分配给响应最快的服务器。</li>
<li><strong>Hash 类</strong>：负载均衡系统根据任务中的某些关键信息进行 Hash 运算，将相同 Hash 值的请求分配到同一台服务器上。常见的有源地址 Hash、目标地址 Hash、session id hash、用户 ID Hash 等。</li>
</ul>
<hr>
<h2 id="高可用架构模式"><a href="#高可用架构模式" class="headerlink" title="高可用架构模式"></a>高可用架构模式</h2><p>高可用架构更多核心是探讨高可用状态决策方式。</p>
<hr>
<h4 id="CAP模型"><a href="#CAP模型" class="headerlink" title="CAP模型"></a>CAP模型</h4><p>第一版解释：</p>
<blockquote>
<p>对于一个分布式计算系统，不可能同时满足一致性（Consistence）、可用性（Availability）、分区容错性（Partition Tolerance）三个设计约束。</p>
</blockquote>
<p>第二版解释：</p>
<blockquote>
<p>在一个分布式系统（指互相连接并共享数据的节点的集合）中，当涉及读写操作时，只能保证一致性（Consistence）、可用性（Availability）、分区容错性（Partition Tolerance）三者中的两个，另外一个必须被牺牲。</p>
</blockquote>
<p>差异点：属于需要共享数据，且只关注与读写功能</p>
<hr>
<h3 id="CAP模型细节"><a href="#CAP模型细节" class="headerlink" title="CAP模型细节"></a>CAP模型细节</h3><h4 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h4><p>第一版解释：</p>
<blockquote>
<p>所有节点在同一时刻都能看到相同的数据。</p>
</blockquote>
<p>第二版解释：</p>
<blockquote>
<p>对某个指定的客户端来说，读操作保证能够返回最新的写操作结果。</p>
</blockquote>
<p>角色从node变成了client，只需要保证观察者能读取到最新数据即可。</p>
<hr>
<h4 id="可用性（Availability）"><a href="#可用性（Availability）" class="headerlink" title="可用性（Availability）"></a>可用性（Availability）</h4><p>第一版解释：</p>
<blockquote>
<p>每个请求都能得到成功或者失败的响应。</p>
</blockquote>
<p>第二版解释：</p>
<blockquote>
<p>非故障的节点在合理的时间内返回合理的响应（不是错误和超时的响应）。</p>
</blockquote>
<p>第二版明确了不能超时、不能出错，结果是合理的，注意没有说“正确”的结果</p>
<hr>
<h4 id="分区容忍性（Partition-Tolerance）"><a href="#分区容忍性（Partition-Tolerance）" class="headerlink" title="分区容忍性（Partition Tolerance）"></a>分区容忍性（Partition Tolerance）</h4><p>第一版解释：</p>
<blockquote>
<p>出现消息丢失或者分区错误时系统能够继续运行。</p>
</blockquote>
<p>第二版解释：</p>
<blockquote>
<p>当出现网络分区后，系统能够继续“履行职责”。</p>
</blockquote>
<p>第二版描述了更多的异常情况，而非消息丢失。同时强调履行职责，而非运行。</p>
<hr>
<h4 id="三者冲突关系"><a href="#三者冲突关系" class="headerlink" title="三者冲突关系"></a>三者冲突关系</h4><p>P是分布式系统的基础，因为如果P无法实现，那C就无法保证写入，必然导致A无法保证。</p>
<hr>
<h3 id="CAP模型细节-1"><a href="#CAP模型细节-1" class="headerlink" title="CAP模型细节"></a>CAP模型细节</h3><p>参考文献：<a href="https://www.infoq.cn/article/cap-twelve-years-later-how-the-rules-have-changed/" target="_blank" rel="noopener">CAP 理论十二年回顾：”规则”变了</a></p>
<ol>
<li>“三选二”的公式一直存在着误导性，它会过分简单化各性质之间的相互关系。</li>
<li>因为分区很少出现，CAP 在大多数时候允许完美的 C 和 A</li>
<li>当分区存在或可感知其影响的情况下，就要预备一种策略去探知分区并显式处理其影响</li>
</ol>
<p>策略应分为三个步骤：探知分区发生，进入显式的分区模式以限制某些操作，启动恢复过程以恢复数据一致性并补偿分区期间发生的错误。</p>
<hr>
<h3 id="ACID、BASE、CAP"><a href="#ACID、BASE、CAP" class="headerlink" title="ACID、BASE、CAP"></a>ACID、BASE、CAP</h3><p>ACID 和 BASE 代表了两种截然相反的设计哲学，分处一致性 - 可用性分布图谱的两极。ACID 注重一致性，是数据库的传统设计思路。</p>
<p>BASE 理论本质上是对 CAP 的延伸和补充，更具体地说，是对 CAP 中 AP 方案的一个补充。前面在剖析 CAP 理论时，提到了其实和 BASE 相关的两点：</p>
<ul>
<li>CAP 理论是忽略延时的，而实际应用中延时是无法避免的。</li>
<li>AP 方案中牺牲一致性只是指分区期间，而不是永远放弃一致性。</li>
</ul>
<p>综合上面的分析，ACID 是数据库事务完整性的理论，CAP 是分布式系统设计理论，BASE 是 CAP 理论中 AP 方案的延伸。</p>
<hr>
<h3 id="高可用存储架构：双机架构"><a href="#高可用存储架构：双机架构" class="headerlink" title="高可用存储架构：双机架构"></a>高可用存储架构：双机架构</h3><p>存储高可用方案的本质都是通过将数据复制到多个存储设备，通过数据冗余的方式来实现高可用</p>
<p>其复杂性主要体现在如何应对复制延迟和中断导致的数据不一致问题。因此，对任何一个高可用存储方案，我们需要从以下几个方面去进行思考和分析：</p>
<ul>
<li>数据如何复制？</li>
<li>各个节点的职责是什么？</li>
<li>如何应对复制延迟？</li>
<li>如何应对复制中断？</li>
</ul>
<p>常见的高可用存储架构有主备、主从、主主、集群、分区，每一种又可以根据业务的需求进行一些特殊的定制化功能，由此衍生出更多的变种</p>
<hr>
<h4 id="主备复制"><a href="#主备复制" class="headerlink" title="主备复制"></a>主备复制</h4><p>主备复制架构的优点就是简单，表现有：</p>
<ul>
<li>对于客户端来说，不需要感知备机的存在，即使灾难恢复后，原来的备机被人工修改为主机后，对于客户端来说，只是认为主机的地址换了而已，无须知道是原来的备机升级为主机。</li>
<li>对于主机和备机来说，双方只需要进行数据复制即可，无须进行状态判断和主备切换这类复杂的操作。</li>
</ul>
<p>主备复制架构的缺点主要有：</p>
<ul>
<li>备机仅仅只为备份，并没有提供读写操作，硬件成本上有浪费。</li>
<li>故障后需要人工干预，无法自动恢复。人工处理的效率是很低的，可能打电话找到能够操作的人就耗费了 10 分钟，甚至如果是深更半夜，出了故障都没人知道。人工在执行恢复操作的过程中也容易出错，因为这类操作并不常见，可能 1 年就 2、3 次，实际操作的时候很可能遇到各种意想不到的问题。</li>
</ul>
<hr>
<h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p>主从复制与主备复制相比，优点有：</p>
<ul>
<li>主从复制在主机故障时，读操作相关的业务可以继续运行。</li>
<li>主从复制架构的从机提供读操作，发挥了硬件的性能。</li>
</ul>
<p>缺点有：</p>
<ul>
<li>主从复制架构中，客户端需要感知主从关系，并将不同的操作发给不同的机器进行处理，复杂度比主备复制要高。</li>
<li>主从复制架构中，从机提供读业务，如果主从复制延迟比较大，业务会因为数据不一致出现问题。</li>
<li>故障时需要人工干预。</li>
</ul>
<hr>
<h3 id="双机切换"><a href="#双机切换" class="headerlink" title="双机切换"></a>双机切换</h3><ol>
<li>主备间状态判断：状态传递的渠道、状态检测的内容</li>
<li>切换决策：切换时机、切换策略、自动程度。</li>
<li>数据冲突解决</li>
</ol>
<hr>
<h4 id="状态传递渠道"><a href="#状态传递渠道" class="headerlink" title="状态传递渠道"></a>状态传递渠道</h4><p>根据状态传递渠道的不同，常见的主备切换架构有三种形式：互连式、中介式和模拟式。</p>
<hr>
<h5 id="互连式"><a href="#互连式" class="headerlink" title="互连式"></a>互连式</h5><p>为了充分利用切换方案能够自动决定主机这个优势，客户端这里也会有一些相应的改变，常见的方式有：</p>
<ul>
<li>为了切换后不影响客户端的访问，主机和备机之间共享一个对客户端来说唯一的地址。例如虚拟 IP，主机需要绑定这个虚拟的 IP。</li>
<li>客户端同时记录主备机的地址，哪个能访问就访问哪个；备机虽然能收到客户端的操作请求，但是会直接拒绝，拒绝的原因就是“备机不对外提供服务”。</li>
</ul>
<p>互连式主备切换主要的缺点在于：</p>
<ul>
<li>如果状态传递的通道本身有故障（例如，网线被人不小心踢掉了），那么备机也会认为主机故障了从而将自己升级为主机，而此时主机并没有故障，最终就可能出现两个主机。</li>
<li>虽然可以通过增加多个通道来增强状态传递的可靠性，但这样做只是降低了通道故障概率而已，不能从根本上解决这个缺点，而且通道越多，后续的状态决策会更加复杂，因为对备机来说，可能从不同的通道收到了不同甚至矛盾的状态信息。</li>
</ul>
<hr>
<h5 id="中介式"><a href="#中介式" class="headerlink" title="中介式"></a>中介式</h5><p>中介式指的是在主备两者之外引入第三方中介，主备机之间不直接连接，而都去连接中介，并且通过中介来传递状态信息</p>
<ul>
<li><strong>连接管理更简单</strong>：主备机无须再建立和管理多种类型的状态传递连接通道，只要连接到中介即可，实际上是降低了主备机的连接管理复杂度。</li>
<li><strong>状态决策更简单</strong>：主备机的状态决策简单了，无须考虑多种类型的连接通道获取的状态信息如何决策的问题，只需要按照下面简单的算法即可完成状态决策。</li>
</ul>
<p>缺点：为了实现高可用，我们引入中介，但中介本身又要求高可用，于是又要设计中介的高可用方案</p>
<hr>
<h5 id="模拟式"><a href="#模拟式" class="headerlink" title="模拟式"></a>模拟式</h5><p>模拟式指主备机之间并不传递任何状态数据，而是备机模拟成一个客户端，向主机发起模拟的读写操作</p>
<p>模拟式切换与互连式切换相比，优点是实现更加简单，因为省去了状态传递通道的建立和管理工作。</p>
<p>简单既是优点，同时也是缺点。因为模拟式读写操作获取的状态信息只有响应信息，没有互连式那样多样，基于有限的状态来做状态决策，可能出现偏差。</p>
<hr>
<h4 id="主主复制"><a href="#主主复制" class="headerlink" title="主主复制"></a>主主复制</h4><p>相比主备切换架构，主主复制架构具有如下特点：</p>
<ul>
<li>两台都是主机，不存在切换的概念。</li>
<li>客户端无须区分不同角色的主机，随便将读写操作发送给哪台主机都可以。</li>
</ul>
<p>主主复制架构对数据的设计有严格的要求，一般适合于那些临时性、可丢失、可覆盖的数据场景。</p>
<hr>
<h3 id="集群和分区"><a href="#集群和分区" class="headerlink" title="集群和分区"></a>集群和分区</h3><p>高可用存储架构也分为2类：数据集群和数据分区。</p>
<hr>
<h4 id="数据集群"><a href="#数据集群" class="headerlink" title="数据集群"></a>数据集群</h4><ul>
<li>数据集中集群<ul>
<li>主机如何将数据复制给备机</li>
<li>备机如何检测主机状态</li>
<li>主机故障后，如何决定新的主机</li>
</ul>
</li>
<li>数据分散集群<ul>
<li>均衡性</li>
<li>容错性</li>
<li>可伸缩性</li>
</ul>
</li>
</ul>
<hr>
<h4 id="数据分区"><a href="#数据分区" class="headerlink" title="数据分区"></a>数据分区</h4><p>需要考虑的核心点：数据量、分区规则、复制规则</p>
<p>常见的分区复制规则有三种：集中式、互备式和独立式。</p>
<hr>
<h5 id="集中式"><a href="#集中式" class="headerlink" title="集中式"></a>集中式</h5><p>集中式备份架构的优缺点是：</p>
<ul>
<li>设计简单，各分区之间并无直接联系，可以做到互不影响。</li>
<li>扩展容易，如果要增加第四个分区（例如，武汉分区），只需要将武汉分区的数据复制到西安备份中心即可，其他分区不受影响。</li>
<li>成本较高，需要建设一个独立的备份中心。</li>
</ul>
<hr>
<h5 id="互备式"><a href="#互备式" class="headerlink" title="互备式"></a>互备式</h5><p>互备式备份架构的优缺点是：</p>
<ul>
<li>设计比较复杂，各个分区除了要承担业务数据存储，还需要承担备份功能，相互之间互相关联和影响。</li>
<li>扩展麻烦，如果增加一个武汉分区，则需要修改广州分区的复制指向武汉分区，然后将武汉分区的复制指向北京分区。而原有北京分区已经备份了的广州分区的数据怎么处理也是个难题，不管是做数据迁移，还是广州分区历史数据保留在北京分区，新数据备份到武汉分区，无论哪种方式都很麻烦。</li>
<li>成本低，直接利用已有的设备。</li>
</ul>
<hr>
<h5 id="独立式"><a href="#独立式" class="headerlink" title="独立式"></a>独立式</h5><p>独立式备份架构的优缺点是：</p>
<ul>
<li>设计简单，各分区互不影响。</li>
<li>扩展容易，新增加的分区只需要搭建自己的备份中心即可。</li>
<li>成本高，每个分区需要独立的备份中心，备份中心的场地成本是主要成本，因此独立式比集中式成本要高很多。</li>
</ul>
<hr>
<h4 id="计算高可用"><a href="#计算高可用" class="headerlink" title="计算高可用"></a>计算高可用</h4><p>计算高可用架构的设计复杂度主要体现在<strong>任务管理</strong>方面，即当任务在某台服务器上执行失败后，如何将任务重新分配到新的服务器进行执行。</p>
<ol>
<li>哪些服务器可以执行任务，</li>
<li>任务如何重新执行</li>
</ol>
<p>计算高可用框架也分为三类：</p>
<ol>
<li>主备架构，备机在故障时才进行启用</li>
<li>主从架构，备机会参与任务执行</li>
<li>集群架构：对称集群、非对称集群。减少人工介入，更多的由机器来进行任务分发。</li>
</ol>
<hr>
<h3 id="异地多活"><a href="#异地多活" class="headerlink" title="异地多活"></a>异地多活</h3><ol>
<li><p>同城异区</p>
</li>
<li><p>跨城异地</p>
</li>
<li><p>跨国异地</p>
</li>
</ol>
<hr>
<h4 id="异地多活设计4大技巧"><a href="#异地多活设计4大技巧" class="headerlink" title="异地多活设计4大技巧"></a>异地多活设计4大技巧</h4><ol>
<li><p>同城异区</p>
<p>关键在于搭建高速网络将两个机房连接起来，达到近似一个本地机房的效果。架构设计上可以将两个机房当作本地机房来设计，无须额外考虑。</p>
</li>
<li><p>跨城异地</p>
<p>关键在于数据不一致的情况下，业务不受影响或者影响很小，这从逻辑的角度上来说其实是矛盾的，架构设计的主要目的就是为了解决这个矛盾。</p>
</li>
<li><p>跨国异地</p>
<p>主要是面向不同地区用户提供业务，或者提供只读业务，对架构设计要求不高。</p>
</li>
</ol>
<hr>
<h4 id="异地多活设计4大技巧-1"><a href="#异地多活设计4大技巧-1" class="headerlink" title="异地多活设计4大技巧"></a>异地多活设计4大技巧</h4><p>技巧 1：保证核心业务的异地多活</p>
<p>技巧 2：保证核心数据最终一致性</p>
<p>技巧 3：采用多种手段同步数据（队列、二次读取、存储同步、回源读取、重新生成）</p>
<p>技巧 4：只保证绝大部分用户的异地多活</p>
<hr>
<h4 id="异地多活设计4步走"><a href="#异地多活设计4步走" class="headerlink" title="异地多活设计4步走"></a>异地多活设计4步走</h4><p>第 1 步：业务分级（访问量大的业务、核心业务、产生大量收入的业务）</p>
<p>第 2 步：数据分类（数据量、唯一性、实时性、可丢失性、可恢复性）</p>
<p>第 3 步：数据同步（存储系统、消息队列、重复生成）</p>
<p>第 4 步：异常处理（多通道同步、同步和访问结合、日志记录、用户补偿）</p>
<hr>
<h3 id="接口级的故障"><a href="#接口级的故障" class="headerlink" title="接口级的故障"></a>接口级的故障</h3><p>降级：系统将某些业务或者接口的功能降低，可以是只提供部分功能，也可以是完全停掉所有功能</p>
<p>熔断：降级的目的是应对系统自身的故障，而熔断的目的是应对依赖的外部系统故障的情况。</p>
<p>限流：只允许系统能够承受的访问量进来，超出系统访问能力的请求将被丢弃。</p>
<p>排队：临时缓存大量的业务请求</p>
<hr>
<h2 id="可扩展的基本思想"><a href="#可扩展的基本思想" class="headerlink" title="可扩展的基本思想"></a>可扩展的基本思想</h2><p>所有的可扩展性架构设计，背后的基本思想都可以总结为一个字：拆！</p>
<ol>
<li>面向流程拆分：将整个业务流程拆分为几个阶段，每个阶段作为一部分。（TCP）</li>
<li>面向服务拆分：将系统提供的服务拆分，每个服务作为一部分。（京东的支付和商城）</li>
<li>面向功能拆分：将系统提供的功能拆分，每个功能作为一部分。（京东用户系统里面的查询和注册）</li>
</ol>
<blockquote>
<p>不同的拆分方式，本质上决定了系统的扩展方式。</p>
</blockquote>
<hr>
<h3 id="可扩展方式"><a href="#可扩展方式" class="headerlink" title="可扩展方式"></a>可扩展方式</h3><p><strong>面向流程拆分：</strong>分层架构。</p>
<p><strong>特点：</strong>扩展时大部分情况只需要修改某一层，少部分情况可能修改关联的两层</p>
<p><strong>面向服务拆分：</strong>SOA、微服务。</p>
<p><strong>特点：</strong>对某个服务扩展，或者要增加新的服务时，只需要扩展相关服务即可，无须修改所有的服务。</p>
<p><strong>面向功能拆分：</strong>微内核架构。</p>
<p><strong>特点：</strong>对某个功能扩展，或者要增加新的功能时，只需要扩展相关功能即可，无须修改所有的服务。</p>
<hr>
<h4 id="微服务架构最佳实践"><a href="#微服务架构最佳实践" class="headerlink" title="微服务架构最佳实践"></a>微服务架构最佳实践</h4><p>实施微服务需要避免踩的陷阱，简单提炼为：</p>
<ol>
<li>微服务拆分过细，过分强调“small”。</li>
<li>微服务基础设施不健全，忽略了“automated”。</li>
<li>微服务并不轻量级，规模大了后，“lightweight”不再适应。</li>
</ol>
<hr>
<h4 id="微服务架构基础设施"><a href="#微服务架构基础设施" class="headerlink" title="微服务架构基础设施"></a>微服务架构基础设施</h4><p>自动化部署：包括版本管理、资源管理（例如，机器管理、虚拟机管理）、部署操作、回退操作等功能。</p>
<p>配置中心：配置版本管理、增删改查配置、节点管理、配置同步、配置推送等功能。</p>
<p>接口框架：以库或者包的形式提供给所有微服务调用</p>
<p>API 网关：接入鉴权（是否允许接入）、权限控制（可以访问哪些功能）、传输加密、请求路由、流量控制等功能。</p>
<p>服务发现：需要一套服务发现的系统来支撑微服务的自动注册和发现</p>
<p>服务路由：从所有符合条件的可用微服务节点中挑选出一个具体的节点发起请求</p>
<p>服务容错：请求重试、流控和服务隔离</p>
<p>服务监控：实时搜集信息并进行分析、监控预警</p>
<p>服务跟踪：在大量微服务系统中快速定位问题</p>
<p>服务安全：接入安全、数据安全、传输安全</p>
<hr>
<h4 id="微内核架构详解"><a href="#微内核架构详解" class="headerlink" title="微内核架构详解"></a>微内核架构详解</h4><blockquote>
<p> 微内核架构（Microkernel Architecture），也被称为插件化架构（Plug-in Architecture），是一种面向功能进行拆分的可扩展性架构</p>
</blockquote>
<p>微内核的核心系统设计的关键技术有：插件管理、插件连接和插件通信。</p>
<ol>
<li><p>插件管理</p>
</li>
<li><p>插件连接</p>
</li>
<li><p>插件通信</p>
</li>
</ol>

  </section>
  <footer class="post-footer">
    <!--
    <section class="author">
      <h4>Skyfire Lee</h4>
      <p></p>
    </section>
    -->
  </footer>
</article>

<nav class="pagination" role="pagination">
    
    <a class="newer-posts" href="/2022/04/28/my-vim-config/">
        ← prev <!--VIM配置分享-->
    </a>
    
    <span class="page-number">•</span>
    
    <a class="older-posts" href="/2021/09/17/re0-redis-expire/">
        <!--Redis淘汰机制--> next →
    </a>
    
</nav>


        </main>
        <footer id="footer">
            <section id="footer-message">&copy; 2022 Skyfire Lee. All rights reserved. Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. <a href="https://github.com/guolin/crisp-hexo-theme" target="_blank">crisp</a> theme by <a href="guolin.github.io" target="_blank">Guo Lin</a>.</section>
        </footer>
    </body>
</html>


