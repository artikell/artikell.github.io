<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta http-equiv="X-UA-Compatible" content="ie=edge" />
<link rel="stylesheet" href="/_assets/main.css" />

    <title>Redis Lua &amp; Function(30%) - Artikell‘s home</title>
  <link rel="stylesheet" href="/_markdown_plugin_assets/highlight.js/atom-one-light.css" /></head>
  <body>
    <div class="main">
      <nav class="navigation">
        <a href="/">Artikell‘s home</a>
      </nav>
      <article>
        <header>
          <h1 class="article-title">Redis Lua &amp; Function(30%)</h1>
          <div class="article-info">
            <div>
              <span
                >Created At：<time datetime="1666916197616"
                  >2022-10-28 08:16</time
                ></span
              >
              <span
                >Updated At：<time datetime="1667348779020"
                  >2022-11-02 08:26</time
                ></span
              >
            </div>
            
          </div>
        </header>
        <div class="article-content markdown-body"><h2 id="介绍顺序">介绍顺序</h2>
<ul>
<li>怎么用Lua和Funciton？</li>
<li>Lua能做什么？</li>
<li>Redis如何和Lua配合的？</li>
<li>Redis中</li>
</ul>
<h2 id="redis和lua功能">Redis和Lua功能</h2>
<h3 id="在redis使用lua脚本的好处">在redis使用lua脚本的好处</h3>
<ul>
<li>减少网络开销。可以将多个请求通过脚本的形式一次发送，减少网络时延。</li>
<li>原子操作。Redis会将整个脚本作为一个整体执行，中间不会被其他请求插入。因此在脚本运行过程中无需担心会出现竞态条件，无需使用事务。</li>
<li>复用。客户端发送的脚本会永久存在redis中，这样其他客户端可以复用这一脚本，而不需要使用代码完成相同的逻辑。</li>
</ul>
<h3 id="在redis中使用lua脚本">在redis中使用lua脚本</h3>
<p>简单介绍一下lua的常见命令，命令不多，就下面这几个：</p>
<ul>
<li>EVAL</li>
<li>EVALSHA</li>
<li>SCRIPT LOAD - SCRIPT EXISTS</li>
<li>SCRIPT FLUSH</li>
<li>SCRIPT KILL</li>
</ul>
<h4 id="eval命令">EVAL命令</h4>
<div><pre class="hljs"><code>命令格式：EVAL script numkeys key <span class="hljs-selector-attr">[key …]</span> arg <span class="hljs-selector-attr">[arg …]</span></code></pre></div>
<ul>
<li>script参数是一段 Lua5.1 脚本程序。脚本不必(也不应该[^1])定义为一个 Lua 函数\</li>
<li>numkeys指定后续参数有几个key，即：key [key …]中key的个数。如没有key，则为0\</li>
<li>key [key …] 从 EVAL 的第三个参数开始算起，表示在脚本中所用到的那些 Redis 键(key)。在Lua脚本中通过KEYS[1], KEYS[2]获取。\</li>
<li>arg [arg …] 附加参数。在Lua脚本中通过ARGV[1],ARGV[2]获取。</li>
</ul>
<h5 id="错误处理">错误处理</h5>
<p>当 redis.call() 在执行命令的过程中发生错误时，脚本会停止执行，并返回一个脚本错误，错误的输出信息会说明错误造成的原因：</p>
<div><pre class="hljs"><code><span class="hljs-number">127.0.0.1:6379</span>&gt; lpush foo a
(integer) <span class="hljs-number">1</span>

<span class="hljs-number">127.0.0.1:6379</span>&gt; eval <span class="hljs-string">"return redis.call('get', 'foo')"</span> <span class="hljs-number">0</span>
(error) ERR Error running script (call to f_282297a0228f48cd3fc6a55de6316f31422f5d17): ERR Operation against a key holding the wrong kind of value</code></pre></div>
<p>和 redis.call() 不同， redis.pcall() 出错时并不引发(raise)错误，而是返回一个带 err 域的 Lua 表(table)，用于表示错误：</p>
<div><pre class="hljs"><code><span class="hljs-number">127.0.0.1:6379</span>&gt; EVAL <span class="hljs-string">"return redis.pcall('get', 'foo')"</span> <span class="hljs-number">0</span>
(error) ERR Operation against a key holding the wrong kind of value</code></pre></div>
<h4 id="script-load命令-和-evalsha命令">SCRIPT LOAD命令 和 EVALSHA命令</h4>
<div><pre class="hljs"><code>SCRIPT <span class="hljs-keyword">LOAD</span>命令格式：SCRIPT <span class="hljs-keyword">LOAD</span> script
EVALSHA命令格式：EVALSHA sha1 numkeys <span class="hljs-built_in">key</span> [<span class="hljs-built_in">key</span> …] arg [arg …]</code></pre></div>
<p>这两个命令放在一起讲的原因是：EVALSHA 命令中的sha1参数，就是SCRIPT LOAD 命令执行的结果。</p>
<p>SCRIPT LOAD 将脚本 script 添加到Redis服务器的脚本缓存中，并不立即执行这个脚本，而是会立即对输入的脚本进行求值。并返回给定脚本的 SHA1 校验和。如果给定的脚本已经在缓存里面了，那么不执行任何操作。</p>
<p>在脚本被加入到缓存之后，在任何客户端通过EVALSHA命令，可以使用脚本的 SHA1 校验和来调用这个脚本。脚本可以在缓存中保留无限长的时间，直到执行SCRIPT FLUSH为止。</p>
<div><pre class="hljs"><code>## SCRIPT LOAD加载脚本，并得到sha1值
<span class="hljs-number">127.0.0.1:6379</span>&gt; SCRIPT LOAD <span class="hljs-string">"redis.call('SET', KEYS[1], ARGV[1]);redis.call('EXPIRE', KEYS[1], ARGV[2]); return 1;"</span>
<span class="hljs-string">"6aeea4b3e96171ef835a78178fceadf1a5dbe345"</span>

## EVALSHA使用sha1值，并拼装和EVAL类似的numkeys和key数组、arg数组，调用脚本。
<span class="hljs-number">127.0.0.1:6379</span>&gt; EVALSHA 6aeea4b3e96171ef835a78178fceadf1a5dbe345 <span class="hljs-number">1</span> userAge <span class="hljs-number">10</span> <span class="hljs-number">60</span>
(integer) <span class="hljs-number">1</span>
<span class="hljs-number">127.0.0.1:6379</span>&gt; get userAge
<span class="hljs-string">"10"</span>
<span class="hljs-number">127.0.0.1:6379</span>&gt; ttl userAge
(integer) <span class="hljs-number">50</span></code></pre></div>
<h4 id="script-exists-命令">SCRIPT EXISTS 命令</h4>
<div><pre class="hljs"><code>命令格式：<span class="hljs-keyword">SCRIPT </span>EXISTS <span class="hljs-keyword">sha1 </span>[<span class="hljs-keyword">sha1 </span>…]</code></pre></div>
<p>作用：给定一个或多个脚本的 SHA1 校验和，返回一个包含 0 和 1 的列表，表示校验和所指定的脚本是否已经被保存在缓存当中</p>
<div><pre class="hljs"><code><span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; SCRIPT EXISTS <span class="hljs-number">6</span>aeea4b3e96171ef835a78178fceadf1a5dbe345
<span class="hljs-attribute">1</span>) (integer) <span class="hljs-number">1</span>
<span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; SCRIPT EXISTS <span class="hljs-number">6</span>aeea4b3e96171ef835a78178fceadf1a5dbe346
<span class="hljs-attribute">1</span>) (integer) <span class="hljs-number">0</span>
<span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; SCRIPT EXISTS <span class="hljs-number">6</span>aeea4b3e96171ef835a78178fceadf1a5dbe345 <span class="hljs-number">6</span>aeea4b3e96171ef835a78178fceadf1a5dbe366
<span class="hljs-attribute">1</span>) (integer) <span class="hljs-number">1</span>
<span class="hljs-attribute">2</span>) (integer) <span class="hljs-number">0</span></code></pre></div>
<h4 id="script-flush-命令">SCRIPT FLUSH 命令</h4>
<div><pre class="hljs"><code>命令格式：SCRIPT <span class="hljs-keyword">FLUSH</span></code></pre></div>
<p>作用：清除Redis服务端所有 Lua 脚本缓存</p>
<div><pre class="hljs"><code><span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; SCRIPT EXISTS <span class="hljs-number">6</span>aeea4b3e96171ef835a78178fceadf1a5dbe345
<span class="hljs-attribute">1</span>) (integer) <span class="hljs-number">1</span>
<span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; SCRIPT FLUSH
<span class="hljs-attribute">OK</span>
<span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; SCRIPT EXISTS <span class="hljs-number">6</span>aeea4b3e96171ef835a78178fceadf1a5dbe345
<span class="hljs-attribute">1</span>) (integer) <span class="hljs-number">0</span></code></pre></div>
<h4 id="script-kill-命令">SCRIPT KILL 命令</h4>
<div><pre class="hljs"><code>命令格式：SCRIPT <span class="hljs-keyword">FLUSH</span></code></pre></div>
<p>作用：杀死当前正在运行的 Lua 脚本，当且仅当这个脚本没有执行过任何写操作时，这个命令才生效。 这个命令主要用于终止运行时间过长的脚本，比如一个因为 BUG 而发生无限 loop 的脚本，诸如此类。</p>
<p>假如当前正在运行的脚本已经执行过写操作，那么即使执行SCRIPT KILL，也无法将它杀死，因为这是违反 Lua 脚本的原子性执行原则的。在这种情况下，唯一可行的办法是使用SHUTDOWN NOSAVE命令，通过停止整个 Redis 进程来停止脚本的运行，并防止不完整(half-written)的信息被写入数据库中。</p>
<h3 id="lua-脚本的问题">Lua 脚本的问题</h3>
<p>脚本必须完整的发送到服务端，虽然 Lua 脚本可以被缓存，但是可能随时丢失，比如：</p>
<ul>
<li>重启 Server</li>
<li>SCRIPT FLUSH</li>
<li>Fail over to replica</li>
</ul>
<p>脚本的设计理念是由应用端维护而不是 server，这又带来另一些问题：</p>
<ul>
<li>客户端必须维护所有的脚本，保证脚本的版本是最新的</li>
<li>脚本的缓存失效提高了 Transactions （MULTIEXECDISCARDWATCH）的失败率</li>
<li>增加了调试的难度</li>
<li>在 script 中不能调用其它 script，降低了可重用性、可维护性</li>
</ul>
<h2 id="redis和function功能">Redis和Function功能</h2>
<h3 id="数据模型">数据模型</h3>
<h3 id="命令介绍">命令介绍</h3>
<p>简单介绍一下function的常见命令，命令不多，就下面这几个：</p>
<ul>
<li>FCALL: 调用函数</li>
<li>FCALL_RO：调用只读函数</li>
<li>FUNCTION DELETE: 按名称删除函数</li>
<li>FUNCTION DUMP: 将所有函数转储到序列化的二进制负载中</li>
<li>FUNCTION FLUSH: 删除所有功能</li>
<li>FUNCTION KILL: 终止当前正在执行的函数。</li>
<li>FUNCTION LIST: 列出所有功能的信息</li>
<li>FUNCTION LOAD: 使用给定的参数（名称、代码、描述）创建函数</li>
<li>FUNCTION RESTORE: 恢复给定有效负载上的所有功能</li>
<li>FUNCTION STATS: 返回有关当前运行的函数的信息（名称、描述、持续时间）</li>
</ul>
<h4 id="function-load加载">FUNCTION LOAD加载</h4>
<div><pre class="hljs"><code>redis&gt; <span class="hljs-keyword">FUNCTION</span> <span class="hljs-keyword">LOAD</span> Lua mylib ""
(error) ERR <span class="hljs-keyword">No</span> <span class="hljs-keyword">functions</span> registered</code></pre></div>
<p>Lua 表示加载引擎，mylib 是库名，后面跟着源码，</p>
<p>每个库至少要有一个注册方法，注册方法是 redis.register_function() ，所以上述例子失败了。</p>
<p>以下是成功的示例：</p>
<div><pre class="hljs"><code>redis&gt; <span class="hljs-keyword">FUNCTION</span> <span class="hljs-title">LOAD</span> Lua mylib "redis.register_function('knockknock', <span class="hljs-keyword">function</span>() <span class="hljs-keyword">return</span> <span class="hljs-type">'Who\\'s</span> there?' <span class="hljs-keyword">end</span>)<span class="hljs-string">"
OK
redis&gt; FCALL knockknock 0
"</span>Who<span class="hljs-symbol">'s</span> there?<span class="hljs-string">"</span></code></pre></div>
<p>redis.register_function 的第一个参数是函数名，第二参数是回调方法。注意 FCALL 至少有两个参数，第二个参数是 key 的数量，和 eval 一样，用来区分后续的参数有多少个是 key。</p>
<p>你也可以通过文件的方式导入函数：</p>
<div><pre class="hljs"><code>$ <span class="hljs-keyword">cat</span> mylib.lua | redis-<span class="hljs-keyword">cli</span> -x FUNCTION LOAD Lua mylib <span class="hljs-keyword">REPLACE</span> DESCRIPTION <span class="hljs-string">"My application's Hash data type enhancements"</span></code></pre></div>
<p>如果需要查看加载的函数，可以通过 FUNCTION LIST 。</p>
<h2 id="lua原理">Lua原理</h2>
<p>lua的优点</p>
<ul>
<li>可移植性</li>
<li>容易嵌入</li>
<li>体积小</li>
<li>高效率</li>
</ul>
<p>这些优点都来自于lua的设计目标：简洁。从Scheme获得了很多灵感，包括匿名函数，合理的语义域概念</p>
<p><img src="/_resources/824b1641df8c4e3a9b8a927ad6a34be6.png" /></p>
<h2 id="redis的lua原理">Redis的Lua原理</h2>
<h2 id="参考文献">参考文献</h2>
<p><a title="https://www.51cto.com/article/286631.html" href="https://www.51cto.com/article/286631.html">详解关于Lua源码分析学习教程-51CTO.COM</a></p>
</div>
      </article>
    </div>
  </body>
</html>
